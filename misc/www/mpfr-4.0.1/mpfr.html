<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version 4.0.1.

Copyright 1991, 1993-2018 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with no Front-Cover Texts, and with no Back-Cover Texts.  A copy of the
license is included in GNU Free Documentation License. -->
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>GNU MPFR 4.0.1</title>

<meta name="description" content="How to install and use GNU MPFR, a library for reliable multiple precision
floating-point arithmetic, version 4.0.1.">
<meta name="keywords" content="GNU MPFR 4.0.1">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#Concept-Index" rel="index" title="Concept Index">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">GNU MPFR 4.0.1</h1>







<a name="Top"></a>
<div class="header">
<p>
Next: <a href="#Copying" accesskey="n" rel="next">Copying</a>, Previous: <a href="dir.html#Top" accesskey="p" rel="prev">(dir)</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="GNU-MPFR"></a>
<h1 class="top">GNU MPFR</h1>


<p>This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version 4.0.1.
</p>
<p>Copyright 1991, 1993-2018 Free Software Foundation, Inc.
</p>
<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with no Front-Cover Texts, and with no Back-Cover Texts.  A copy of the
license is included in <a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>.
</p>
<br>



<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Copying" accesskey="1">Copying</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">MPFR Copying Conditions (LGPL).
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Introduction-to-MPFR" accesskey="2">Introduction to MPFR</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Brief introduction to GNU MPFR.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installing-MPFR" accesskey="3">Installing MPFR</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">How to configure and compile the MPFR library.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reporting-Bugs" accesskey="4">Reporting Bugs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">How to usefully report bugs.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#MPFR-Basics" accesskey="5">MPFR Basics</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">What every MPFR user should now.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#MPFR-Interface" accesskey="6">MPFR Interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">MPFR functions and macros.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#API-Compatibility" accesskey="7">API Compatibility</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">API compatibility with previous MPFR versions.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#MPFR-and-the-IEEE-754-Standard" accesskey="8">MPFR and the IEEE 754 Standard</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Contributors" accesskey="9">Contributors</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#References">References</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Concept-Index">Concept Index</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Function-and-Type-Index">Function and Type Index</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>










<hr>
<a name="Copying"></a>
<div class="header">
<p>
Next: <a href="#Introduction-to-MPFR" accesskey="n" rel="next">Introduction to MPFR</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="MPFR-Copying-Conditions"></a>
<h2 class="unnumbered">MPFR Copying Conditions</h2>
<a name="index-Copying-conditions"></a>
<a name="index-Conditions-for-copying-MPFR"></a>

<p>The GNU MPFR library (or MPFR for short)
is <em>free</em>; this means that everyone is free to use it and
free to redistribute it on a free basis.  The library is not in the public
domain; it is copyrighted and there are restrictions on its distribution, but
these restrictions are designed to permit everything that a good cooperating
citizen would want to do.  What is not allowed is to try to prevent others
from further sharing any version of this library that they might get from
you.
</p>
<p>Specifically, we want to make sure that you have the right to give away copies
of the library, that you receive source code or else can get it if you want
it, that you can change this library or use pieces of it in new free programs,
and that you know you can do these things.
</p>
<p>To make sure that everyone has such rights, we have to forbid you to deprive
anyone else of these rights.  For example, if you distribute copies of the
GNU MPFR library, you must give the recipients all the rights that you have.
You must make sure that they, too, receive or can get the source code.  And you
must tell them their rights.
</p>
<p>Also, for our own protection, we must make certain that everyone finds out
that there is no warranty for the GNU MPFR library.  If it is modified by
someone else and passed on, we want their recipients to know that what they
have is not what we distributed, so that any problems introduced by others
will not reflect on our reputation.
</p>
<p>The precise conditions of the license for the GNU MPFR library are found in the
Lesser General Public License that accompanies the source code.
See the file COPYING.LESSER.
</p>
<hr>
<a name="Introduction-to-MPFR"></a>
<div class="header">
<p>
Next: <a href="#Installing-MPFR" accesskey="n" rel="next">Installing MPFR</a>, Previous: <a href="#Copying" accesskey="p" rel="prev">Copying</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Introduction-to-MPFR-1"></a>
<h2 class="chapter">1 Introduction to MPFR</h2>


<p>MPFR is a portable library written in C for arbitrary precision arithmetic
on floating-point numbers. It is based on the GNU MP library.
It aims to provide a class of floating-point numbers with
precise semantics. The main characteristics of MPFR, which make it differ
from most arbitrary precision floating-point software tools, are:
</p>
<ul>
<li> the MPFR code is portable, i.e., the result of any operation
does not depend on the machine word size
<code>mp_bits_per_limb</code> (64 on most current processors), possibly
except in faithful rounding.
It does not depend either on the machine rounding mode or rounding precision;

</li><li> the precision in bits can be set <em>exactly</em> to any valid value
for each variable (including very small precision);

</li><li> MPFR provides the four rounding modes from the IEEE 754-1985
standard, plus away-from-zero, as well as for basic operations as for other
mathematical functions. Faithful rounding (partially supported) is provided
too, but the results may no longer be reproducible.

</li></ul>

<p>In particular, with a precision of 53 bits and in any of the four standard
rounding modes, MPFR is able to
exactly reproduce all computations with double-precision machine
floating-point numbers (e.g., <code>double</code> type in C, with a C
implementation that rigorously follows Annex F of the ISO C99 standard
and <code>FP_CONTRACT</code> pragma set to <code>OFF</code>) on the four arithmetic
operations and the square root, except the default exponent range is much
wider and subnormal numbers are not implemented (but can be emulated).
</p>
<p>This version of MPFR is released under the GNU Lesser General Public
License, version 3 or any later version.
It is permitted to link MPFR to most non-free programs, as long as when
distributing them the MPFR source code and a means to re-link with a
modified MPFR library is provided.
</p>
<a name="How-to-Use-This-Manual"></a>
<h3 class="section">1.1 How to Use This Manual</h3>

<p>Everyone should read <a href="#MPFR-Basics">MPFR Basics</a>.  If you need to install the library
yourself, you need to read <a href="#Installing-MPFR">Installing MPFR</a>, too.
To use the library you will need to refer to <a href="#MPFR-Interface">MPFR Interface</a>.
</p>
<p>The rest of the manual can be used for later reference, although it is
probably a good idea to glance through it.
</p>
<hr>
<a name="Installing-MPFR"></a>
<div class="header">
<p>
Next: <a href="#Reporting-Bugs" accesskey="n" rel="next">Reporting Bugs</a>, Previous: <a href="#Introduction-to-MPFR" accesskey="p" rel="prev">Introduction to MPFR</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Installing-MPFR-1"></a>
<h2 class="chapter">2 Installing MPFR</h2>
<a name="index-Installation"></a>

<p>The MPFR library is already installed on some GNU/Linux distributions,
but the development files necessary to the compilation such as
<samp>mpfr.h</samp> are not always present. To check that MPFR is fully
installed on your computer, you can check the presence of the file
<samp>mpfr.h</samp> in <samp>/usr/include</samp>, or try to compile a small program
having <code>#include &lt;mpfr.h&gt;</code> (since <samp>mpfr.h</samp> may be installed
somewhere else). For instance, you can try to compile:
</p>
<div class="example">
<pre class="example">#include &lt;stdio.h&gt;
#include &lt;mpfr.h&gt;
int main (void)
{
  printf (&quot;MPFR library: %-12s\nMPFR header:  %s (based on %d.%d.%d)\n&quot;,
          mpfr_get_version (), MPFR_VERSION_STRING, MPFR_VERSION_MAJOR,
          MPFR_VERSION_MINOR, MPFR_VERSION_PATCHLEVEL);
  return 0;
}
</pre></div>

<p>with
</p>
<div class="example">
<pre class="example">cc -o version version.c -lmpfr -lgmp
</pre></div>

<p>and if you get errors whose first line looks like
</p>
<div class="example">
<pre class="example">version.c:2:19: error: mpfr.h: No such file or directory
</pre></div>

<p>then MPFR is probably not installed. Running this program will give you
the MPFR version.
</p>
<p>If MPFR is not installed on your computer, or if you want to install a
different version, please follow the steps below.
</p>
<a name="How-to-Install"></a>
<h3 class="section">2.1 How to Install</h3>

<p>Here are the steps needed to install the library on Unix systems
(more details are provided in the <samp>INSTALL</samp> file):
</p>
<ol>
<li> To build MPFR, you first have to install GNU MP
(version 4.1 or higher) on your computer.
You need a C compiler, preferably GCC, but any reasonable compiler should
work.  And you need the standard Unix &lsquo;<samp>make</samp>&rsquo; command, plus some other
standard Unix utility commands.

<p>Then, in the MPFR build directory, type the following commands.
</p>
</li><li> &lsquo;<samp>./configure</samp>&rsquo;

<p>This will prepare the build and setup the options according to your system.
You can give options to specify the install directories (instead of
the default <samp>/usr/local</samp>), threading support, and so on. See
the <samp>INSTALL</samp> file and/or the output of &lsquo;<samp>./configure --help</samp>&rsquo;
for more information, in particular if you get error messages.
</p>
</li><li> &lsquo;<samp>make</samp>&rsquo;

<p>This will compile MPFR, and create a library archive file <samp>libmpfr.a</samp>.
On most platforms, a dynamic library will be produced too.
</p>
</li><li> &lsquo;<samp>make check</samp>&rsquo;

<p>This will make sure that MPFR was built correctly.
If any test fails, information about this failure can be found in the
<samp>tests/test-suite.log</samp> file. If you want the contents of this file to
be automatically output in case of failure, you can set the &lsquo;<samp>VERBOSE</samp>&rsquo;
environment variable to 1 before running &lsquo;<samp>make check</samp>&rsquo;, for instance
by typing:
</p>
<p>&lsquo;<samp>VERBOSE=1 make check</samp>&rsquo;
</p>
<p>In case of failure, you may want to check whether the problem is already
known. If not, please report this failure to the MPFR mailing-list
&lsquo;<samp>mpfr@inria.fr</samp>&rsquo;. For details, See <a href="#Reporting-Bugs">Reporting Bugs</a>.
</p>
</li><li> &lsquo;<samp>make install</samp>&rsquo;

<p>This will copy the files <samp>mpfr.h</samp> and <samp>mpf2mpfr.h</samp> to the directory
<samp>/usr/local/include</samp>, the library files (<samp>libmpfr.a</samp> and possibly
others) to the directory <samp>/usr/local/lib</samp>, the file <samp>mpfr.info</samp>
to the directory <samp>/usr/local/share/info</samp>, and some other documentation
files to the directory <samp>/usr/local/share/doc/mpfr</samp> (or if you passed the
&lsquo;<samp>--prefix</samp>&rsquo; option to <samp>configure</samp>, using the prefix directory given
as argument to &lsquo;<samp>--prefix</samp>&rsquo; instead of <samp>/usr/local</samp>).
</p></li></ol>

<a name="Other-_0060make_0027-Targets"></a>
<h3 class="section">2.2 Other &lsquo;make&rsquo; Targets</h3>

<p>There are some other useful make targets:
</p>
<ul>
<li> &lsquo;<samp>mpfr.info</samp>&rsquo; or &lsquo;<samp>info</samp>&rsquo;

<p>Create or update an info version of the manual, in <samp>mpfr.info</samp>.
</p>
<p>This file is already provided in the MPFR archives.
</p>
</li><li> &lsquo;<samp>mpfr.pdf</samp>&rsquo; or &lsquo;<samp>pdf</samp>&rsquo;

<p>Create a PDF version of the manual, in <samp>mpfr.pdf</samp>.
</p>
</li><li> &lsquo;<samp>mpfr.dvi</samp>&rsquo; or &lsquo;<samp>dvi</samp>&rsquo;

<p>Create a DVI version of the manual, in <samp>mpfr.dvi</samp>.
</p>
</li><li> &lsquo;<samp>mpfr.ps</samp>&rsquo; or &lsquo;<samp>ps</samp>&rsquo;

<p>Create a Postscript version of the manual, in <samp>mpfr.ps</samp>.
</p>
</li><li> &lsquo;<samp>mpfr.html</samp>&rsquo; or &lsquo;<samp>html</samp>&rsquo;

<p>Create a HTML version of the manual, in several pages in the directory
<samp>doc/mpfr.html</samp>; if you want only one output HTML file, then type
&lsquo;<samp>makeinfo --html --no-split mpfr.texi</samp>&rsquo; from the &lsquo;<samp>doc</samp>&rsquo; directory
instead.
</p>
</li><li> &lsquo;<samp>clean</samp>&rsquo;

<p>Delete all object files and archive files, but not the configuration files.
</p>
</li><li> &lsquo;<samp>distclean</samp>&rsquo;

<p>Delete all generated files not included in the distribution.
</p>
</li><li> &lsquo;<samp>uninstall</samp>&rsquo;

<p>Delete all files copied by &lsquo;<samp>make install</samp>&rsquo;.
</p>
</li></ul>


<a name="Build-Problems"></a>
<h3 class="section">2.3 Build Problems</h3>

<p>In case of problem, please read the <samp>INSTALL</samp> file carefully
before reporting a bug, in particular section &ldquo;In case of problem&rdquo;.
Some problems are due to bad configuration on the user side (not
specific to MPFR). Problems are also mentioned in the FAQ
<a href="http://www.mpfr.org/faq.html">http://www.mpfr.org/faq.html</a>.
</p>
<p>Please report problems to the MPFR mailing-list &lsquo;<samp>mpfr@inria.fr</samp>&rsquo;.
See <a href="#Reporting-Bugs">Reporting Bugs</a>.
Some bug fixes are available on the
MPFR 4.0.1 web page <a href="http://www.mpfr.org/mpfr-4.0.1/">http://www.mpfr.org/mpfr-4.0.1/</a>.
</p>
<a name="Getting-the-Latest-Version-of-MPFR"></a>
<h3 class="section">2.4 Getting the Latest Version of MPFR</h3>

<p>The latest version of MPFR is available from
<a href="https://ftp.gnu.org/gnu/mpfr/">https://ftp.gnu.org/gnu/mpfr/</a> or <a href="http://www.mpfr.org/">http://www.mpfr.org/</a>.
</p>
<hr>
<a name="Reporting-Bugs"></a>
<div class="header">
<p>
Next: <a href="#MPFR-Basics" accesskey="n" rel="next">MPFR Basics</a>, Previous: <a href="#Installing-MPFR" accesskey="p" rel="prev">Installing MPFR</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Reporting-Bugs-1"></a>
<h2 class="chapter">3 Reporting Bugs</h2>
<a name="index-Reporting-bugs"></a>

<p>If you think you have found a bug in the MPFR library, first have a look
on the MPFR 4.0.1 web page <a href="http://www.mpfr.org/mpfr-4.0.1/">http://www.mpfr.org/mpfr-4.0.1/</a> and the
FAQ <a href="http://www.mpfr.org/faq.html">http://www.mpfr.org/faq.html</a>:
perhaps this bug is already known, in which case you may find there
a workaround for it.
You might also look in the archives of the MPFR mailing-list:
<a href="https://sympa.inria.fr/sympa/arc/mpfr">https://sympa.inria.fr/sympa/arc/mpfr</a>.
Otherwise, please investigate and report it.
We have made this library available to you, and it is not to ask too
much from you, to ask you to report the bugs that you find.
</p>
<p>There are a few things you should think about when you put your bug report
together.
</p>
<p>You have to send us a test case that makes it possible for us to reproduce the
bug, i.e., a small self-content program, using no other library than MPFR.
Include instructions on how to run the test case.
</p>
<p>You also have to explain what is wrong; if you get a crash, or if the results
you get are incorrect and in that case, in what way.
</p>
<p>Please include compiler version information in your bug report. This can
be extracted using &lsquo;<samp>cc -V</samp>&rsquo; on some machines, or, if you are using GCC,
&lsquo;<samp>gcc -v</samp>&rsquo;. Also, include the output from &lsquo;<samp>uname -a</samp>&rsquo; and the MPFR
version (the GMP version may be useful too).
If you get a failure while running &lsquo;<samp>make</samp>&rsquo; or &lsquo;<samp>make check</samp>&rsquo;, please
include the <samp>config.log</samp> file in your bug report, and in case of test
failure, the <samp>tests/test-suite.log</samp> file too.
</p>
<p>If your bug report is good, we will do our best to help you to get a corrected
version of the library; if the bug report is poor, we will not do anything
about it (aside of chiding you to send better bug reports).
</p>
<p>Send your bug report to the MPFR mailing-list &lsquo;<samp>mpfr@inria.fr</samp>&rsquo;.
</p>
<p>If you think something in this manual is unclear, or downright incorrect, or if
the language needs to be improved, please send a note to the same address.
</p>
<hr>
<a name="MPFR-Basics"></a>
<div class="header">
<p>
Next: <a href="#MPFR-Interface" accesskey="n" rel="next">MPFR Interface</a>, Previous: <a href="#Reporting-Bugs" accesskey="p" rel="prev">Reporting Bugs</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="MPFR-Basics-1"></a>
<h2 class="chapter">4 MPFR Basics</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Headers-and-Libraries" accesskey="1">Headers and Libraries</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nomenclature-and-Types" accesskey="2">Nomenclature and Types</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#MPFR-Variable-Conventions" accesskey="3">MPFR Variable Conventions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Rounding-Modes" accesskey="4">Rounding Modes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Floating_002dPoint-Values-on-Special-Numbers" accesskey="5">Floating-Point Values on Special Numbers</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Exceptions" accesskey="6">Exceptions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Memory-Handling" accesskey="7">Memory Handling</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Getting-the-Best-Efficiency-Out-of-MPFR" accesskey="8">Getting the Best Efficiency Out of MPFR</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Headers-and-Libraries"></a>
<div class="header">
<p>
Next: <a href="#Nomenclature-and-Types" accesskey="n" rel="next">Nomenclature and Types</a>, Previous: <a href="#MPFR-Basics" accesskey="p" rel="prev">MPFR Basics</a>, Up: <a href="#MPFR-Basics" accesskey="u" rel="up">MPFR Basics</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Headers-and-Libraries-1"></a>
<h3 class="section">4.1 Headers and Libraries</h3>

<a name="index-mpfr_002eh"></a>
<p>All declarations needed to use MPFR are collected in the include file
<samp>mpfr.h</samp>.  It is designed to work with both C and C++ compilers.
You should include that file in any program using the MPFR library:
</p>
<div class="example">
<pre class="example">#include &lt;mpfr.h&gt;
</pre></div>

<a name="index-stdio_002eh"></a>
<p>Note however that prototypes for MPFR functions with <code>FILE *</code> parameters
are provided only if <code>&lt;stdio.h&gt;</code> is included too (before <samp>mpfr.h</samp>):
</p>
<div class="example">
<pre class="example">#include &lt;stdio.h&gt;
#include &lt;mpfr.h&gt;
</pre></div>

<a name="index-stdarg_002eh"></a>
<p>Likewise <code>&lt;stdarg.h&gt;</code> (or <code>&lt;varargs.h&gt;</code>) is required for prototypes
with <code>va_list</code> parameters, such as <code>mpfr_vprintf</code>.
</p>
<a name="index-stdint_002eh"></a>
<a name="index-inttypes_002eh"></a>
<a name="index-intmax_005ft"></a>
<a name="index-uintmax_005ft"></a>
<p>And for any functions using <code>intmax_t</code>, you must include
<code>&lt;stdint.h&gt;</code> or <code>&lt;inttypes.h&gt;</code> before <samp>mpfr.h</samp>, to
allow <samp>mpfr.h</samp> to define prototypes for these functions.
Moreover, under some platforms (in particular with C++ compilers),
users may need to define
<code>MPFR_USE_INTMAX_T</code> (and should do it for portability) before
<samp>mpfr.h</samp> has been included; of course, it is possible to do that
on the command line, e.g., with <code>-DMPFR_USE_INTMAX_T</code>.
</p>
<p>Note: If <samp>mpfr.h</samp> and/or <samp>gmp.h</samp> (used by <samp>mpfr.h</samp>)
are included several times (possibly from another header file),
<code>&lt;stdio.h&gt;</code> and/or <code>&lt;stdarg.h&gt;</code> (or <code>&lt;varargs.h&gt;</code>)
should be included <strong>before the first inclusion</strong> of
<samp>mpfr.h</samp> or <samp>gmp.h</samp>.  Alternatively, you can define
<code>MPFR_USE_FILE</code> (for MPFR I/O functions) and/or
<code>MPFR_USE_VA_LIST</code> (for MPFR functions with <code>va_list</code>
parameters) anywhere before the last inclusion of <samp>mpfr.h</samp>.
As a consequence, if your file is a public header that includes
<samp>mpfr.h</samp>, you need to use the latter method.
</p>
<p>When calling a MPFR macro, it is not allowed to have previously defined
a macro with the same name as some keywords (currently <code>do</code>,
<code>while</code> and <code>sizeof</code>).
</p>
<p>You can avoid the use of MPFR macros encapsulating functions by defining
the <code>MPFR_USE_NO_MACRO</code> macro before <samp>mpfr.h</samp> is included.  In
general this should not be necessary, but this can be useful when debugging
user code: with some macros, the compiler may emit spurious warnings with
some warning options, and macros can prevent some prototype checking.
</p>
<a name="index-Libraries"></a>
<a name="index-Linking"></a>
<a name="index-libmpfr"></a>
<p>All programs using MPFR must link against both <samp>libmpfr</samp> and
<samp>libgmp</samp> libraries.  On a typical Unix-like system this can be
done with &lsquo;<samp>-lmpfr -lgmp</samp>&rsquo; (in that order), for example:
</p>
<div class="example">
<pre class="example">gcc myprogram.c -lmpfr -lgmp
</pre></div>

<a name="index-Libtool"></a>
<p>MPFR is built using Libtool and an application can use that to link if
desired, see <cite>GNU Libtool</cite>.
</p>
<p>If MPFR has been installed to a non-standard location, then it may be
necessary to set up environment variables such as &lsquo;<samp>C_INCLUDE_PATH</samp>&rsquo;
and &lsquo;<samp>LIBRARY_PATH</samp>&rsquo;, or use &lsquo;<samp>-I</samp>&rsquo; and &lsquo;<samp>-L</samp>&rsquo; compiler options,
in order to point to the right directories. For a shared library, it may
also be necessary to set up some sort of run-time library path (e.g.,
&lsquo;<samp>LD_LIBRARY_PATH</samp>&rsquo;) on some systems. Please read the <samp>INSTALL</samp>
file for additional information.
</p>
<p>Alternatively, it is possible to use &lsquo;<samp>pkg-config</samp>&rsquo; (a file
&lsquo;<samp>mpfr.pc</samp>&rsquo; is provided as of MPFR 4.0):
</p>
<div class="example">
<pre class="example">cc myprogram.c $(pkg-config --cflags --libs mpfr)
</pre></div>

<p>Note that the &lsquo;<samp>MPFR_</samp>&rsquo; and &lsquo;<samp>mpfr_</samp>&rsquo; prefixes are reserved for MPFR.
As a general rule, in order to avoid clashes, software using MPFR (directly
or indirectly) and system headers/libraries should not define macros and
symbols using these prefixes.
</p>
<hr>
<a name="Nomenclature-and-Types"></a>
<div class="header">
<p>
Next: <a href="#MPFR-Variable-Conventions" accesskey="n" rel="next">MPFR Variable Conventions</a>, Previous: <a href="#Headers-and-Libraries" accesskey="p" rel="prev">Headers and Libraries</a>, Up: <a href="#MPFR-Basics" accesskey="u" rel="up">MPFR Basics</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nomenclature-and-Types-1"></a>
<h3 class="section">4.2 Nomenclature and Types</h3>

<a name="index-Floating_002dpoint-number"></a>
<a name="index-mpfr_005ft"></a>
<p>A <em>floating-point number</em>, or <em>float</em> for short, is an arbitrary
precision significand (also called mantissa) with a limited precision
exponent. The C data type
for such objects is <code>mpfr_t</code> (internally defined as a one-element
array of a structure, and <code>mpfr_ptr</code> is the C data type representing
a pointer to this structure). A floating-point number can have
three special values: Not-a-Number (NaN) or plus or minus Infinity. NaN
represents an uninitialized object, the result of an invalid operation
(like 0 divided by 0), or a value that cannot be determined (like
+Infinity minus +Infinity). Moreover, like in the IEEE 754 standard,
zero is signed, i.e., there are both +0 and -0; the behavior
is the same as in the IEEE 754 standard and it is generalized to
the other functions supported by MPFR. Unless documented otherwise,
the sign bit of a NaN is unspecified.
</p>
<a name="index-Precision"></a>
<a name="index-mpfr_005fprec_005ft"></a>
<p>The <em>precision</em> is the number of bits used to represent the significand
of a floating-point number;
the corresponding C data type is <code>mpfr_prec_t</code>.
The precision can be any integer between <code>MPFR_PREC_MIN</code> and
<code>MPFR_PREC_MAX</code>. In the current implementation, <code>MPFR_PREC_MIN</code>
is equal to 1.
</p>
<p>Warning! MPFR needs to increase the precision internally, in order to
provide accurate results (and in particular, correct rounding). Do not
attempt to set the precision to any value near <code>MPFR_PREC_MAX</code>,
otherwise MPFR will abort due to an assertion failure. Moreover, you
may reach some memory limit on your platform, in which case the program
may abort, crash or have undefined behavior (depending on your C
implementation).
</p>
<a name="index-Rounding-Modes"></a>
<a name="index-mpfr_005frnd_005ft"></a>
<p>The <em>rounding mode</em> specifies the way to round the result of a
floating-point operation, in case the exact result can not be represented
exactly in the destination significand;
the corresponding C data type is <code>mpfr_rnd_t</code>.
</p>
<a name="index-Group-of-flags"></a>
<a name="index-mpfr_005fflags_005ft"></a>
<p>MPFR has a global (or per-thread) flag for each supported exception and
provides operations on flags (<a href="#Exceptions">Exceptions</a>). This C data type is used
to represent a group of flags (or a mask).
</p>
<hr>
<a name="MPFR-Variable-Conventions"></a>
<div class="header">
<p>
Next: <a href="#Rounding-Modes" accesskey="n" rel="next">Rounding Modes</a>, Previous: <a href="#Nomenclature-and-Types" accesskey="p" rel="prev">Nomenclature and Types</a>, Up: <a href="#MPFR-Basics" accesskey="u" rel="up">MPFR Basics</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="MPFR-Variable-Conventions-1"></a>
<h3 class="section">4.3 MPFR Variable Conventions</h3>

<p>Before you can assign to a MPFR variable, you need to initialize it by calling
one of the special initialization functions.  When you are done with a
variable, you need to clear it out, using one of the functions for that
purpose.
A variable should only be initialized once, or at least cleared out between
each initialization.  After a variable has been initialized, it may be
assigned to any number of times.
For efficiency reasons, avoid to initialize and clear out a variable in loops.
Instead, initialize it before entering the loop, and clear it out after the
loop has exited.
You do not need to be concerned about allocating additional space for MPFR
variables, since any variable has a significand of fixed size.
Hence unless you change its precision, or clear and reinitialize it,
a floating-point variable will have the same allocated space during all its
life.
</p>
<p>As a general rule, all MPFR functions expect output arguments before input
arguments.  This notation is based on an analogy with the assignment operator.
MPFR allows you to use the same variable for both input and output in the same
expression.  For example, the main function for floating-point multiplication,
<code>mpfr_mul</code>, can be used like this: <code>mpfr_mul (x, x, x, rnd)</code>.
This computes the square of <var>x</var> with rounding mode <code>rnd</code>
and puts the result back in <var>x</var>.
</p>
<hr>
<a name="Rounding-Modes"></a>
<div class="header">
<p>
Next: <a href="#Floating_002dPoint-Values-on-Special-Numbers" accesskey="n" rel="next">Floating-Point Values on Special Numbers</a>, Previous: <a href="#MPFR-Variable-Conventions" accesskey="p" rel="prev">MPFR Variable Conventions</a>, Up: <a href="#MPFR-Basics" accesskey="u" rel="up">MPFR Basics</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Rounding-Modes-1"></a>
<h3 class="section">4.4 Rounding Modes</h3>

<p>The following rounding modes are supported:
</p><ul>
<li> <code>MPFR_RNDN</code>: round to nearest (roundTiesToEven in IEEE 754-2008),
</li><li> <code>MPFR_RNDZ</code>: round toward zero (roundTowardZero in IEEE 754-2008),
</li><li> <code>MPFR_RNDU</code>: round toward plus infinity (roundTowardPositive in IEEE 754-2008),
</li><li> <code>MPFR_RNDD</code>: round toward minus infinity (roundTowardNegative in IEEE 754-2008),
</li><li> <code>MPFR_RNDA</code>: round away from zero.
</li><li> <code>MPFR_RNDF</code>: faithful rounding. This feature is currently
experimental. Specific support for this rounding mode has been added
to some functions, such as the basic operations (addition, subtraction,
multiplication, square, division, square root) or when explicitly
documented. It might also work with other functions, as it is possible that
they do not need modification in their code; even though a correct behavior
is not guaranteed yet (corrections were done when failures occurred in the
test suite, but almost nothing has been checked manually), failures should
be regarded as bugs and reported, so that they can be fixed.
</li></ul>

<p>The &lsquo;<samp>round to nearest</samp>&rsquo; mode works as in the IEEE 754 standard: in
case the number to be rounded lies exactly in the middle of two representable
numbers, it is rounded to the one with the least significant bit set to zero.
For example, the number 2.5, which is represented by (10.1) in binary, is
rounded to (10.0)=2 with a precision of two bits, and not to (11.0)=3.
This rule avoids the <em>drift</em> phenomenon mentioned by Knuth in volume 2
of The Art of Computer Programming (Section 4.2.2).
</p>
<p>The <code>MPFR_RNDF</code> mode works as follows: the computed value is either
that corresponding to <code>MPFR_RNDD</code> or that corresponding to
<code>MPFR_RNDU</code>.
In particular when those values are identical,
i.e., when the result of the corresponding operation is exactly
representable, that exact result is returned.
Thus, the computed result can take at most two possible values, and
in absence of underflow/overflow, the corresponding error is strictly
less than one ulp (unit in the last place) of that result and of the
exact result.
For <code>MPFR_RNDF</code>, the ternary value (defined below) and the inexact flag
(defined later, as with the other flags) are unspecified, the divide-by-zero
flag is as with other roundings, and the underflow and overflow flags match
what would be obtained in the case the computed value is the same as with
<code>MPFR_RNDD</code> or <code>MPFR_RNDU</code>.
The results may not be reproducible.
</p>
<a name="ternary-value"></a><a name="index-Ternary-value"></a>
<p>Most MPFR functions take as first argument the destination variable, as
second and following arguments the input variables, as last argument a
rounding mode, and have a return value of type <code>int</code>, called the
<em>ternary value</em>. The value stored in the destination variable is
correctly rounded, i.e., MPFR behaves as if it computed the result with
an infinite precision, then rounded it to the precision of this variable.
The input variables are regarded as exact (in particular, their precision
does not affect the result).
</p>
<p>As a consequence, in case of a non-zero real rounded result, the error
on the result is less or equal to 1/2 ulp (unit in the last place) of
that result in the rounding to nearest mode, and less than 1 ulp of that
result in the directed rounding modes (a ulp is the weight of the least
significant represented bit of the result after rounding).
</p>
<p>Unless documented otherwise, functions returning an <code>int</code> return
a ternary value.
If the ternary value is zero, it means that the value stored in the
destination variable is the exact result of the corresponding mathematical
function. If the ternary value is positive (resp. negative), it means
the value stored in the destination variable is greater (resp. lower)
than the exact result. For example with the <code>MPFR_RNDU</code> rounding mode,
the ternary value is usually positive, except when the result is exact, in
which case it is zero. In the case of an infinite result, it is considered
as inexact when it was obtained by overflow, and exact otherwise. A NaN
result (Not-a-Number) always corresponds to an exact return value.
The opposite of a returned ternary value is guaranteed to be representable
in an <code>int</code>.
</p>
<p>Unless documented otherwise, functions returning as result the value <code>1</code>
(or any other value specified in this manual)
for special cases (like <code>acos(0)</code>) yield an overflow or
an underflow if that value is not representable in the current exponent range.
</p>
<hr>
<a name="Floating_002dPoint-Values-on-Special-Numbers"></a>
<div class="header">
<p>
Next: <a href="#Exceptions" accesskey="n" rel="next">Exceptions</a>, Previous: <a href="#Rounding-Modes" accesskey="p" rel="prev">Rounding Modes</a>, Up: <a href="#MPFR-Basics" accesskey="u" rel="up">MPFR Basics</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Floating_002dPoint-Values-on-Special-Numbers-1"></a>
<h3 class="section">4.5 Floating-Point Values on Special Numbers</h3>

<p>This section specifies the floating-point values (of type <code>mpfr_t</code>)
returned by MPFR functions (where by &ldquo;returned&rdquo; we mean here the modified
value of the destination object, which should not be mixed with the ternary
return value of type <code>int</code> of those functions).
For functions returning several values (like
<code>mpfr_sin_cos</code>), the rules apply to each result separately.
</p>
<p>Functions can have one or several input arguments. An input point is
a mapping from these input arguments to the set of the MPFR numbers.
When none of its components are NaN, an input point can also be seen
as a tuple in the extended real numbers (the set of the real numbers
with both infinities).
</p>
<p>When the input point is in the domain of the mathematical function, the
result is rounded as described in Section &ldquo;Rounding Modes&rdquo; (but see
below for the specification of the sign of an exact zero). Otherwise
the general rules from this section apply unless stated otherwise in
the description of the MPFR function (<a href="#MPFR-Interface">MPFR Interface</a>).
</p>
<p>When the input point is not in the domain of the mathematical function
but is in its closure in the extended real numbers and the function can
be extended by continuity, the result is the obtained limit.
Examples: <code>mpfr_hypot</code> on (+Inf,0) gives +Inf. But <code>mpfr_pow</code>
cannot be defined on (1,+Inf) using this rule, as one can find
sequences (<em><var>x</var>_<var>n</var></em>,<em><var>y</var>_<var>n</var></em>) such that
<em><var>x</var>_<var>n</var></em> goes to 1, <em><var>y</var>_<var>n</var></em> goes to +Inf
and <em><var>x</var>_<var>n</var> to the <var>y</var>_<var>n</var></em> goes to any
positive value when <var>n</var> goes to the infinity.
</p>
<p>When the input point is in the closure of the domain of the mathematical
function and an input argument is +0 (resp. -0), one considers
the limit when the corresponding argument approaches 0 from above
(resp. below), if possible. If the limit is not defined (e.g.,
<code>mpfr_sqrt</code> and <code>mpfr_log</code> on -0), the behavior is
specified in the description of the MPFR function, but must be consistent
with the rule from the above paragraph (e.g., <code>mpfr_log</code> on ±0
gives -Inf).
</p>
<p>When the result is equal to 0, its sign is determined by considering the
limit as if the input point were not in the domain: If one approaches 0
from above (resp. below), the result is +0 (resp. -0);
for example, <code>mpfr_sin</code> on -0 gives -0 and
<code>mpfr_acos</code> on 1 gives +0 (in all rounding modes).
In the other cases, the sign is specified in the description of the MPFR
function; for example <code>mpfr_max</code> on -0 and +0 gives +0.
</p>
<p>When the input point is not in the closure of the domain of the function,
the result is NaN. Example: <code>mpfr_sqrt</code> on -17 gives NaN.
</p>
<p>When an input argument is NaN, the result is NaN, possibly except when
a partial function is constant on the finite floating-point numbers;
such a case is always explicitly specified in <a href="#MPFR-Interface">MPFR Interface</a>.
Example: <code>mpfr_hypot</code> on (NaN,0) gives NaN, but <code>mpfr_hypot</code>
on (NaN,+Inf) gives +Inf (as specified in <a href="#Special-Functions">Special Functions</a>),
since for any finite or infinite input <var>x</var>, <code>mpfr_hypot</code> on
(<var>x</var>,+Inf) gives +Inf.
</p>
<hr>
<a name="Exceptions"></a>
<div class="header">
<p>
Next: <a href="#Memory-Handling" accesskey="n" rel="next">Memory Handling</a>, Previous: <a href="#Floating_002dPoint-Values-on-Special-Numbers" accesskey="p" rel="prev">Floating-Point Values on Special Numbers</a>, Up: <a href="#MPFR-Basics" accesskey="u" rel="up">MPFR Basics</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Exceptions-1"></a>
<h3 class="section">4.6 Exceptions</h3>

<p>MPFR defines a global (or per-thread) flag for each supported exception.
A macro evaluating to a power of two is associated with each flag and
exception, in order to be able to specify a group of flags (or a mask)
by OR&rsquo;ing such macros.
</p>
<p>Flags can be cleared (lowered), set (raised), and tested by functions
described in <a href="#Exception-Related-Functions">Exception Related Functions</a>.
</p>
<p>The supported exceptions are listed below. The macro associated with
each exception is in parentheses.
</p>
<ul>
<li> Underflow (<code>MPFR_FLAGS_UNDERFLOW</code>):
An underflow occurs when the exact result of a function is a non-zero
real number and the result obtained after the rounding, assuming an
unbounded exponent range (for the rounding), has an exponent smaller
than the minimum value of the current exponent range. (In the round-to-nearest
mode, the halfway case is rounded toward zero.)

<p>Note: This is not the single possible definition of the underflow. MPFR chooses
to consider the underflow <em>after</em> rounding. The underflow before rounding
can also be defined. For instance, consider a function that has the
exact result <em>7 multiplied by two to the power
<var>e</var>-4</em>, where <var>e</var> is the smallest exponent (for a
significand between 1/2 and 1),
with a 2-bit target precision and rounding toward plus infinity.
The exact result has the exponent <var>e</var>-1. With the underflow
before rounding, such a function call would yield an underflow, as
<var>e</var>-1 is outside the current exponent range. However, MPFR
first considers the rounded result assuming an unbounded exponent range.
The exact result cannot be represented exactly in precision 2, and here,
it is rounded to <em>0.5 times 2 to <var>e</var></em>, which is
representable in the current exponent range. As a consequence, this will
not yield an underflow in MPFR.
</p>
</li><li> Overflow (<code>MPFR_FLAGS_OVERFLOW</code>):
An overflow occurs when the exact result of a function is a non-zero
real number and the result obtained after the rounding, assuming an
unbounded exponent range (for the rounding), has an exponent larger
than the maximum value of the current exponent range. In the round-to-nearest
mode, the result is infinite.
Note: unlike the underflow case, there is only one possible definition of
overflow here.

</li><li> Divide-by-zero (<code>MPFR_FLAGS_DIVBY0</code>):
An exact infinite result is obtained from finite inputs.

</li><li> NaN (<code>MPFR_FLAGS_NAN</code>):
A NaN exception occurs when the result of a function is NaN.

</li><li> Inexact (<code>MPFR_FLAGS_INEXACT</code>):
An inexact exception occurs when the result of a function cannot be
represented exactly and must be rounded.

</li><li> Range error (<code>MPFR_FLAGS_ERANGE</code>):
A range exception occurs when a function that does not return a MPFR
number (such as comparisons and conversions to an integer) has an
invalid result (e.g., an argument is NaN in <code>mpfr_cmp</code>, or a
conversion to an integer cannot be represented in the target type).

</li></ul>

<p>Moreover, the group consisting of all the flags is represented by
the <code>MPFR_FLAGS_ALL</code> macro (if new flags are added in future
MPFR versions, they will be added to this macro too).
</p>
<p>Differences with the ISO C99 standard:
</p>
<ul>
<li> In C, only quiet NaNs are specified, and a NaN propagation does not
raise an invalid exception. Unless explicitly stated otherwise, MPFR sets
the NaN flag whenever a NaN is generated, even when a NaN is propagated
(e.g., in NaN + NaN), as if all NaNs were signaling.

</li><li> An invalid exception in C corresponds to either a NaN exception or
a range error in MPFR.

</li></ul>

<hr>
<a name="Memory-Handling"></a>
<div class="header">
<p>
Next: <a href="#Getting-the-Best-Efficiency-Out-of-MPFR" accesskey="n" rel="next">Getting the Best Efficiency Out of MPFR</a>, Previous: <a href="#Exceptions" accesskey="p" rel="prev">Exceptions</a>, Up: <a href="#MPFR-Basics" accesskey="u" rel="up">MPFR Basics</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Memory-Handling-1"></a>
<h3 class="section">4.7 Memory Handling</h3>

<p>MPFR functions may create caches, e.g., when computing constants such
as <em>Pi</em>, either because the user has called a function like
<code>mpfr_const_pi</code> directly or because such a function was called
internally by the MPFR library itself to compute some other function.
When more precision is needed, the value is automatically recomputed;
a minimum of 10% increase of the precision is guaranteed to avoid too
many recomputations.
</p>
<p>MPFR functions may also create thread-local pools for internal use
to avoid the cost of memory allocation. The pools can be freed with
<code>mpfr_free_pool</code> (but with a default MPFR build, they should not
take much memory, as the allocation size is limited).
</p>
<p>At any time, the user can free various caches and pools with
<code>mpfr_free_cache</code> and <code>mpfr_free_cache2</code>. It is strongly advised
to free thread-local caches before terminating a thread, and all caches
before exiting when using tools like &lsquo;<samp>valgrind</samp>&rsquo; (to avoid memory leaks
being reported).
</p>
<p>MPFR allocates its memory either on the stack (for temporary memory only)
or with the same allocator as the one configured for GMP:
see Section &ldquo;Custom Allocation&rdquo; in <cite>GNU MP</cite>.
This means that the application must make sure that data allocated with the
current allocator will not be reallocated or freed with a new allocator.
So, in practice, if an application needs to change the allocator with
<code>mp_set_memory_functions</code>, it should first free all data allocated
with the current allocator: for its own data, with <code>mpfr_clear</code>,
etc.; for the caches and pools, with <code>mpfr_mp_memory_cleanup</code> in
all threads where MPFR is potentially used. This function is currently
equivalent to <code>mpfr_free_cache</code>, but <code>mpfr_mp_memory_cleanup</code>
is the recommended way in case the allocation method changes in the future
(for instance, one may choose to allocate the caches for floating-point
constants with <code>malloc</code> to avoid freeing them if the allocator
changes). Developers should also be aware that MPFR may also be used
indirectly by libraries, so that libraries based on MPFR should provide
a clean-up function calling <code>mpfr_mp_memory_cleanup</code> and/or warn
their users about this issue.
</p>
<p>Note: For multithreaded applications, the allocator must be valid in
all threads where MPFR may be used; data allocated in one thread may
be reallocated and/or freed in some other thread.
</p>
<p>MPFR internal data such as flags, the exponent range, the default
precision and rounding mode, and caches (i.e., data that are not
accessed via parameters) are either global (if MPFR has not been
compiled as thread safe) or per-thread (thread local storage, TLS).
The initial values of TLS data after a thread is created entirely
depend on the compiler and thread implementation (MPFR simply does
a conventional variable initialization, the variables being declared
with an implementation-defined TLS specifier).
</p>
<p>Writers of libraries using MPFR should be aware that the application and/or
another library used by the application may also use MPFR, so that changing
the exponent range, the default precision, or the default rounding mode may
have an effect on this other use of MPFR since these data are not duplicated
(unless they are in a different thread). Therefore any such value changed in
a library function should be restored before the function returns (unless
the purpose of the function is to do such a change). Writers of software
using MPFR should also be careful when changing such a value if they use
a library using MPFR (directly or indirectly), in order to make sure that
such a change is compatible with the library.
</p>
<hr>
<a name="Getting-the-Best-Efficiency-Out-of-MPFR"></a>
<div class="header">
<p>
Previous: <a href="#Memory-Handling" accesskey="p" rel="prev">Memory Handling</a>, Up: <a href="#MPFR-Basics" accesskey="u" rel="up">MPFR Basics</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Getting-the-Best-Efficiency-Out-of-MPFR-1"></a>
<h3 class="section">4.8 Getting the Best Efficiency Out of MPFR</h3>

<p>Here are a few hints to get the best efficiency out of MPFR:
</p>
<ul>
<li> you should avoid allocating and clearing variables. Reuse variables
      whenever possible, allocate or clear outside of loops, pass
      temporary variables to subroutines instead of allocating them inside
      the subroutines;

</li><li> use <code>mpfr_swap</code> instead of <code>mpfr_set</code> whenever possible.
      This will avoid copying the significands;

</li><li> avoid using MPFR from C++, or make sure your C++ interface does not
      perform unnecessary allocations or copies;

</li><li> MPFR functions work in-place: to compute <code>a = a + b</code> you don&rsquo;t
      need an auxiliary variable, you can directly write
      <code>mpfr_add (a, a, b, ...)</code>.

</li></ul>

<hr>
<a name="MPFR-Interface"></a>
<div class="header">
<p>
Next: <a href="#API-Compatibility" accesskey="n" rel="next">API Compatibility</a>, Previous: <a href="#MPFR-Basics" accesskey="p" rel="prev">MPFR Basics</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="MPFR-Interface-1"></a>
<h2 class="chapter">5 MPFR Interface</h2>
<a name="index-Floating_002dpoint-functions"></a>
<a name="index-Float-functions"></a>

<p>The floating-point functions expect arguments of type <code>mpfr_t</code>.
</p>
<p>The MPFR floating-point functions have an interface that is similar to the
GNU MP
functions.  The function prefix for floating-point operations is <code>mpfr_</code>.
</p>
<p>The user has
to specify the precision of each variable.  A computation that assigns a
variable will take place with the precision of the assigned variable; the
cost of that computation should not depend on the
precision of variables used as input (on average).
</p>
<a name="index-Precision-1"></a>
<p>The semantics of a calculation in MPFR is specified as follows: Compute the
requested operation exactly (with &ldquo;infinite accuracy&rdquo;), and round the result
to the precision of the destination variable, with the given rounding mode.
The MPFR floating-point functions are intended to be a smooth extension
of the IEEE 754 arithmetic. The results obtained on a given computer are
identical to those obtained on a computer with a different word size,
or with a different compiler or operating system.
</p>
<a name="index-Accuracy"></a>
<p>MPFR <em>does not keep track</em> of the accuracy of a computation. This is left
to the user or to a higher layer (for example the MPFI library for interval
arithmetic).
As a consequence, if two variables are used to store
only a few significant bits, and their product is stored in a variable with large
precision, then MPFR will still compute the result with full precision.
</p>
<p>The value of the standard C macro <code>errno</code> may be set to non-zero after
calling any MPFR function or macro, whether or not there is an error. Except
when documented, MPFR will not set <code>errno</code>, but functions called by the
MPFR code (libc functions, memory allocator, etc.) may do so.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Initialization-Functions" accesskey="1">Initialization Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Assignment-Functions" accesskey="2">Assignment Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Combined-Initialization-and-Assignment-Functions" accesskey="3">Combined Initialization and Assignment Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Conversion-Functions" accesskey="4">Conversion Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Basic-Arithmetic-Functions" accesskey="5">Basic Arithmetic Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Comparison-Functions" accesskey="6">Comparison Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Special-Functions" accesskey="7">Special Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Input-and-Output-Functions" accesskey="8">Input and Output Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Formatted-Output-Functions" accesskey="9">Formatted Output Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Rounding_002dRelated-Functions">Rounding-Related Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Miscellaneous-Functions">Miscellaneous Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Exception-Related-Functions">Exception Related Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Compatibility-with-MPF">Compatibility with MPF</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Custom-Interface">Custom Interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Internals">Internals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Initialization-Functions"></a>
<div class="header">
<p>
Next: <a href="#Assignment-Functions" accesskey="n" rel="next">Assignment Functions</a>, Previous: <a href="#MPFR-Interface" accesskey="p" rel="prev">MPFR Interface</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Initialization-functions"></a>
<a name="Initialization-Functions-1"></a>
<h3 class="section">5.1 Initialization Functions</h3>

<p>An <code>mpfr_t</code> object must be initialized before storing the first value in
it.  The functions <code>mpfr_init</code> and <code>mpfr_init2</code> are used for that
purpose.
</p>
<dl>
<dt><a name="index-mpfr_005finit2"></a>Function: <em>void</em> <strong>mpfr_init2</strong> <em>(mpfr_t <var>x</var>, mpfr_prec_t <var>prec</var>)</em></dt>
<dd><p>Initialize <var>x</var>, set its precision to be <strong>exactly</strong>
<var>prec</var> bits and its value to NaN. (Warning: the corresponding
MPF function initializes to zero instead.)
</p>
<p>Normally, a variable should be initialized once only or at
least be cleared, using <code>mpfr_clear</code>, between initializations.
To change the precision of a variable which has already been initialized,
use <code>mpfr_set_prec</code>.
The precision <var>prec</var> must be an integer between <code>MPFR_PREC_MIN</code> and
<code>MPFR_PREC_MAX</code> (otherwise the behavior is undefined).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005finits2"></a>Function: <em>void</em> <strong>mpfr_inits2</strong> <em>(mpfr_prec_t <var>prec</var>, mpfr_t <var>x</var>, ...)</em></dt>
<dd><p>Initialize all the <code>mpfr_t</code> variables of the given variable
argument <code>va_list</code>, set their precision to be <strong>exactly</strong>
<var>prec</var> bits and their value to NaN.
See <code>mpfr_init2</code> for more details.
The <code>va_list</code> is assumed to be composed only of type <code>mpfr_t</code>
(or equivalently <code>mpfr_ptr</code>).
It begins from <var>x</var>, and ends when it encounters a null pointer (whose
type must also be <code>mpfr_ptr</code>).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fclear"></a>Function: <em>void</em> <strong>mpfr_clear</strong> <em>(mpfr_t <var>x</var>)</em></dt>
<dd><p>Free the space occupied by the significand of
<var>x</var>.  Make sure to call this function for all
<code>mpfr_t</code> variables when you are done with them.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fclears"></a>Function: <em>void</em> <strong>mpfr_clears</strong> <em>(mpfr_t <var>x</var>, ...)</em></dt>
<dd><p>Free the space occupied by all the <code>mpfr_t</code> variables of the given
<code>va_list</code>. See <code>mpfr_clear</code> for more details.
The <code>va_list</code> is assumed to be composed only of type <code>mpfr_t</code>
(or equivalently <code>mpfr_ptr</code>).
It begins from <var>x</var>, and ends when it encounters a null pointer (whose
type must also be <code>mpfr_ptr</code>).
</p></dd></dl>

<p>Here is an example of how to use multiple initialization functions
(since <code>NULL</code> is not necessarily defined in this context, we use
<code>(mpfr_ptr) 0</code> instead, but <code>(mpfr_ptr) NULL</code> is also correct).
</p>
<div class="example">
<pre class="example">{
  mpfr_t x, y, z, t;
  mpfr_inits2 (256, x, y, z, t, (mpfr_ptr) 0);
  &hellip;
  mpfr_clears (x, y, z, t, (mpfr_ptr) 0);
}
</pre></div>

<dl>
<dt><a name="index-mpfr_005finit"></a>Function: <em>void</em> <strong>mpfr_init</strong> <em>(mpfr_t <var>x</var>)</em></dt>
<dd><p>Initialize <var>x</var>, set its precision to the default precision,
and set its value to NaN.
The default precision can be changed by a call to <code>mpfr_set_default_prec</code>.
</p>
<p>Warning! In a given program, some other libraries might change the default
precision and not restore it. Thus it is safer to use <code>mpfr_init2</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005finits"></a>Function: <em>void</em> <strong>mpfr_inits</strong> <em>(mpfr_t <var>x</var>, ...)</em></dt>
<dd><p>Initialize all the <code>mpfr_t</code> variables of the given <code>va_list</code>,
set their precision to the default precision and their value to NaN.
See <code>mpfr_init</code> for more details.
The <code>va_list</code> is assumed to be composed only of type <code>mpfr_t</code>
(or equivalently <code>mpfr_ptr</code>).
It begins from <var>x</var>, and ends when it encounters a null pointer (whose
type must also be <code>mpfr_ptr</code>).
</p>
<p>Warning! In a given program, some other libraries might change the default
precision and not restore it. Thus it is safer to use <code>mpfr_inits2</code>.
</p></dd></dl>

<dl>
<dt><a name="index-MPFR_005fDECL_005fINIT"></a>Macro: <strong>MPFR_DECL_INIT</strong> <em>(<var>name</var>, <var>prec</var>)</em></dt>
<dd><p>This macro declares <var>name</var> as an automatic variable of type <code>mpfr_t</code>,
initializes it and sets its precision to be <strong>exactly</strong> <var>prec</var> bits
and its value to NaN. <var>name</var> must be a valid identifier.
You must use this macro in the declaration section.
This macro is much faster than using <code>mpfr_init2</code> but has some
drawbacks:
</p>
<ul>
<li> You <strong>must not</strong> call <code>mpfr_clear</code> with variables
created with this macro (the storage is allocated at the point of declaration
and deallocated when the brace-level is exited).

</li><li> You <strong>cannot</strong> change their precision.

</li><li> You <strong>should not</strong> create variables with huge precision with this
macro.

</li><li> Your compiler must support &lsquo;<samp>Non-Constant Initializers</samp>&rsquo; (standard
in C++ and ISO C99) and &lsquo;<samp>Token Pasting</samp>&rsquo;
(standard in ISO C89). If <var>prec</var> is not a constant expression, your
compiler must support &lsquo;<samp>variable-length automatic arrays</samp>&rsquo; (standard
in ISO C99). GCC 2.95.3 and above supports all these features.
If you compile your program with GCC in C89 mode and with &lsquo;<samp>-pedantic</samp>&rsquo;,
you may want to define the <code>MPFR_USE_EXTENSION</code> macro to avoid warnings
due to the <code>MPFR_DECL_INIT</code> implementation.

</li></ul>
</dd></dl>

<dl>
<dt><a name="index-mpfr_005fset_005fdefault_005fprec"></a>Function: <em>void</em> <strong>mpfr_set_default_prec</strong> <em>(mpfr_prec_t <var>prec</var>)</em></dt>
<dd><p>Set the default precision to be <strong>exactly</strong> <var>prec</var> bits, where
<var>prec</var> can be any integer between <code>MPFR_PREC_MIN</code> and
<code>MPFR_PREC_MAX</code>.
The
precision of a variable means the number of bits used to store its significand.
All
subsequent calls to <code>mpfr_init</code> or <code>mpfr_inits</code>
will use this precision, but previously
initialized variables are unaffected.
The default precision is set to 53 bits initially.
</p>
<p>Note: when MPFR is built with the &lsquo;<samp>--enable-thread-safe</samp>&rsquo; configure option,
the default precision is local to each thread. See <a href="#Memory-Handling">Memory Handling</a>, for
more information.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005fdefault_005fprec"></a>Function: <em>mpfr_prec_t</em> <strong>mpfr_get_default_prec</strong> <em>(void)</em></dt>
<dd><p>Return the current default MPFR precision in bits.
See the documentation of <code>mpfr_set_default_prec</code>.
</p></dd></dl>

<p>Here is an example on how to initialize floating-point variables:
</p>
<div class="example">
<pre class="example">{
  mpfr_t x, y;
  mpfr_init (x);                /* use default precision */
  mpfr_init2 (y, 256);          /* precision <em>exactly</em> 256 bits */
  &hellip;
  /* When the program is about to exit, do ... */
  mpfr_clear (x);
  mpfr_clear (y);
  mpfr_free_cache ();           /* free the cache for constants like pi */
}
</pre></div>

<p>The following functions are useful for changing the precision during a
calculation.  A typical use would be for adjusting the precision gradually in
iterative algorithms like Newton-Raphson, making the computation precision
closely match the actual accurate part of the numbers.
</p>
<dl>
<dt><a name="index-mpfr_005fset_005fprec"></a>Function: <em>void</em> <strong>mpfr_set_prec</strong> <em>(mpfr_t <var>x</var>, mpfr_prec_t <var>prec</var>)</em></dt>
<dd><p>Reset the precision of <var>x</var> to be <strong>exactly</strong> <var>prec</var> bits,
and set its value to NaN.
The previous value stored in <var>x</var> is lost. It is equivalent to
a call to <code>mpfr_clear(x)</code> followed by a call to
<code>mpfr_init2(x, prec)</code>, but more efficient as no allocation is done in
case the current allocated space for the significand of <var>x</var> is enough.
The precision <var>prec</var> can be any integer between <code>MPFR_PREC_MIN</code> and
<code>MPFR_PREC_MAX</code>.
In case you want to keep the previous value stored in <var>x</var>,
use <code>mpfr_prec_round</code> instead.
</p>
<p>Warning! You must not use this function if <var>x</var> was initialized
with <code>MPFR_DECL_INIT</code> or with <code>mpfr_custom_init_set</code>
(see <a href="#Custom-Interface">Custom Interface</a>).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005fprec"></a>Function: <em>mpfr_prec_t</em> <strong>mpfr_get_prec</strong> <em>(mpfr_t <var>x</var>)</em></dt>
<dd><p>Return the precision of <var>x</var>, i.e., the
number of bits used to store its significand.
</p></dd></dl>

<hr>
<a name="Assignment-Functions"></a>
<div class="header">
<p>
Next: <a href="#Combined-Initialization-and-Assignment-Functions" accesskey="n" rel="next">Combined Initialization and Assignment Functions</a>, Previous: <a href="#Initialization-Functions" accesskey="p" rel="prev">Initialization Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Assignment-functions"></a>
<a name="Assignment-Functions-1"></a>
<h3 class="section">5.2 Assignment Functions</h3>

<p>These functions assign new values to already initialized floats
(see <a href="#Initialization-Functions">Initialization Functions</a>).
</p>
<dl>
<dt><a name="index-mpfr_005fset"></a>Function: <em>int</em> <strong>mpfr_set</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fui"></a>Function: <em>int</em> <strong>mpfr_set_ui</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fsi"></a>Function: <em>int</em> <strong>mpfr_set_si</strong> <em>(mpfr_t <var>rop</var>, long int <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fuj"></a>Function: <em>int</em> <strong>mpfr_set_uj</strong> <em>(mpfr_t <var>rop</var>, uintmax_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fsj"></a>Function: <em>int</em> <strong>mpfr_set_sj</strong> <em>(mpfr_t <var>rop</var>, intmax_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fflt"></a>Function: <em>int</em> <strong>mpfr_set_flt</strong> <em>(mpfr_t <var>rop</var>, float <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fd"></a>Function: <em>int</em> <strong>mpfr_set_d</strong> <em>(mpfr_t <var>rop</var>, double <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fld"></a>Function: <em>int</em> <strong>mpfr_set_ld</strong> <em>(mpfr_t <var>rop</var>, long double <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005ffloat128"></a>Function: <em>int</em> <strong>mpfr_set_float128</strong> <em>(mpfr_t <var>rop</var>, __float128 <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fdecimal64"></a>Function: <em>int</em> <strong>mpfr_set_decimal64</strong> <em>(mpfr_t <var>rop</var>, _Decimal64 <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fz"></a>Function: <em>int</em> <strong>mpfr_set_z</strong> <em>(mpfr_t <var>rop</var>, mpz_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fq"></a>Function: <em>int</em> <strong>mpfr_set_q</strong> <em>(mpfr_t <var>rop</var>, mpq_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005ff"></a>Function: <em>int</em> <strong>mpfr_set_f</strong> <em>(mpfr_t <var>rop</var>, mpf_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set the value of <var>rop</var> from <var>op</var>, rounded
toward the given direction <var>rnd</var>.
Note that the input 0 is converted to +0 by <code>mpfr_set_ui</code>,
<code>mpfr_set_si</code>, <code>mpfr_set_uj</code>, <code>mpfr_set_sj</code>,
The <code>mpfr_set_float128</code> function is built only with the configure
option &lsquo;<samp>--enable-float128</samp>&rsquo;, which requires the compiler or
system provides the &lsquo;<samp>__float128</samp>&rsquo; data type
(GCC 4.3 or later supports this data type);
to use <code>mpfr_set_float128</code>, one should define the macro
<code>MPFR_WANT_FLOAT128</code> before including <samp>mpfr.h</samp>.
<code>mpfr_set_z</code>, <code>mpfr_set_q</code> and
<code>mpfr_set_f</code>, regardless of the rounding mode.
If the system does not support the IEEE 754 standard,
<code>mpfr_set_flt</code>, <code>mpfr_set_d</code>, <code>mpfr_set_ld</code> and
<code>mpfr_set_decimal64</code> might not preserve the signed zeros.
The <code>mpfr_set_decimal64</code> function is built only with the configure
option &lsquo;<samp>--enable-decimal-float</samp>&rsquo;, and when the compiler or
system provides the &lsquo;<samp>_Decimal64</samp>&rsquo; data type
(recent versions of GCC support this data type);
to use <code>mpfr_set_decimal64</code>, one should define the macro
<code>MPFR_WANT_DECIMAL_FLOATS</code> before including <samp>mpfr.h</samp>.
<code>mpfr_set_q</code> might fail if the numerator (or the
denominator) can not be represented as a <code>mpfr_t</code>.
</p>
<p>For <code>mpfr_set</code>, the sign of a NaN is propagated in order to mimic the
IEEE 754 <code>copy</code> operation. But contrary to IEEE 754, the NaN flag is
set as usual.
</p>
<p>Note: If you want to store a floating-point constant to a <code>mpfr_t</code>,
you should use <code>mpfr_set_str</code> (or one of the MPFR constant functions,
such as <code>mpfr_const_pi</code> for <em>Pi</em>) instead of
<code>mpfr_set_flt</code>, <code>mpfr_set_d</code>,
<code>mpfr_set_ld</code> or <code>mpfr_set_decimal64</code>.
Otherwise the floating-point constant will be first
converted into a reduced-precision (e.g., 53-bit) binary
(or decimal, for <code>mpfr_set_decimal64</code>) number before
MPFR can work with it.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fset_005fui_005f2exp"></a>Function: <em>int</em> <strong>mpfr_set_ui_2exp</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op</var>, mpfr_exp_t <var>e</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fsi_005f2exp"></a>Function: <em>int</em> <strong>mpfr_set_si_2exp</strong> <em>(mpfr_t <var>rop</var>, long int <var>op</var>, mpfr_exp_t <var>e</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fuj_005f2exp"></a>Function: <em>int</em> <strong>mpfr_set_uj_2exp</strong> <em>(mpfr_t <var>rop</var>, uintmax_t <var>op</var>, intmax_t <var>e</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fsj_005f2exp"></a>Function: <em>int</em> <strong>mpfr_set_sj_2exp</strong> <em>(mpfr_t <var>rop</var>, intmax_t <var>op</var>, intmax_t <var>e</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fz_005f2exp"></a>Function: <em>int</em> <strong>mpfr_set_z_2exp</strong> <em>(mpfr_t <var>rop</var>, mpz_t <var>op</var>, mpfr_exp_t <var>e</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set the value of <var>rop</var> from <em><var>op</var> multiplied by
two to the power <var>e</var></em>, rounded toward the given direction <var>rnd</var>.
Note that the input 0 is converted to +0.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fset_005fstr"></a>Function: <em>int</em> <strong>mpfr_set_str</strong> <em>(mpfr_t <var>rop</var>, const char *<var>s</var>, int <var>base</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the string <var>s</var> in base <var>base</var>,
rounded in the direction <var>rnd</var>.
See the documentation of <code>mpfr_strtofr</code> for a detailed description
of the valid string formats.
Contrary to <code>mpfr_strtofr</code>, <code>mpfr_set_str</code> requires the
<em>whole</em> string to represent a valid floating-point number.
</p>
<p>The meaning of the return value differs from other MPFR functions:
it is 0 if the entire string up to the final null character
is a valid number in base <var>base</var>; otherwise it is -1, and
<var>rop</var> may have changed (users interested in the <a href="#ternary-value">ternary value</a>
should use <code>mpfr_strtofr</code> instead).
</p>
<p>Note: it is preferable to use <code>mpfr_strtofr</code> if one wants to distinguish
between an infinite <var>rop</var> value coming from an infinite <var>s</var> or from
an overflow.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fstrtofr"></a>Function: <em>int</em> <strong>mpfr_strtofr</strong> <em>(mpfr_t <var>rop</var>, const char *<var>nptr</var>, char **<var>endptr</var>, int <var>base</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Read a floating-point number from a string <var>nptr</var> in base <var>base</var>,
rounded in the direction <var>rnd</var>; <var>base</var> must be either 0 (to
detect the base, as described below) or a number from 2 to 62 (otherwise
the behavior is undefined). If <var>nptr</var> starts with valid data, the
result is stored in <var>rop</var> and <code>*<var>endptr</var></code> points to the
character just after the valid data (if <var>endptr</var> is not a null pointer);
otherwise <var>rop</var> is set to zero (for consistency with <code>strtod</code>)
and the value of <var>nptr</var> is stored
in the location referenced by <var>endptr</var> (if <var>endptr</var> is not a null
pointer). The usual ternary value is returned.
</p>
<p>Parsing follows the standard C <code>strtod</code> function with some extensions.
After optional leading whitespace, one has a subject sequence consisting of an
optional sign (&lsquo;<samp>+</samp>&rsquo; or &lsquo;<samp>-</samp>&rsquo;), and either numeric data or special
data. The subject sequence is defined as the longest initial subsequence of
the input string, starting with the first non-whitespace character, that is of
the expected form.
</p>
<p>The form of numeric data is a non-empty sequence of significand digits with an
optional decimal point, and an optional exponent consisting of an exponent
prefix followed by an optional sign and a non-empty sequence of decimal
digits. A significand digit is either a decimal digit or a Latin letter (62
possible characters), with &lsquo;<samp>A</samp>&rsquo; = 10, &lsquo;<samp>B</samp>&rsquo; = 11, &hellip;, &lsquo;<samp>Z</samp>&rsquo; =
35; case is ignored in bases less or equal to 36, in bases larger than 36,
&lsquo;<samp>a</samp>&rsquo; = 36, &lsquo;<samp>b</samp>&rsquo; = 37, &hellip;, &lsquo;<samp>z</samp>&rsquo; = 61.
The value of a
significand digit must be strictly less than the base.  The decimal point can
be either the one defined by the current locale or the period (the first one
is accepted for consistency with the C standard and the practice, the second
one is accepted to allow the programmer to provide MPFR numbers from strings
in a way that does not depend on the current locale).
The exponent prefix can be &lsquo;<samp>e</samp>&rsquo; or &lsquo;<samp>E</samp>&rsquo; for bases up to 10, or
&lsquo;<samp>@</samp>&rsquo; in any base; it indicates a multiplication by a power of the
base. In bases 2 and 16, the exponent prefix can also be &lsquo;<samp>p</samp>&rsquo; or &lsquo;<samp>P</samp>&rsquo;,
in which case the exponent, called <em>binary exponent</em>, indicates a
multiplication by a power of 2 instead of the base (there is a difference
only for base 16); in base 16 for example &lsquo;<samp>1p2</samp>&rsquo; represents 4 whereas
&lsquo;<samp>1@2</samp>&rsquo; represents 256. The value of an exponent is always written in
base 10.
</p>
<p>If the argument <var>base</var> is 0, then the base is automatically detected
as follows. If the significand starts with &lsquo;<samp>0b</samp>&rsquo; or &lsquo;<samp>0B</samp>&rsquo;, base 2
is assumed. If the significand starts with &lsquo;<samp>0x</samp>&rsquo; or &lsquo;<samp>0X</samp>&rsquo;, base 16
is assumed. Otherwise base 10 is assumed.
</p>
<p>Note: The exponent (if present)
must contain at least a digit. Otherwise the possible
exponent prefix and sign are not part of the number (which ends with the
significand). Similarly, if &lsquo;<samp>0b</samp>&rsquo;, &lsquo;<samp>0B</samp>&rsquo;, &lsquo;<samp>0x</samp>&rsquo; or &lsquo;<samp>0X</samp>&rsquo;
is not followed by a binary/hexadecimal digit, then the subject sequence
stops at the character &lsquo;<samp>0</samp>&rsquo;, thus 0 is read.
</p>
<p>Special data (for infinities and NaN) can be &lsquo;<samp>@inf@</samp>&rsquo; or
&lsquo;<samp>@nan@(n-char-sequence-opt)</samp>&rsquo;, and if <em><var>base</var> &lt;= 16</em>,
it can also be &lsquo;<samp>infinity</samp>&rsquo;, &lsquo;<samp>inf</samp>&rsquo;, &lsquo;<samp>nan</samp>&rsquo; or
&lsquo;<samp>nan(n-char-sequence-opt)</samp>&rsquo;, all case insensitive.
A &lsquo;<samp>n-char-sequence-opt</samp>&rsquo; is a possibly empty string containing only digits,
Latin letters and the underscore (0, 1, 2, &hellip;, 9, a, b, &hellip;, z,
A, B, &hellip;, Z, _). Note: one has an optional sign for all data, even
NaN.
For example, &lsquo;<samp>-@nAn@(This_Is_Not_17)</samp>&rsquo; is a valid representation for NaN
in base 17.
</p>
</dd></dl>

<dl>
<dt><a name="index-mpfr_005fset_005fnan"></a>Function: <em>void</em> <strong>mpfr_set_nan</strong> <em>(mpfr_t <var>x</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005finf"></a>Function: <em>void</em> <strong>mpfr_set_inf</strong> <em>(mpfr_t <var>x</var>, int <var>sign</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005fzero"></a>Function: <em>void</em> <strong>mpfr_set_zero</strong> <em>(mpfr_t <var>x</var>, int <var>sign</var>)</em></dt>
<dd><p>Set the variable <var>x</var> to NaN (Not-a-Number), infinity or zero respectively.
In <code>mpfr_set_inf</code> or <code>mpfr_set_zero</code>, <var>x</var> is set to plus
infinity or plus zero iff <var>sign</var> is nonnegative;
in <code>mpfr_set_nan</code>, the sign bit of the result is unspecified.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fswap"></a>Function: <em>void</em> <strong>mpfr_swap</strong> <em>(mpfr_t <var>x</var>, mpfr_t <var>y</var>)</em></dt>
<dd><p>Swap the structures pointed to by <var>x</var> and <var>y</var>. In particular,
the values are exchanged without rounding (this may be different from
three <code>mpfr_set</code> calls using a third auxiliary variable).
</p>
<p>Warning! Since the precisions are exchanged, this will affect future
assignments. Moreover, since the significand pointers are also exchanged,
you must not use this function if the allocation method used for <var>x</var>
and/or <var>y</var> does not permit it. This is the case when <var>x</var> and/or
<var>y</var> were declared and initialized with <code>MPFR_DECL_INIT</code>, and
possibly with <code>mpfr_custom_init_set</code> (see <a href="#Custom-Interface">Custom Interface</a>).
</p></dd></dl>

<hr>
<a name="Combined-Initialization-and-Assignment-Functions"></a>
<div class="header">
<p>
Next: <a href="#Conversion-Functions" accesskey="n" rel="next">Conversion Functions</a>, Previous: <a href="#Assignment-Functions" accesskey="p" rel="prev">Assignment Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Combined-initialization-and-assignment-functions"></a>
<a name="Combined-Initialization-and-Assignment-Functions-1"></a>
<h3 class="section">5.3 Combined Initialization and Assignment Functions</h3>

<dl>
<dt><a name="index-mpfr_005finit_005fset"></a>Macro: <em>int</em> <strong>mpfr_init_set</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005finit_005fset_005fui"></a>Macro: <em>int</em> <strong>mpfr_init_set_ui</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005finit_005fset_005fsi"></a>Macro: <em>int</em> <strong>mpfr_init_set_si</strong> <em>(mpfr_t <var>rop</var>, long int <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005finit_005fset_005fd"></a>Macro: <em>int</em> <strong>mpfr_init_set_d</strong> <em>(mpfr_t <var>rop</var>, double <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005finit_005fset_005fld"></a>Macro: <em>int</em> <strong>mpfr_init_set_ld</strong> <em>(mpfr_t <var>rop</var>, long double <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005finit_005fset_005fz"></a>Macro: <em>int</em> <strong>mpfr_init_set_z</strong> <em>(mpfr_t <var>rop</var>, mpz_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005finit_005fset_005fq"></a>Macro: <em>int</em> <strong>mpfr_init_set_q</strong> <em>(mpfr_t <var>rop</var>, mpq_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005finit_005fset_005ff"></a>Macro: <em>int</em> <strong>mpfr_init_set_f</strong> <em>(mpfr_t <var>rop</var>, mpf_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Initialize <var>rop</var> and set its value from <var>op</var>, rounded in the direction
<var>rnd</var>.
The precision of <var>rop</var> will be taken from the active default precision,
as set by <code>mpfr_set_default_prec</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005finit_005fset_005fstr"></a>Function: <em>int</em> <strong>mpfr_init_set_str</strong> <em>(mpfr_t <var>x</var>, const char *<var>s</var>, int <var>base</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Initialize <var>x</var> and set its value from
the string <var>s</var> in base <var>base</var>,
rounded in the direction <var>rnd</var>.
See <code>mpfr_set_str</code>.
</p></dd></dl>

<hr>
<a name="Conversion-Functions"></a>
<div class="header">
<p>
Next: <a href="#Basic-Arithmetic-Functions" accesskey="n" rel="next">Basic Arithmetic Functions</a>, Previous: <a href="#Combined-Initialization-and-Assignment-Functions" accesskey="p" rel="prev">Combined Initialization and Assignment Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Conversion-functions"></a>
<a name="Conversion-Functions-1"></a>
<h3 class="section">5.4 Conversion Functions</h3>

<dl>
<dt><a name="index-mpfr_005fget_005fflt"></a>Function: <em>float</em> <strong>mpfr_get_flt</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fget_005fd"></a>Function: <em>double</em> <strong>mpfr_get_d</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fget_005fld"></a>Function: <em>long double</em> <strong>mpfr_get_ld</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fget_005ffloat128"></a>Function: <em>__float128</em> <strong>mpfr_get_float128</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fget_005fdecimal64"></a>Function: <em>_Decimal64</em> <strong>mpfr_get_decimal64</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Convert <var>op</var> to a <code>float</code> (respectively <code>double</code>,
<code>long double</code> or <code>_Decimal64</code>), using the rounding mode <var>rnd</var>.
If <var>op</var> is NaN, some fixed NaN (either quiet or signaling) or the result
of 0.0/0.0 is returned. If <var>op</var> is ±Inf, an infinity of the same
sign or the result of ±1.0/0.0 is returned. If <var>op</var> is zero, these
functions return a zero, trying to preserve its sign, if possible.
The <code>mpfr_get_float128</code> and <code>mpfr_get_decimal64</code> functions are built
only under some conditions: see the documentation of <code>mpfr_set_float128</code>
and <code>mpfr_set_decimal64</code> respectively.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005fsi"></a>Function: <em>long</em> <strong>mpfr_get_si</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fget_005fui"></a>Function: <em>unsigned long</em> <strong>mpfr_get_ui</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fget_005fsj"></a>Function: <em>intmax_t</em> <strong>mpfr_get_sj</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fget_005fuj"></a>Function: <em>uintmax_t</em> <strong>mpfr_get_uj</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Convert <var>op</var> to a <code>long</code>, an <code>unsigned long</code>,
an <code>intmax_t</code> or an <code>uintmax_t</code> (respectively) after rounding
it to an integer with respect to <var>rnd</var>.
If <var>op</var> is NaN, 0 is returned and the <em>erange</em> flag is set.
If <var>op</var> is too big for the return type, the function returns the maximum
or the minimum of the corresponding C type, depending on the direction
of the overflow; the <em>erange</em> flag is set too.
When there is no such range error, if the return value differs from
<var>op</var>, i.e., if <var>op</var> is not an integer, the inexact flag is set.
See also <code>mpfr_fits_slong_p</code>, <code>mpfr_fits_ulong_p</code>,
<code>mpfr_fits_intmax_p</code> and <code>mpfr_fits_uintmax_p</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005fd_005f2exp"></a>Function: <em>double</em> <strong>mpfr_get_d_2exp</strong> <em>(long *<var>exp</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fget_005fld_005f2exp"></a>Function: <em>long double</em> <strong>mpfr_get_ld_2exp</strong> <em>(long *<var>exp</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Return <var>d</var> and set <var>exp</var>
(formally, the value pointed to by <var>exp</var>)
such that <em>0.5&lt;=abs(<var>d</var>)&lt;1</em>
and <em><var>d</var> times 2 raised to <var>exp</var></em> equals
<var>op</var> rounded to double (resp. long double)
precision, using the given rounding mode.
If <var>op</var> is zero, then a zero of the same sign (or an unsigned zero,
if the implementation does not have signed zeros) is returned, and
<var>exp</var> is set to 0.
If <var>op</var> is NaN or an infinity, then the corresponding double precision
(resp. long-double precision)
value is returned, and <var>exp</var> is undefined.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ffrexp"></a>Function: <em>int</em> <strong>mpfr_frexp</strong> <em>(mpfr_exp_t *<var>exp</var>, mpfr_t <var>y</var>, mpfr_t <var>x</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>exp</var>
(formally, the value pointed to by <var>exp</var>) and <var>y</var>
such that <em>0.5&lt;=abs(<var>y</var>)&lt;1</em>
and <em><var>y</var> times 2 raised to <var>exp</var></em> equals
<var>x</var> rounded to the precision of <var>y</var>, using the given rounding mode.
If <var>x</var> is zero, then <var>y</var> is set to a zero of the same sign and
<var>exp</var> is set to 0.
If <var>x</var> is NaN or an infinity, then <var>y</var> is set to the same value
and <var>exp</var> is undefined.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005fz_005f2exp"></a>Function: <em>mpfr_exp_t</em> <strong>mpfr_get_z_2exp</strong> <em>(mpz_t <var>rop</var>, mpfr_t <var>op</var>)</em></dt>
<dd><p>Put the scaled significand of <var>op</var> (regarded as an integer, with the
precision of <var>op</var>) into <var>rop</var>, and return the exponent <var>exp</var>
(which may be outside the current exponent range) such that <var>op</var>
exactly equals
<var>rop</var> times 2 raised to the power <var>exp</var>.
If <var>op</var> is zero, the minimal exponent <code>emin</code> is returned.
If <var>op</var> is NaN or an infinity, the <em>erange</em> flag is set, <var>rop</var>
is set to 0, and the the minimal exponent <code>emin</code> is returned.
The returned exponent may be less than the minimal exponent <code>emin</code>
of MPFR numbers in the current exponent range; in case the exponent is
not representable in the <code>mpfr_exp_t</code> type, the <em>erange</em> flag
is set and the minimal value of the <code>mpfr_exp_t</code> type is returned.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005fz"></a>Function: <em>int</em> <strong>mpfr_get_z</strong> <em>(mpz_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Convert <var>op</var> to a <code>mpz_t</code>, after rounding it with respect to
<var>rnd</var>. If <var>op</var> is NaN or an infinity, the <em>erange</em> flag is
set, <var>rop</var> is set to 0, and 0 is returned. Otherwise the return
value is zero when <var>rop</var> is equal to <var>op</var> (i.e., when <var>op</var>
is an integer), positive when it is greater than <var>op</var>, and negative
when it is smaller than <var>op</var>; moreover, if <var>rop</var> differs from
<var>op</var>, i.e., if <var>op</var> is not an integer, the inexact flag is set.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005fq"></a>Function: <em>void</em> <strong>mpfr_get_q</strong> <em>(mpq_t <var>rop</var>, mpfr_t <var>op</var>)</em></dt>
<dd><p>Convert <var>op</var> to a <code>mpq_t</code>.
If <var>op</var> is NaN or an infinity, the <em>erange</em> flag is
set and <var>rop</var> is set to 0. Otherwise the conversion is always exact.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005ff"></a>Function: <em>int</em> <strong>mpfr_get_f</strong> <em>(mpf_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Convert <var>op</var> to a <code>mpf_t</code>, after rounding it with respect to
<var>rnd</var>.
The <em>erange</em> flag is set if <var>op</var> is NaN or an infinity, which
do not exist in MPF.  If <var>op</var> is NaN, then <var>rop</var> is undefined.
If <var>op</var> is +Inf (resp. -Inf), then <var>rop</var> is set to
the maximum (resp. minimum) value in the precision of the MPF number;
if a future MPF version supports infinities, this behavior will be
considered incorrect and will change (portable programs should assume
that <var>rop</var> is set either to this finite number or to an infinite
number).
Note that since MPFR currently has the same exponent type as MPF (but
not with the same radix), the range of values is much larger in MPF
than in MPFR, so that an overflow or underflow is not possible.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005fstr"></a>Function: <em>char *</em> <strong>mpfr_get_str</strong> <em>(char *<var>str</var>, mpfr_exp_t *<var>expptr</var>, int <var>b</var>, size_t <var>n</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Convert <var>op</var> to a string of digits in base <var>b</var>, with rounding in
the direction <var>rnd</var>, where <var>n</var> is either zero (see below) or the
number of significant digits output in the string; in the latter case,
<var>n</var> must be greater or equal to 2. The base may vary from 2 to 62;
otherwise the function does nothing and immediately returns a null pointer.
</p>
<p>If the input is NaN, then the returned string is &lsquo;<samp>@NaN@</samp>&rsquo; and the
NaN flag is set. If the input is +Inf (resp. -Inf), then the
returned string is &lsquo;<samp>@Inf@</samp>&rsquo; (resp. &lsquo;<samp>-@Inf@</samp>&rsquo;).
</p>
<p>If the input number is a finite number, the exponent is written through
the pointer <var>expptr</var> (for input 0, the current minimal exponent is
written); the type <code>mpfr_exp_t</code> is large enough to hold the exponent
in all cases.
</p>
<p>The generated string is a fraction, with an implicit radix point immediately
to the left of the first digit.  For example, the number -3.1416 would
be returned as &quot;-31416&quot; in the string and 1 written at <var>expptr</var>.
If <var>rnd</var> is to nearest, and <var>op</var> is exactly in the middle of two
consecutive possible outputs, the one with an even significand is chosen,
where both significands are considered with the exponent of <var>op</var>.
Note that for an odd base, this may not correspond to an even last digit:
for example with 2 digits in base 7, (14) and a half is rounded to (15)
which is 12 in decimal, (16) and a half is rounded to
(20) which is 14 in decimal,
and (26) and a half is rounded to (26) which is 20 in decimal.
</p>
<p>If <var>n</var> is zero, the number of digits of the significand is chosen
large enough so that re-reading the printed value with the same precision,
assuming both output and input use rounding to nearest, will recover
the original value of <var>op</var>.
More precisely, in most cases, the chosen precision of <var>str</var> is the
minimal precision <em>m</em> depending only on <var>p</var> = PREC(<var>op</var>) and
<var>b</var> that satisfies the above property, i.e.,
m = 1 + ceil(<var>p</var>*log(2)/log(<var>b</var>)),
with <var>p</var> replaced by <var>p</var>-1 if <var>b</var> is a power of 2,
but in some very rare cases, it might be <em>m+1</em>
(the smallest case for bases up to 62 is when <var>p</var> equals 186564318007
for bases 7 and 49).
</p>
<p>If <var>str</var> is a null pointer, space for the significand is allocated using
the allocation function (see <a href="#Memory-Handling">Memory Handling</a>) and a pointer to the string
is returned (unless the base is invalid).
To free the returned string, you must use <code>mpfr_free_str</code>.
</p>
<p>If <var>str</var> is not a null pointer, it should point to a block of storage
large enough for the significand. A safe block size (sufficient for any
value) is <code>max(<var>n</var> + 2, 7)</code> if <var>n</var> is not zero; if <var>n</var> is
zero, replace it by <em>m+1</em>, as discussed above. The extra two bytes are
for a possible minus sign, and for the terminating null character, and the
value 7 accounts for &lsquo;<samp>-@Inf@</samp>&rsquo; plus the terminating null character.
The pointer to the string <var>str</var> is returned (unless the base is invalid).
</p>
<p>Like in usual functions, the inexact flag is set iff the result is inexact.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ffree_005fstr"></a>Function: <em>void</em> <strong>mpfr_free_str</strong> <em>(char *<var>str</var>)</em></dt>
<dd><p>Free a string allocated by <code>mpfr_get_str</code> using the unallocation
function (see <a href="#Memory-Handling">Memory Handling</a>).
The block is assumed to be <code>strlen(<var>str</var>)+1</code> bytes.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ffits_005fulong_005fp"></a>Function: <em>int</em> <strong>mpfr_fits_ulong_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ffits_005fslong_005fp"></a>Function: <em>int</em> <strong>mpfr_fits_slong_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ffits_005fuint_005fp"></a>Function: <em>int</em> <strong>mpfr_fits_uint_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ffits_005fsint_005fp"></a>Function: <em>int</em> <strong>mpfr_fits_sint_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ffits_005fushort_005fp"></a>Function: <em>int</em> <strong>mpfr_fits_ushort_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ffits_005fsshort_005fp"></a>Function: <em>int</em> <strong>mpfr_fits_sshort_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ffits_005fuintmax_005fp"></a>Function: <em>int</em> <strong>mpfr_fits_uintmax_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ffits_005fintmax_005fp"></a>Function: <em>int</em> <strong>mpfr_fits_intmax_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Return non-zero if <var>op</var> would fit in the respective C data type,
respectively <code>unsigned long</code>, <code>long</code>, <code>unsigned int</code>,
<code>int</code>, <code>unsigned short</code>, <code>short</code>, <code>uintmax_t</code>,
<code>intmax_t</code>, when rounded to an integer in the direction <var>rnd</var>.
For instance, with the <code>MPFR_RNDU</code> rounding mode on -0.5,
the result will be non-zero for all these functions.
For <code>MPFR_RNDF</code>, those functions return non-zero when it is guaranteed
that the corresponding conversion function (for example <code>mpfr_get_ui</code>
for <code>mpfr_fits_ulong_p</code>), when called with faithful rounding,
will always return a number that is representable in the corresponding type.
As a consequence, for <code>MPFR_RNDF</code>, <code>mpfr_fits_ulong_p</code> will return
non-zero for a non-negative number less or equal to <code>ULONG_MAX</code>.
</p></dd></dl>

<hr>
<a name="Basic-Arithmetic-Functions"></a>
<div class="header">
<p>
Next: <a href="#Comparison-Functions" accesskey="n" rel="next">Comparison Functions</a>, Previous: <a href="#Conversion-Functions" accesskey="p" rel="prev">Conversion Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Basic-arithmetic-functions"></a>
<a name="index-Float-arithmetic-functions"></a>
<a name="index-Arithmetic-functions"></a>
<a name="Basic-Arithmetic-Functions-1"></a>
<h3 class="section">5.5 Basic Arithmetic Functions</h3>

<dl>
<dt><a name="index-mpfr_005fadd"></a>Function: <em>int</em> <strong>mpfr_add</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fadd_005fui"></a>Function: <em>int</em> <strong>mpfr_add_ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fadd_005fsi"></a>Function: <em>int</em> <strong>mpfr_add_si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fadd_005fd"></a>Function: <em>int</em> <strong>mpfr_add_d</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, double <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fadd_005fz"></a>Function: <em>int</em> <strong>mpfr_add_z</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpz_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fadd_005fq"></a>Function: <em>int</em> <strong>mpfr_add_q</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpq_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em><var>op1</var> + <var>op2</var></em> rounded in the direction
<var>rnd</var>.  The IEEE 754 rules are used, in particular for signed zeros.
But for types having no signed zeros, 0 is considered unsigned
(i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
The <code>mpfr_add_d</code> function assumes that the radix of the <code>double</code> type
is a power of 2, with a precision at most that declared by the C implementation
(macro <code>IEEE_DBL_MANT_DIG</code>, and if not defined 53 bits).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsub"></a>Function: <em>int</em> <strong>mpfr_sub</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fui_005fsub"></a>Function: <em>int</em> <strong>mpfr_ui_sub</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fsub_005fui"></a>Function: <em>int</em> <strong>mpfr_sub_ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fsi_005fsub"></a>Function: <em>int</em> <strong>mpfr_si_sub</strong> <em>(mpfr_t <var>rop</var>, long int <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fsub_005fsi"></a>Function: <em>int</em> <strong>mpfr_sub_si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fd_005fsub"></a>Function: <em>int</em> <strong>mpfr_d_sub</strong> <em>(mpfr_t <var>rop</var>, double <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fsub_005fd"></a>Function: <em>int</em> <strong>mpfr_sub_d</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, double <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fz_005fsub"></a>Function: <em>int</em> <strong>mpfr_z_sub</strong> <em>(mpfr_t <var>rop</var>, mpz_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fsub_005fz"></a>Function: <em>int</em> <strong>mpfr_sub_z</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpz_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fsub_005fq"></a>Function: <em>int</em> <strong>mpfr_sub_q</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpq_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em><var>op1</var> - <var>op2</var></em> rounded in the direction
<var>rnd</var>.  The IEEE 754 rules are used, in particular for signed zeros.
But for types having no signed zeros, 0 is considered unsigned
(i.e., (+0) - 0 = (+0), (-0) - 0 = (-0),
0 - (+0) = (-0) and 0 - (-0) = (+0)).
The same restrictions than for <code>mpfr_add_d</code> apply to <code>mpfr_d_sub</code>
and <code>mpfr_sub_d</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fmul"></a>Function: <em>int</em> <strong>mpfr_mul</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fmul_005fui"></a>Function: <em>int</em> <strong>mpfr_mul_ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fmul_005fsi"></a>Function: <em>int</em> <strong>mpfr_mul_si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fmul_005fd"></a>Function: <em>int</em> <strong>mpfr_mul_d</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, double <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fmul_005fz"></a>Function: <em>int</em> <strong>mpfr_mul_z</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpz_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fmul_005fq"></a>Function: <em>int</em> <strong>mpfr_mul_q</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpq_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em><var>op1</var> times <var>op2</var></em> rounded in the
direction <var>rnd</var>.
When a result is zero, its sign is the product of the signs of the operands
(for types having no signed zeros, 0 is considered positive).
The same restrictions than for <code>mpfr_add_d</code> apply to <code>mpfr_mul_d</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsqr"></a>Function: <em>int</em> <strong>mpfr_sqr</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em>the square of <var>op</var></em>
rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fdiv"></a>Function: <em>int</em> <strong>mpfr_div</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fui_005fdiv"></a>Function: <em>int</em> <strong>mpfr_ui_div</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fdiv_005fui"></a>Function: <em>int</em> <strong>mpfr_div_ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fsi_005fdiv"></a>Function: <em>int</em> <strong>mpfr_si_div</strong> <em>(mpfr_t <var>rop</var>, long int <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fdiv_005fsi"></a>Function: <em>int</em> <strong>mpfr_div_si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fd_005fdiv"></a>Function: <em>int</em> <strong>mpfr_d_div</strong> <em>(mpfr_t <var>rop</var>, double <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fdiv_005fd"></a>Function: <em>int</em> <strong>mpfr_div_d</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, double <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fdiv_005fz"></a>Function: <em>int</em> <strong>mpfr_div_z</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpz_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fdiv_005fq"></a>Function: <em>int</em> <strong>mpfr_div_q</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpq_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em><var>op1</var>/<var>op2</var></em> rounded in the direction <var>rnd</var>.
When a result is zero, its sign is the product of the signs of the operands.
For types having no signed zeros, 0 is considered positive; but note that if
<var>op1</var> is non-zero and <var>op2</var> is zero, the result might change from
±Inf to NaN in future MPFR versions if there is an opposite decision
on the IEEE 754 side.
The same restrictions than for <code>mpfr_add_d</code> apply to <code>mpfr_d_div</code>
and <code>mpfr_div_d</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsqrt"></a>Function: <em>int</em> <strong>mpfr_sqrt</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fsqrt_005fui"></a>Function: <em>int</em> <strong>mpfr_sqrt_ui</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em>the square root of <var>op</var></em>
rounded in the direction <var>rnd</var>.  Set <var>rop</var> to -0 if
<var>op</var> is -0, to be consistent with the IEEE 754 standard.
Set <var>rop</var> to NaN if <var>op</var> is negative.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005frec_005fsqrt"></a>Function: <em>int</em> <strong>mpfr_rec_sqrt</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em>the reciprocal square root of <var>op</var></em>
rounded in the direction <var>rnd</var>.  Set <var>rop</var> to +Inf if <var>op</var> is
±0, +0 if <var>op</var> is +Inf, and NaN if <var>op</var> is negative.  Warning!
Therefore the result on -0 is different from the one of the rSqrt
function recommended by the IEEE 754-2008 standard (Section 9.2.1), which
is -Inf instead of +Inf.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcbrt"></a>Function: <em>int</em> <strong>mpfr_cbrt</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005frootn_005fui"></a>Function: <em>int</em> <strong>mpfr_rootn_ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, unsigned long int <var>k</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the cubic root (resp. the <var>k</var>th root)
of <var>op</var> rounded in the direction <var>rnd</var>.
For <var>k</var> = 0, set <var>rop</var> to NaN.
For <var>k</var> odd (resp. even) and <var>op</var> negative (including -Inf),
set <var>rop</var> to a negative number (resp. NaN).
If <var>op</var> is zero, set <var>rop</var> to zero with the sign obtained by the
usual limit rules, i.e., the same sign as <var>op</var> if <var>k</var> is odd, and
positive if <var>k</var> is even.
</p>
<p>These functions agree with the rootn function of the IEEE 754-2008 standard
(Section 9.2).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005froot"></a>Function: <em>int</em> <strong>mpfr_root</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, unsigned long int <var>k</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>This function is the same as <code>mpfr_rootn_ui</code> except when <var>op</var>
is -0 and <var>k</var> is even: the result is -0 instead of +0
(the reason was to be consistent with <code>mpfr_sqrt</code>). Said otherwise,
if <var>op</var> is zero, set <var>rop</var> to <var>op</var>.
</p>
<p>This function predates the IEEE 754-2008 standard and behaves differently
from its rootn function. It is marked as deprecated and will be removed in
a future release.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fpow"></a>Function: <em>int</em> <strong>mpfr_pow</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fpow_005fui"></a>Function: <em>int</em> <strong>mpfr_pow_ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fpow_005fsi"></a>Function: <em>int</em> <strong>mpfr_pow_si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fpow_005fz"></a>Function: <em>int</em> <strong>mpfr_pow_z</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpz_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fui_005fpow_005fui"></a>Function: <em>int</em> <strong>mpfr_ui_pow_ui</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fui_005fpow"></a>Function: <em>int</em> <strong>mpfr_ui_pow</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em><var>op1</var> raised to <var>op2</var></em>,
rounded in the direction <var>rnd</var>.
Special values are handled as described in the ISO C99 and IEEE 754-2008
standards for the <code>pow</code> function:
</p><ul>
<li> <code>pow(±0, <var>y</var>)</code> returns plus or minus infinity for <var>y</var> a negative odd integer.
</li><li> <code>pow(±0, <var>y</var>)</code> returns plus infinity for <var>y</var> negative and not an odd integer.
</li><li> <code>pow(±0, <var>y</var>)</code> returns plus or minus zero for <var>y</var> a positive odd integer.
</li><li> <code>pow(±0, <var>y</var>)</code> returns plus zero for <var>y</var> positive and not an odd integer.
</li><li> <code>pow(-1, ±Inf)</code> returns 1.
</li><li> <code>pow(+1, <var>y</var>)</code> returns 1 for any <var>y</var>, even a NaN.
</li><li> <code>pow(<var>x</var>, ±0)</code> returns 1 for any <var>x</var>, even a NaN.
</li><li> <code>pow(<var>x</var>, <var>y</var>)</code> returns NaN for finite negative <var>x</var> and finite non-integer <var>y</var>.
</li><li> <code>pow(<var>x</var>, -Inf)</code> returns plus infinity for <em>0 &lt; abs(x) &lt; 1</em>, and plus zero for <em>abs(x) &gt; 1</em>.
</li><li> <code>pow(<var>x</var>, +Inf)</code> returns plus zero for <em>0 &lt; abs(x) &lt; 1</em>, and plus infinity for <em>abs(x) &gt; 1</em>.
</li><li> <code>pow(-Inf, <var>y</var>)</code> returns minus zero for <var>y</var> a negative odd integer.
</li><li> <code>pow(-Inf, <var>y</var>)</code> returns plus zero for <var>y</var> negative and not an odd integer.
</li><li> <code>pow(-Inf, <var>y</var>)</code> returns minus infinity for <var>y</var> a positive odd integer.
</li><li> <code>pow(-Inf, <var>y</var>)</code> returns plus infinity for <var>y</var> positive and not an odd integer.
</li><li> <code>pow(+Inf, <var>y</var>)</code> returns plus zero for <var>y</var> negative, and plus infinity for <var>y</var> positive.
</li></ul>
<p>Note: When 0 is of integer type, it is regarded as +0 by these functions.
We do not use the usual limit rules in this case, as these rules are not
used for <code>pow</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fneg"></a>Function: <em>int</em> <strong>mpfr_neg</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fabs"></a>Function: <em>int</em> <strong>mpfr_abs</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em>-<var>op</var></em> and the absolute value of <var>op</var>
respectively, rounded in the direction <var>rnd</var>.
Just changes or adjusts
the sign if <var>rop</var> and <var>op</var> are the same variable,
otherwise a rounding might occur if the precision of <var>rop</var> is less than
that of <var>op</var>.
</p>
<p>The sign rule also applies to NaN in order to mimic the IEEE 754
<code>negate</code> and <code>abs</code> operations, i.e., for <code>mpfr_neg</code>, the
sign is reversed, and for <code>mpfr_abs</code>, the sign is set to positive.
But contrary to IEEE 754, the NaN flag is set as usual.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fdim"></a>Function: <em>int</em> <strong>mpfr_dim</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the positive difference of <var>op1</var> and <var>op2</var>, i.e.,
<em><var>op1</var> - <var>op2</var></em> rounded in the direction <var>rnd</var>
if <em><var>op1</var> &gt; <var>op2</var></em>, +0 if <em><var>op1</var> &lt;= <var>op2</var></em>,
and NaN if <var>op1</var> or <var>op2</var> is NaN.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fmul_005f2ui"></a>Function: <em>int</em> <strong>mpfr_mul_2ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fmul_005f2si"></a>Function: <em>int</em> <strong>mpfr_mul_2si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em><var>op1</var> times 2 raised
to <var>op2</var></em>
rounded in the direction <var>rnd</var>. Just increases the exponent by <var>op2</var>
when <var>rop</var> and <var>op1</var> are identical.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fdiv_005f2ui"></a>Function: <em>int</em> <strong>mpfr_div_2ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fdiv_005f2si"></a>Function: <em>int</em> <strong>mpfr_div_2si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em><var>op1</var> divided by 2 raised
to <var>op2</var></em>
rounded in the direction <var>rnd</var>. Just decreases the exponent by <var>op2</var>
when <var>rop</var> and <var>op1</var> are identical.
</p></dd></dl>

<hr>
<a name="Comparison-Functions"></a>
<div class="header">
<p>
Next: <a href="#Special-Functions" accesskey="n" rel="next">Special Functions</a>, Previous: <a href="#Basic-Arithmetic-Functions" accesskey="p" rel="prev">Basic Arithmetic Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Float-comparisons-functions"></a>
<a name="index-Comparison-functions"></a>
<a name="Comparison-Functions-1"></a>
<h3 class="section">5.6 Comparison Functions</h3>

<dl>
<dt><a name="index-mpfr_005fcmp"></a>Function: <em>int</em> <strong>mpfr_cmp</strong> <em>(mpfr_t <var>op1</var>, mpfr_t <var>op2</var>)</em></dt>
<dt><a name="index-mpfr_005fcmp_005fui"></a>Function: <em>int</em> <strong>mpfr_cmp_ui</strong> <em>(mpfr_t <var>op1</var>, unsigned long int <var>op2</var>)</em></dt>
<dt><a name="index-mpfr_005fcmp_005fsi"></a>Function: <em>int</em> <strong>mpfr_cmp_si</strong> <em>(mpfr_t <var>op1</var>, long int <var>op2</var>)</em></dt>
<dt><a name="index-mpfr_005fcmp_005fd"></a>Function: <em>int</em> <strong>mpfr_cmp_d</strong> <em>(mpfr_t <var>op1</var>, double <var>op2</var>)</em></dt>
<dt><a name="index-mpfr_005fcmp_005fld"></a>Function: <em>int</em> <strong>mpfr_cmp_ld</strong> <em>(mpfr_t <var>op1</var>, long double <var>op2</var>)</em></dt>
<dt><a name="index-mpfr_005fcmp_005fz"></a>Function: <em>int</em> <strong>mpfr_cmp_z</strong> <em>(mpfr_t <var>op1</var>, mpz_t <var>op2</var>)</em></dt>
<dt><a name="index-mpfr_005fcmp_005fq"></a>Function: <em>int</em> <strong>mpfr_cmp_q</strong> <em>(mpfr_t <var>op1</var>, mpq_t <var>op2</var>)</em></dt>
<dt><a name="index-mpfr_005fcmp_005ff"></a>Function: <em>int</em> <strong>mpfr_cmp_f</strong> <em>(mpfr_t <var>op1</var>, mpf_t <var>op2</var>)</em></dt>
<dd><p>Compare <var>op1</var> and <var>op2</var>.  Return a positive value if <em><var>op1</var> &gt;
<var>op2</var></em>, zero if <em><var>op1</var> = <var>op2</var></em>, and a negative value if
<em><var>op1</var> &lt; <var>op2</var></em>.
Both <var>op1</var> and <var>op2</var> are considered to their full own precision,
which may differ.
If one of the operands is NaN, set the <em>erange</em> flag and return zero.
</p>
<p>Note: These functions may be useful to distinguish the three possible cases.
If you need to distinguish two cases only, it is recommended to use the
predicate functions (e.g., <code>mpfr_equal_p</code> for the equality) described
below; they behave like the IEEE 754 comparisons, in particular when one
or both arguments are NaN. But only floating-point numbers can be compared
(you may need to do a conversion first).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcmp_005fui_005f2exp"></a>Function: <em>int</em> <strong>mpfr_cmp_ui_2exp</strong> <em>(mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_exp_t <var>e</var>)</em></dt>
<dt><a name="index-mpfr_005fcmp_005fsi_005f2exp"></a>Function: <em>int</em> <strong>mpfr_cmp_si_2exp</strong> <em>(mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_exp_t <var>e</var>)</em></dt>
<dd><p>Compare <var>op1</var> and <em><var>op2</var> multiplied by two to
the power <var>e</var></em>. Similar as above.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcmpabs"></a>Function: <em>int</em> <strong>mpfr_cmpabs</strong> <em>(mpfr_t <var>op1</var>, mpfr_t <var>op2</var>)</em></dt>
<dd><p>Compare <em>|<var>op1</var>|</em> and <em>|<var>op2</var>|</em>.  Return a positive value if
<em>|<var>op1</var>| &gt; |<var>op2</var>|</em>, zero if <em>|<var>op1</var>| = |<var>op2</var>|</em>, and
a negative value if <em>|<var>op1</var>| &lt; |<var>op2</var>|</em>.
If one of the operands is NaN, set the <em>erange</em> flag and return zero.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fnan_005fp"></a>Function: <em>int</em> <strong>mpfr_nan_p</strong> <em>(mpfr_t <var>op</var>)</em></dt>
<dt><a name="index-mpfr_005finf_005fp"></a>Function: <em>int</em> <strong>mpfr_inf_p</strong> <em>(mpfr_t <var>op</var>)</em></dt>
<dt><a name="index-mpfr_005fnumber_005fp"></a>Function: <em>int</em> <strong>mpfr_number_p</strong> <em>(mpfr_t <var>op</var>)</em></dt>
<dt><a name="index-mpfr_005fzero_005fp"></a>Function: <em>int</em> <strong>mpfr_zero_p</strong> <em>(mpfr_t <var>op</var>)</em></dt>
<dt><a name="index-mpfr_005fregular_005fp"></a>Function: <em>int</em> <strong>mpfr_regular_p</strong> <em>(mpfr_t <var>op</var>)</em></dt>
<dd><p>Return non-zero if <var>op</var> is respectively NaN, an infinity, an ordinary
number (i.e., neither NaN nor an infinity), zero, or a regular number
(i.e., neither NaN, nor an infinity nor zero). Return zero otherwise.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsgn"></a>Macro: <em>int</em> <strong>mpfr_sgn</strong> <em>(mpfr_t <var>op</var>)</em></dt>
<dd><p>Return a positive value if <em><var>op</var> &gt; 0</em>, zero if <em><var>op</var> = 0</em>,
and a negative value if <em><var>op</var> &lt; 0</em>.
If the operand is NaN, set the <em>erange</em> flag and return zero.
This is equivalent to <code>mpfr_cmp_ui (op, 0)</code>, but more efficient.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fgreater_005fp"></a>Function: <em>int</em> <strong>mpfr_greater_p</strong> <em>(mpfr_t <var>op1</var>, mpfr_t <var>op2</var>)</em></dt>
<dt><a name="index-mpfr_005fgreaterequal_005fp"></a>Function: <em>int</em> <strong>mpfr_greaterequal_p</strong> <em>(mpfr_t <var>op1</var>, mpfr_t <var>op2</var>)</em></dt>
<dt><a name="index-mpfr_005fless_005fp"></a>Function: <em>int</em> <strong>mpfr_less_p</strong> <em>(mpfr_t <var>op1</var>, mpfr_t <var>op2</var>)</em></dt>
<dt><a name="index-mpfr_005flessequal_005fp"></a>Function: <em>int</em> <strong>mpfr_lessequal_p</strong> <em>(mpfr_t <var>op1</var>, mpfr_t <var>op2</var>)</em></dt>
<dt><a name="index-mpfr_005fequal_005fp"></a>Function: <em>int</em> <strong>mpfr_equal_p</strong> <em>(mpfr_t <var>op1</var>, mpfr_t <var>op2</var>)</em></dt>
<dd><p>Return non-zero if
<em><var>op1</var> &gt; <var>op2</var></em>,
<em><var>op1</var> &gt;= <var>op2</var></em>,
<em><var>op1</var> &lt; <var>op2</var></em>,
<em><var>op1</var> &lt;= <var>op2</var></em>,
<em><var>op1</var> = <var>op2</var></em> respectively,
and zero otherwise.
Those functions return zero whenever <var>op1</var> and/or <var>op2</var> is NaN.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005flessgreater_005fp"></a>Function: <em>int</em> <strong>mpfr_lessgreater_p</strong> <em>(mpfr_t <var>op1</var>, mpfr_t <var>op2</var>)</em></dt>
<dd><p>Return non-zero if <em><var>op1</var> &lt; <var>op2</var></em> or
<em><var>op1</var> &gt; <var>op2</var></em> (i.e., neither <var>op1</var>, nor <var>op2</var> is
NaN, and <em><var>op1</var> &lt;&gt; <var>op2</var></em>), zero otherwise (i.e., <var>op1</var>
and/or <var>op2</var> is NaN, or <em><var>op1</var> = <var>op2</var></em>).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005funordered_005fp"></a>Function: <em>int</em> <strong>mpfr_unordered_p</strong> <em>(mpfr_t <var>op1</var>, mpfr_t <var>op2</var>)</em></dt>
<dd><p>Return non-zero if <var>op1</var> or <var>op2</var> is a NaN (i.e., they cannot be
compared), zero otherwise.
</p></dd></dl>

<hr>
<a name="Special-Functions"></a>
<div class="header">
<p>
Next: <a href="#Input-and-Output-Functions" accesskey="n" rel="next">Input and Output Functions</a>, Previous: <a href="#Comparison-Functions" accesskey="p" rel="prev">Comparison Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Special-functions"></a>
<a name="Special-Functions-1"></a>
<h3 class="section">5.7 Special Functions</h3>

<p>All those functions, except explicitly stated (for example
<code>mpfr_sin_cos</code>), return a <a href="#ternary-value">ternary value</a>, i.e., zero for an
exact return value, a positive value for a return value larger than the
exact result, and a negative value otherwise.
</p>
<p>Important note: in some domains, computing special functions (even more
with correct rounding) is expensive, even for small precision,
for example the trigonometric and Bessel functions for large argument.
For some functions, the memory usage might depend not only on the output
precision: it is the case of the <code>mpfr_rootn_ui</code> function where the
memory usage is also linear in the argument <var>k</var>,
and of the incomplete Gamma function (dependence on the precision of <var>op</var>).
</p>
<dl>
<dt><a name="index-mpfr_005flog"></a>Function: <em>int</em> <strong>mpfr_log</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005flog_005fui"></a>Function: <em>int</em> <strong>mpfr_log_ui</strong> <em>(mpfr_t <var>rop</var>, unsigned long <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005flog2"></a>Function: <em>int</em> <strong>mpfr_log2</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005flog10"></a>Function: <em>int</em> <strong>mpfr_log10</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the natural logarithm of <var>op</var>,
<em>log2(<var>op</var>)</em> or
<em>log10(<var>op</var>)</em>, respectively,
rounded in the direction <var>rnd</var>.
Set <var>rop</var> to +0 if <var>op</var> is 1 (in all rounding modes),
for consistency with the ISO C99 and IEEE 754-2008 standards.
Set <var>rop</var> to -Inf if <var>op</var> is ±0
(i.e., the sign of the zero has no influence on the result).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005flog1p"></a>Function: <em>int</em> <strong>mpfr_log1p</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the logarithm of one plus <var>op</var>,
rounded in the direction <var>rnd</var>.
Set <var>rop</var> to -Inf if <var>op</var> is -1.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fexp"></a>Function: <em>int</em> <strong>mpfr_exp</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fexp2"></a>Function: <em>int</em> <strong>mpfr_exp2</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fexp10"></a>Function: <em>int</em> <strong>mpfr_exp10</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the exponential of <var>op</var>,
 to <em>2 power of <var>op</var></em>
or to <em>10 power of <var>op</var></em>, respectively,
rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fexpm1"></a>Function: <em>int</em> <strong>mpfr_expm1</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em>the exponential of <var>op</var> followed by a
subtraction by one</em>, rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcos"></a>Function: <em>int</em> <strong>mpfr_cos</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fsin"></a>Function: <em>int</em> <strong>mpfr_sin</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ftan"></a>Function: <em>int</em> <strong>mpfr_tan</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the cosine of <var>op</var>, sine of <var>op</var>,
tangent of <var>op</var>, rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsin_005fcos"></a>Function: <em>int</em> <strong>mpfr_sin_cos</strong> <em>(mpfr_t <var>sop</var>, mpfr_t <var>cop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set simultaneously <var>sop</var> to the sine of <var>op</var> and <var>cop</var> to the
cosine of <var>op</var>, rounded in the direction <var>rnd</var> with the corresponding
precisions of <var>sop</var> and <var>cop</var>, which must be different variables.
Return 0 iff both results are exact, more precisely it returns <em>s+4c</em>
where <em>s=0</em> if <var>sop</var> is exact, <em>s=1</em> if <var>sop</var> is larger
than the sine of <var>op</var>, <em>s=2</em> if <var>sop</var> is smaller than the sine
of <var>op</var>, and similarly for <em>c</em> and the cosine of <var>op</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsec"></a>Function: <em>int</em> <strong>mpfr_sec</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fcsc"></a>Function: <em>int</em> <strong>mpfr_csc</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fcot"></a>Function: <em>int</em> <strong>mpfr_cot</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the secant of <var>op</var>, cosecant of <var>op</var>,
cotangent of <var>op</var>, rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005facos"></a>Function: <em>int</em> <strong>mpfr_acos</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fasin"></a>Function: <em>int</em> <strong>mpfr_asin</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fatan"></a>Function: <em>int</em> <strong>mpfr_atan</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the arc-cosine, arc-sine or arc-tangent of <var>op</var>,
rounded in the direction <var>rnd</var>.
Note that since <code>acos(-1)</code> returns the floating-point number closest to
<em>Pi</em> according to the given rounding mode, this number might not be
in the output range <em>0 &lt;= <var>rop</var> &lt; \pi</em>
of the arc-cosine function;
still, the result lies in the image of the output range
by the rounding function.
The same holds for <code>asin(-1)</code>, <code>asin(1)</code>, <code>atan(-Inf)</code>,
<code>atan(+Inf)</code> or for <code>atan(op)</code> with large <var>op</var> and
small precision of <var>rop</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fatan2"></a>Function: <em>int</em> <strong>mpfr_atan2</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>y</var>, mpfr_t <var>x</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the arc-tangent2 of <var>y</var> and <var>x</var>,
rounded in the direction <var>rnd</var>:
if <code>x &gt; 0</code>, <code>atan2(y, x) = atan(y/x)</code>;
if <code>x &lt; 0</code>, <code>atan2(y, x) = sign(y)*(Pi - atan(abs(y/x)))</code>,
thus a number from <em>-Pi</em> to <em>Pi</em>.
As for <code>atan</code>, in case the exact mathematical result is <em>+Pi</em> or
<em>-Pi</em>,
its rounded result might be outside the function output range.
</p>
<p><code>atan2(y, 0)</code> does not raise any floating-point exception.
Special values are handled as described in the ISO C99 and IEEE 754-2008
standards for the <code>atan2</code> function:
</p><ul>
<li> <code>atan2(+0, -0)</code> returns <em>+Pi</em>.
</li><li> <code>atan2(-0, -0)</code> returns <em>-Pi</em>.
</li><li> <code>atan2(+0, +0)</code> returns +0.
</li><li> <code>atan2(-0, +0)</code> returns -0.
</li><li> <code>atan2(+0, x)</code> returns <em>+Pi</em> for <em>x &lt; 0</em>.
</li><li> <code>atan2(-0, x)</code> returns <em>-Pi</em> for <em>x &lt; 0</em>.
</li><li> <code>atan2(+0, x)</code> returns +0 for <em>x &gt; 0</em>.
</li><li> <code>atan2(-0, x)</code> returns -0 for <em>x &gt; 0</em>.
</li><li> <code>atan2(y, 0)</code> returns <em>-Pi/2</em> for <em>y &lt; 0</em>.
</li><li> <code>atan2(y, 0)</code> returns <em>+Pi/2</em> for <em>y &gt; 0</em>.
</li><li> <code>atan2(+Inf, -Inf)</code> returns <em>+3*Pi/4</em>.
</li><li> <code>atan2(-Inf, -Inf)</code> returns <em>-3*Pi/4</em>.
</li><li> <code>atan2(+Inf, +Inf)</code> returns <em>+Pi/4</em>.
</li><li> <code>atan2(-Inf, +Inf)</code> returns <em>-Pi/4</em>.
</li><li> <code>atan2(+Inf, x)</code> returns <em>+Pi/2</em> for finite <em>x</em>.
</li><li> <code>atan2(-Inf, x)</code> returns <em>-Pi/2</em> for finite <em>x</em>.
</li><li> <code>atan2(y, -Inf)</code> returns <em>+Pi</em> for finite <em>y &gt; 0</em>.
</li><li> <code>atan2(y, -Inf)</code> returns <em>-Pi</em> for finite <em>y &lt; 0</em>.
</li><li> <code>atan2(y, +Inf)</code> returns +0 for finite <em>y &gt; 0</em>.
</li><li> <code>atan2(y, +Inf)</code> returns -0 for finite <em>y &lt; 0</em>.
</li></ul>
</dd></dl>

<dl>
<dt><a name="index-mpfr_005fcosh"></a>Function: <em>int</em> <strong>mpfr_cosh</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fsinh"></a>Function: <em>int</em> <strong>mpfr_sinh</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ftanh"></a>Function: <em>int</em> <strong>mpfr_tanh</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the hyperbolic cosine, sine or tangent of <var>op</var>,
rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsinh_005fcosh"></a>Function: <em>int</em> <strong>mpfr_sinh_cosh</strong> <em>(mpfr_t <var>sop</var>, mpfr_t <var>cop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set simultaneously <var>sop</var> to the hyperbolic sine of <var>op</var> and
<var>cop</var> to the hyperbolic cosine of <var>op</var>,
rounded in the direction <var>rnd</var> with the corresponding precision of
<var>sop</var> and <var>cop</var>, which must be different variables.
Return 0 iff both results are exact (see <code>mpfr_sin_cos</code> for a more
detailed description of the return value).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsech"></a>Function: <em>int</em> <strong>mpfr_sech</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fcsch"></a>Function: <em>int</em> <strong>mpfr_csch</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fcoth"></a>Function: <em>int</em> <strong>mpfr_coth</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the hyperbolic secant of <var>op</var>, cosecant of <var>op</var>,
cotangent of <var>op</var>, rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005facosh"></a>Function: <em>int</em> <strong>mpfr_acosh</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fasinh"></a>Function: <em>int</em> <strong>mpfr_asinh</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fatanh"></a>Function: <em>int</em> <strong>mpfr_atanh</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the inverse hyperbolic cosine, sine or tangent of <var>op</var>,
rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ffac_005fui"></a>Function: <em>int</em> <strong>mpfr_fac_ui</strong> <em>(mpfr_t <var>rop</var>, unsigned long int  <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the factorial of <var>op</var>, rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005feint"></a>Function: <em>int</em> <strong>mpfr_eint</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the exponential integral of <var>op</var>,
rounded in the direction <var>rnd</var>.
This is the sum of Euler&rsquo;s constant, of the logarithm
of the absolute value of <var>op</var>, and of the sum for k from 1 to infinity of
<var>op</var> to the power k, divided by k and factorial(k).
For positive <var>op</var>, it corresponds to the Ei function at <var>op</var>
(see formula 5.1.10 from the Handbook of Mathematical Functions from
Abramowitz and Stegun),
and for negative <var>op</var>, to the opposite of the
E1 function (sometimes called eint1)
at -<var>op</var> (formula 5.1.1 from the same reference).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fli2"></a>Function: <em>int</em> <strong>mpfr_li2</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to real part of the dilogarithm of <var>op</var>, rounded in the
direction <var>rnd</var>. MPFR defines the dilogarithm function as
<em>the integral of -log(1-t)/t from 0
to <var>op</var></em>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fgamma"></a>Function: <em>int</em> <strong>mpfr_gamma</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fgamma_005finc"></a>Function: <em>int</em> <strong>mpfr_gamma_inc</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the Gamma function on <var>op</var>, resp. the
incomplete Gamma function on <var>op</var> and <var>op2</var>,
rounded in the direction <var>rnd</var>.
(In the literature, <code>mpfr_gamma_inc</code> is called upper
incomplete Gamma function,
or sometimes complementary incomplete Gamma function.)
For <code>mpfr_gamma</code> (and <code>mpfr_gamma_inc</code> when <var>op2</var> is zero),
when <var>op</var> is a negative integer, <var>rop</var> is set to NaN.
</p>
<p>Note: the current implementation of <code>mpfr_gamma_inc</code> is slow for
large values of <var>rop</var> or <var>op</var>, in which case some internal overflow
might also occur.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005flngamma"></a>Function: <em>int</em> <strong>mpfr_lngamma</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the logarithm of the Gamma function on <var>op</var>,
rounded in the direction <var>rnd</var>.
When <var>op</var> is 1 or 2, set <var>rop</var> to +0 (in all rounding modes).
When <var>op</var> is an infinity or a nonpositive integer, set <var>rop</var> to +Inf,
following the general rules on special values.
When <em>-2<var>k</var>-1 &lt; <var>op</var> &lt; -2<var>k</var></em>,
<var>k</var> being a nonnegative integer, set <var>rop</var> to NaN.
See also <code>mpfr_lgamma</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005flgamma"></a>Function: <em>int</em> <strong>mpfr_lgamma</strong> <em>(mpfr_t <var>rop</var>, int *<var>signp</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the logarithm of the absolute value of the
Gamma function on <var>op</var>, rounded in the direction <var>rnd</var>. The sign
(1 or -1) of Gamma(<var>op</var>) is returned in the object pointed to
by <var>signp</var>.
When <var>op</var> is 1 or 2, set <var>rop</var> to +0 (in all rounding modes).
When <var>op</var> is an infinity or a nonpositive integer, set <var>rop</var> to +Inf.
When <var>op</var> is NaN, -Inf or a negative integer, *<var>signp</var> is
undefined, and when <var>op</var> is ±0, *<var>signp</var> is the sign of the zero.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fdigamma"></a>Function: <em>int</em> <strong>mpfr_digamma</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the Digamma (sometimes also called Psi)
function on <var>op</var>, rounded in the direction <var>rnd</var>.
When <var>op</var> is a negative integer, set <var>rop</var> to NaN.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fbeta"></a>Function: <em>int</em> <strong>mpfr_beta</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the Beta function at arguments <var>op1</var> and
<var>op2</var>.
Note: the current code does not try to avoid internal overflow or underflow,
and might use a huge internal precision in some cases.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fzeta"></a>Function: <em>int</em> <strong>mpfr_zeta</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fzeta_005fui"></a>Function: <em>int</em> <strong>mpfr_zeta_ui</strong> <em>(mpfr_t <var>rop</var>, unsigned long <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the Riemann Zeta function on <var>op</var>,
rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ferf"></a>Function: <em>int</em> <strong>mpfr_erf</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ferfc"></a>Function: <em>int</em> <strong>mpfr_erfc</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the error function on <var>op</var>
(resp. the complementary error function on <var>op</var>)
rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fj0"></a>Function: <em>int</em> <strong>mpfr_j0</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fj1"></a>Function: <em>int</em> <strong>mpfr_j1</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fjn"></a>Function: <em>int</em> <strong>mpfr_jn</strong> <em>(mpfr_t <var>rop</var>, long <var>n</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the first kind Bessel function of order 0,
(resp. 1 and <var>n</var>)
on <var>op</var>, rounded in the direction <var>rnd</var>. When <var>op</var> is
NaN, <var>rop</var> is always set to NaN. When <var>op</var> is plus or minus Infinity,
<var>rop</var> is set to +0. When <var>op</var> is zero, and <var>n</var> is not zero,
<var>rop</var> is set to +0 or -0 depending on the parity and sign of <var>n</var>,
and the sign of <var>op</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fy0"></a>Function: <em>int</em> <strong>mpfr_y0</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fy1"></a>Function: <em>int</em> <strong>mpfr_y1</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fyn"></a>Function: <em>int</em> <strong>mpfr_yn</strong> <em>(mpfr_t <var>rop</var>, long <var>n</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the second kind Bessel function of order 0
(resp. 1 and <var>n</var>)
on <var>op</var>, rounded in the direction <var>rnd</var>. When <var>op</var> is
NaN or negative, <var>rop</var> is always set to NaN. When <var>op</var> is +Inf,
<var>rop</var> is set to +0. When <var>op</var> is zero, <var>rop</var> is set to +Inf
or -Inf depending on the parity and sign of <var>n</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ffma"></a>Function: <em>int</em> <strong>mpfr_fma</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_t <var>op3</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ffms"></a>Function: <em>int</em> <strong>mpfr_fms</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_t <var>op3</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em>(<var>op1</var> times <var>op2</var>) + <var>op3</var></em>
(resp. <em>(<var>op1</var> times <var>op2</var>) - <var>op3</var></em>)
rounded in the direction <var>rnd</var>.  Concerning special values (signed zeros,
infinities, NaN), these functions behave like a multiplication followed by a
separate addition or subtraction.  That is, the fused operation matters only
for rounding.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ffmma"></a>Function: <em>int</em> <strong>mpfr_fmma</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_t <var>op3</var>, mpfr_t <var>op4</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ffmms"></a>Function: <em>int</em> <strong>mpfr_fmms</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_t <var>op3</var>, mpfr_t <var>op4</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <em>(<var>op1</var> times <var>op2</var>) + (<var>op3</var> times <var>op4</var>)</em>
(resp. <em>(<var>op1</var> times <var>op2</var>) - (<var>op3</var> times <var>op4</var>)</em>)
rounded in the direction <var>rnd</var>.
In case the computation of <em><var>op1</var> times <var>op2</var></em> overflows or
underflows (or that of <em><var>op3</var> times <var>op4</var></em>), the result
<var>rop</var> is computed as if the two intermediate products were computed with
rounding toward zero.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fagm"></a>Function: <em>int</em> <strong>mpfr_agm</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the arithmetic-geometric mean of <var>op1</var> and <var>op2</var>,
rounded in the direction <var>rnd</var>.
The arithmetic-geometric mean is the common limit of the sequences
<em><var>u</var>_<var>n</var></em> and <em><var>v</var>_<var>n</var></em>,
where <em><var>u</var>_<var>0</var></em>=<var>op1</var>, <em><var>v</var>_<var>0</var></em>=<var>op2</var>,
<em><var>u</var>_(<var>n</var>+1)</em> is the
arithmetic mean of <em><var>u</var>_<var>n</var></em> and <em><var>v</var>_<var>n</var></em>,
and <em><var>v</var>_(<var>n</var>+1)</em> is the geometric mean of
<em><var>u</var>_<var>n</var></em> and <em><var>v</var>_<var>n</var></em>.
If any operand is negative and the other one is not zero,
set <var>rop</var> to NaN.
If any operand is zero and the other one is finite (resp. infinite),
set <var>rop</var> to +0 (resp. NaN).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fhypot"></a>Function: <em>int</em> <strong>mpfr_hypot</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>x</var>, mpfr_t <var>y</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the Euclidean norm of <var>x</var> and <var>y</var>,
i.e., the square root of the sum of the squares of <var>x</var> and <var>y</var>,
rounded in the direction <var>rnd</var>.
Special values are handled as described in the ISO C99 (Section F.9.4.3)
and IEEE 754-2008 (Section 9.2.1) standards:
If <var>x</var> or <var>y</var> is an infinity, then +Inf is returned in <var>rop</var>,
even if the other number is NaN.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fai"></a>Function: <em>int</em> <strong>mpfr_ai</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>x</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the Airy function Ai
 on <var>x</var>, rounded in the direction <var>rnd</var>.
When <var>x</var> is
NaN,
<var>rop</var> is always set to NaN. When <var>x</var> is +Inf or -Inf,
<var>rop</var> is +0.
The current implementation is not intended to be used with large arguments.
It works with abs(<var>x</var>) typically smaller than 500. For larger arguments,
other methods should be used and will be implemented in a future version.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fconst_005flog2"></a>Function: <em>int</em> <strong>mpfr_const_log2</strong> <em>(mpfr_t <var>rop</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fconst_005fpi"></a>Function: <em>int</em> <strong>mpfr_const_pi</strong> <em>(mpfr_t <var>rop</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fconst_005feuler"></a>Function: <em>int</em> <strong>mpfr_const_euler</strong> <em>(mpfr_t <var>rop</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fconst_005fcatalan"></a>Function: <em>int</em> <strong>mpfr_const_catalan</strong> <em>(mpfr_t <var>rop</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the logarithm of 2, the value of <em>Pi</em>,
of Euler&rsquo;s constant 0.577&hellip;, of Catalan&rsquo;s constant 0.915&hellip;,
respectively, rounded in the direction
<var>rnd</var>. These functions cache the computed values to avoid other
calculations if a lower or equal precision is requested. To free these caches,
use <code>mpfr_free_cache</code> or <code>mpfr_free_cache2</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ffree_005fcache"></a>Function: <em>void</em> <strong>mpfr_free_cache</strong> <em>(void)</em></dt>
<dd><p>Free all caches and pools used by MPFR internally (thoses local to the
current thread and those shared by all threads).
You should call this function before terminating a thread, even if you did
not call <code>mpfr_const_*</code> functions directly (they could have been called
internally).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ffree_005fcache2"></a>Function: <em>void</em> <strong>mpfr_free_cache2</strong> <em>(mpfr_free_cache_t <var>way</var>)</em></dt>
<dd><p>Free various caches and pools used by MPFR internally,
as specified by <var>way</var>, which is a set of flags:
</p><ul>
<li> those local to the current thread if flag <code>MPFR_FREE_LOCAL_CACHE</code>
is set;
</li><li> those shared by all threads if flag <code>MPFR_FREE_GLOBAL_CACHE</code>
is set.
</li></ul>
<p>The other bits of <var>way</var> are currently ignored and are reserved for
future use; they should be zero.
</p>
<p>Note: <code>mpfr_free_cache2(MPFR_FREE_LOCAL_CACHE|MPFR_FREE_GLOBAL_CACHE)</code>
is currently equivalent to <code>mpfr_free_cache()</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ffree_005fpool"></a>Function: <em>void</em> <strong>mpfr_free_pool</strong> <em>(void)</em></dt>
<dd><p>Free the pools used by MPFR internally.
Note: This function is automatically called after the thread-local caches
are freed (with <code>mpfr_free_cache</code> or <code>mpfr_free_cache2</code>).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fmp_005fmemory_005fcleanup"></a>Function: <em>int</em> <strong>mpfr_mp_memory_cleanup</strong> <em>(void)</em></dt>
<dd><p>This function should be called before calling <code>mp_set_memory_functions</code>.
See <a href="#Memory-Handling">Memory Handling</a>, for more information.
Zero is returned in case of success, non-zero in case of error.
Errors are currently not possible, but checking the return value
is recommended for future compatibility.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsum"></a>Function: <em>int</em> <strong>mpfr_sum</strong> <em>(mpfr_t <var>rop</var>, const mpfr_ptr <var>tab</var>[], unsigned long int <var>n</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the sum of all elements of <var>tab</var>, whose size is <var>n</var>,
correctly rounded in the direction <var>rnd</var>. Warning: for efficiency reasons,
<var>tab</var> is an array of pointers
to <code>mpfr_t</code>, not an array of <code>mpfr_t</code>.
If <var>n</var> = 0, then the result is +0, and if <var>n</var> = 1, then the function
is equivalent to <code>mpfr_set</code>.
For the special exact cases, the result is the same as the one obtained
with a succession of additions (<code>mpfr_add</code>) in infinite precision.
In particular, if the result is an exact zero and <em><var>n</var> &gt;= 1</em>:
</p><ul>
<li> if all the inputs have the same sign (i.e., all +0 or all -0),
then the result has the same sign as the inputs;
</li><li> otherwise, either because all inputs are zeros with at least a +0 and
a -0, or because some inputs are non-zero (but they globally cancel),
the result is +0, except for the <code>MPFR_RNDD</code> rounding mode, where it is
-0.
</li></ul>
</dd></dl>

<hr>
<a name="Input-and-Output-Functions"></a>
<div class="header">
<p>
Next: <a href="#Formatted-Output-Functions" accesskey="n" rel="next">Formatted Output Functions</a>, Previous: <a href="#Special-Functions" accesskey="p" rel="prev">Special Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Float-input-and-output-functions"></a>
<a name="index-Input-functions"></a>
<a name="index-Output-functions"></a>
<a name="index-I_002fO-functions"></a>
<a name="Input-and-Output-Functions-1"></a>
<h3 class="section">5.8 Input and Output Functions</h3>

<p>This section describes functions that perform input from an input/output
stream, and functions that output to an input/output stream.
Passing a null pointer for a <code>stream</code> to any of these functions will make
them read from <code>stdin</code> and write to <code>stdout</code>, respectively.
</p>
<p>When using a function that takes a <code>FILE *</code> argument, you must
include the <code>&lt;stdio.h&gt;</code> standard header before <samp>mpfr.h</samp>,
to allow <samp>mpfr.h</samp> to define prototypes for these functions.
</p>
<dl>
<dt><a name="index-mpfr_005fout_005fstr"></a>Function: <em>size_t</em> <strong>mpfr_out_str</strong> <em>(FILE *<var>stream</var>, int <var>base</var>, size_t <var>n</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Output <var>op</var> on stream <var>stream</var>, as a string of digits in
base <var>base</var>, rounded in the direction <var>rnd</var>.
The base may vary from 2 to 62.  Print <var>n</var> significant digits exactly,
or if <var>n</var> is 0, enough digits so that <var>op</var> can be read back
exactly (see <code>mpfr_get_str</code>).
</p>
<p>In addition to the significant digits, a decimal point (defined by the
current locale) at the right of the
first digit and a trailing exponent in base 10, in the form &lsquo;<samp>eNNN</samp>&rsquo;,
are printed. If <var>base</var> is greater than 10, &lsquo;<samp>@</samp>&rsquo; will be used
instead of &lsquo;<samp>e</samp>&rsquo; as exponent delimiter.
</p>
<p>Return the number of characters written, or if an error occurred, return 0.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005finp_005fstr"></a>Function: <em>size_t</em> <strong>mpfr_inp_str</strong> <em>(mpfr_t <var>rop</var>, FILE *<var>stream</var>, int <var>base</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Input a string in base <var>base</var> from stream <var>stream</var>,
rounded in the direction <var>rnd</var>, and put the
read float in <var>rop</var>.
</p>
<p>This function reads a word (defined as a sequence of characters between
whitespace) and parses it using <code>mpfr_set_str</code>.
See the documentation of <code>mpfr_strtofr</code> for a detailed description
of the valid string formats.
</p>
<p>Return the number of bytes read, or if an error occurred, return 0.
</p></dd></dl>


<dl>
<dt><a name="index-mpfr_005ffpif_005fexport"></a>Function: <em>int</em> <strong>mpfr_fpif_export</strong> <em>(FILE *<var>stream</var>, mpfr_t <var>op</var>)</em></dt>
<dd><p>Export the number <var>op</var> to the stream <var>stream</var> in a floating-point
interchange format.
In particular one can export on a 32-bit computer and import on a 64-bit
computer, or export on a little-endian computer and import on a big-endian
computer.
The precision of <var>op</var> and the sign bit of a NaN are stored too.
Return 0 iff the export was successful.
</p>
<p>Note: this function is experimental and its interface might change in future
versions.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ffpif_005fimport"></a>Function: <em>int</em> <strong>mpfr_fpif_import</strong> <em>(mpfr_t <var>op</var>, FILE *<var>stream</var>)</em></dt>
<dd><p>Import the number <var>op</var> from the stream <var>stream</var> in a floating-point
interchange format (see <code>mpfr_fpif_export</code>).
Note that the precision of <var>op</var> is set to the one read from the stream,
and the sign bit is always retrieved (even for NaN).
If the stored precision is zero or greater than <code>MPFR_PREC_MAX</code>, the
function fails (it returns non-zero) and <var>op</var> is unchanged. If the
function fails for another reason, <var>op</var> is set to NaN and it is
unspecified whether the precision of <var>op</var> has changed to the one
read from the file.
Return 0 iff the import was successful.
</p>
<p>Note: this function is experimental and its interface might change in future
versions.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fdump"></a>Function: <em>void</em> <strong>mpfr_dump</strong> <em>(mpfr_t <var>op</var>)</em></dt>
<dd><p>Output <var>op</var> on <code>stdout</code> in some unspecified format, then a newline
character. This function is mainly for debugging purpose. Thus invalid data
may be supported. Everything that is not specified may change without
breaking the ABI and may depend on the environment.
</p>
<p>The current output format is the following: a minus sign if the sign bit
is set (even for NaN); &lsquo;<samp>@NaN@</samp>&rsquo;, &lsquo;<samp>@Inf@</samp>&rsquo; or &lsquo;<samp>0</samp>&rsquo; if the
argument is NaN, an infinity or zero, respectively; otherwise the remaining
of the output is as follows: &lsquo;<samp>0.</samp>&rsquo; then the <var>p</var> bits of the binary
significand, where <var>p</var> is the precision of the number; if the trailing
bits are not all zeros (which must not occur with valid data), they are
output enclosed by square brackets; the character &lsquo;<samp>E</samp>&rsquo; followed by
the exponent written in base 10; in case of invalid data or out-of-range
exponent, this function outputs three exclamation marks (&lsquo;<samp>!!!</samp>&rsquo;),
followed by flags, followed by three exclamation marks (&lsquo;<samp>!!!</samp>&rsquo;) again.
These flags are: &lsquo;<samp>N</samp>&rsquo; if the most significant bit of the significand
is 0 (i.e., the number is not normalized); &lsquo;<samp>T</samp>&rsquo; if there are non-zero
trailing bits; &lsquo;<samp>U</samp>&rsquo; if this is a UBF number (internal use only);
&lsquo;<samp>&lt;</samp>&rsquo; if the exponent is less than the current minimum exponent;
&lsquo;<samp>&gt;</samp>&rsquo; if the exponent is greater than the current maximum exponent.
</p></dd></dl>

<hr>
<a name="Formatted-Output-Functions"></a>
<div class="header">
<p>
Next: <a href="#Integer-and-Remainder-Related-Functions" accesskey="n" rel="next">Integer and Remainder Related Functions</a>, Previous: <a href="#Input-and-Output-Functions" accesskey="p" rel="prev">Input and Output Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Float-output-functions"></a>
<a name="index-Output-functions-1"></a>
<a name="index-I_002fO-functions-1"></a>
<a name="Formatted-Output-Functions-1"></a>
<h3 class="section">5.9 Formatted Output Functions</h3>

<a name="Requirements"></a>
<h4 class="subsection">5.9.1 Requirements</h4>
<p>The class of <code>mpfr_printf</code> functions provides formatted output in a
similar manner as the standard C <code>printf</code>. These functions are defined
only if your system supports ISO C variadic functions and the corresponding
argument access macros.
</p>
<p>When using any of these functions, you must include the <code>&lt;stdio.h&gt;</code>
standard header before <samp>mpfr.h</samp>, to allow <samp>mpfr.h</samp> to define
prototypes for these functions.
</p>
<a name="Format-String"></a>
<h4 class="subsection">5.9.2 Format String</h4>
<p>The format specification accepted by <code>mpfr_printf</code> is an extension of the
<code>printf</code> one. The conversion specification is of the form:
</p><div class="example">
<pre class="example">% [flags] [width] [.[precision]] [type] [rounding] conv
</pre></div>
<p>&lsquo;<samp>flags</samp>&rsquo;, &lsquo;<samp>width</samp>&rsquo;, and &lsquo;<samp>precision</samp>&rsquo; have the same meaning as for
the standard <code>printf</code> (in particular, notice that the &lsquo;<samp>precision</samp>&rsquo; is
related to the number of digits displayed in the base chosen by &lsquo;<samp>conv</samp>&rsquo;
and not related to the internal precision of the <code>mpfr_t</code> variable), but
note that for &lsquo;<samp>Re</samp>&rsquo;, the default precision is not the same as the one for
&lsquo;<samp>e</samp>&rsquo;.
<code>mpfr_printf</code> accepts the same &lsquo;<samp>type</samp>&rsquo; specifiers as GMP (except the
non-standard and deprecated &lsquo;<samp>q</samp>&rsquo;, use &lsquo;<samp>ll</samp>&rsquo; instead), namely the
length modifiers defined in the C standard:
</p>
<blockquote>
<table>
<tr><td>&lsquo;<samp>h</samp>&rsquo;</td><td><code>short</code></td></tr>
<tr><td>&lsquo;<samp>hh</samp>&rsquo;</td><td><code>char</code></td></tr>
<tr><td>&lsquo;<samp>j</samp>&rsquo;</td><td><code>intmax_t</code> or <code>uintmax_t</code></td></tr>
<tr><td>&lsquo;<samp>l</samp>&rsquo;</td><td><code>long</code> or <code>wchar_t</code></td></tr>
<tr><td>&lsquo;<samp>ll</samp>&rsquo;</td><td><code>long long</code></td></tr>
<tr><td>&lsquo;<samp>L</samp>&rsquo;</td><td><code>long double</code></td></tr>
<tr><td>&lsquo;<samp>t</samp>&rsquo;</td><td><code>ptrdiff_t</code></td></tr>
<tr><td>&lsquo;<samp>z</samp>&rsquo;</td><td><code>size_t</code></td></tr>
</table>
</blockquote>

<p>and the &lsquo;<samp>type</samp>&rsquo; specifiers defined in GMP plus &lsquo;<samp>R</samp>&rsquo; and &lsquo;<samp>P</samp>&rsquo;
specific to MPFR (the second column in the table below shows the type of the
argument read in the argument list and the kind of &lsquo;<samp>conv</samp>&rsquo; specifier to
use after the &lsquo;<samp>type</samp>&rsquo; specifier):
</p>
<blockquote>
<table>
<tr><td>&lsquo;<samp>F</samp>&rsquo;</td><td><code>mpf_t</code>, float conversions</td></tr>
<tr><td>&lsquo;<samp>Q</samp>&rsquo;</td><td><code>mpq_t</code>, integer conversions</td></tr>
<tr><td>&lsquo;<samp>M</samp>&rsquo;</td><td><code>mp_limb_t</code>, integer conversions</td></tr>
<tr><td>&lsquo;<samp>N</samp>&rsquo;</td><td><code>mp_limb_t</code> array, integer conversions</td></tr>
<tr><td>&lsquo;<samp>Z</samp>&rsquo;</td><td><code>mpz_t</code>, integer conversions</td></tr>
<tr><td>&lsquo;<samp>P</samp>&rsquo;</td><td><code>mpfr_prec_t</code>, integer conversions</td></tr>
<tr><td>&lsquo;<samp>R</samp>&rsquo;</td><td><code>mpfr_t</code>, float conversions</td></tr>
</table>
</blockquote>

<p>The &lsquo;<samp>type</samp>&rsquo; specifiers have the same restrictions as those
mentioned in the GMP documentation:
see Section &ldquo;Formatted Output Strings&rdquo; in <cite>GNU MP</cite>.
In particular, the &lsquo;<samp>type</samp>&rsquo; specifiers (except &lsquo;<samp>R</samp>&rsquo; and &lsquo;<samp>P</samp>&rsquo;) are
supported only if they are supported by <code>gmp_printf</code> in your GMP build;
this implies that the standard specifiers, such as &lsquo;<samp>t</samp>&rsquo;, must <em>also</em>
be supported by your C library if you want to use them.
</p>
<p>The &lsquo;<samp>rounding</samp>&rsquo; field is specific to <code>mpfr_t</code> arguments and should
not be used with other types.
</p>
<p>With conversion specification not involving &lsquo;<samp>P</samp>&rsquo; and &lsquo;<samp>R</samp>&rsquo; types,
<code>mpfr_printf</code> behaves exactly as <code>gmp_printf</code>.
</p>
<p>The &lsquo;<samp>P</samp>&rsquo; type specifies that a following &lsquo;<samp>d</samp>&rsquo;, &lsquo;<samp>i</samp>&rsquo;,
&lsquo;<samp>o</samp>&rsquo;, &lsquo;<samp>u</samp>&rsquo;, &lsquo;<samp>x</samp>&rsquo;, or &lsquo;<samp>X</samp>&rsquo; conversion specifier applies
to a <code>mpfr_prec_t</code> argument.
It is needed because the <code>mpfr_prec_t</code> type does not necessarily
correspond to an <code>int</code> or any fixed standard type.
The &lsquo;<samp>precision</samp>&rsquo; field specifies the minimum number of digits to
appear. The default &lsquo;<samp>precision</samp>&rsquo; is 1.
For example:
</p><div class="example">
<pre class="example">mpfr_t x;
mpfr_prec_t p;
mpfr_init (x);
&hellip;
p = mpfr_get_prec (x);
mpfr_printf (&quot;variable x with %Pu bits&quot;, p);
</pre></div>

<p>The &lsquo;<samp>R</samp>&rsquo; type specifies that a following &lsquo;<samp>a</samp>&rsquo;, &lsquo;<samp>A</samp>&rsquo;, &lsquo;<samp>b</samp>&rsquo;,
&lsquo;<samp>e</samp>&rsquo;, &lsquo;<samp>E</samp>&rsquo;, &lsquo;<samp>f</samp>&rsquo;, &lsquo;<samp>F</samp>&rsquo;, &lsquo;<samp>g</samp>&rsquo;, &lsquo;<samp>G</samp>&rsquo;, or &lsquo;<samp>n</samp>&rsquo;
conversion specifier applies to a <code>mpfr_t</code> argument.
The &lsquo;<samp>R</samp>&rsquo; type can be followed by a &lsquo;<samp>rounding</samp>&rsquo; specifier denoted by
one of the following characters:
</p>
<blockquote>
<table>
<tr><td>&lsquo;<samp>U</samp>&rsquo;</td><td>round toward plus infinity</td></tr>
<tr><td>&lsquo;<samp>D</samp>&rsquo;</td><td>round toward minus infinity</td></tr>
<tr><td>&lsquo;<samp>Y</samp>&rsquo;</td><td>round away from zero</td></tr>
<tr><td>&lsquo;<samp>Z</samp>&rsquo;</td><td>round toward zero</td></tr>
<tr><td>&lsquo;<samp>N</samp>&rsquo;</td><td>round to nearest (with ties to even)</td></tr>
<tr><td>&lsquo;<samp>*</samp>&rsquo;</td><td>rounding mode indicated by the <code>mpfr_rnd_t</code> argument
just before the corresponding <code>mpfr_t</code> variable.</td></tr>
</table>
</blockquote>

<p>The default rounding mode is rounding to nearest.
The following three examples are equivalent:
</p><div class="example">
<pre class="example">mpfr_t x;
mpfr_init (x);
&hellip;
mpfr_printf (&quot;%.128Rf&quot;, x);
mpfr_printf (&quot;%.128RNf&quot;, x);
mpfr_printf (&quot;%.128R*f&quot;, MPFR_RNDN, x);
</pre></div>

<p>Note that the rounding away from zero mode is specified with &lsquo;<samp>Y</samp>&rsquo;
because ISO C reserves the &lsquo;<samp>A</samp>&rsquo; specifier for hexadecimal output (see
below).
</p>
<p>The output &lsquo;<samp>conv</samp>&rsquo; specifiers allowed with <code>mpfr_t</code> parameter are:
</p>
<blockquote>
<table>
<tr><td>&lsquo;<samp>a</samp>&rsquo; &lsquo;<samp>A</samp>&rsquo;</td><td>hex float, C99 style</td></tr>
<tr><td>&lsquo;<samp>b</samp>&rsquo;</td><td>binary output</td></tr>
<tr><td>&lsquo;<samp>e</samp>&rsquo; &lsquo;<samp>E</samp>&rsquo;</td><td>scientific-format float</td></tr>
<tr><td>&lsquo;<samp>f</samp>&rsquo; &lsquo;<samp>F</samp>&rsquo;</td><td>fixed-point float</td></tr>
<tr><td>&lsquo;<samp>g</samp>&rsquo; &lsquo;<samp>G</samp>&rsquo;</td><td>fixed-point or scientific float</td></tr>
</table>
</blockquote>

<p>The conversion specifier &lsquo;<samp>b</samp>&rsquo; which displays the argument in binary is
specific to <code>mpfr_t</code> arguments and should not be used with other types.
Other conversion specifiers have the same meaning as for a <code>double</code>
argument.
</p>
<p>In case of non-decimal output, only the significand is written in the
specified base, the exponent is always displayed in decimal.
Special values are always displayed as <code>nan</code>, <code>-inf</code>, and <code>inf</code>
for &lsquo;<samp>a</samp>&rsquo;, &lsquo;<samp>b</samp>&rsquo;, &lsquo;<samp>e</samp>&rsquo;, &lsquo;<samp>f</samp>&rsquo;, and &lsquo;<samp>g</samp>&rsquo; specifiers and
<code>NAN</code>, <code>-INF</code>, and <code>INF</code> for &lsquo;<samp>A</samp>&rsquo;, &lsquo;<samp>E</samp>&rsquo;, &lsquo;<samp>F</samp>&rsquo;, and
&lsquo;<samp>G</samp>&rsquo; specifiers.
</p>
<p>If the &lsquo;<samp>precision</samp>&rsquo; field is not empty, the <code>mpfr_t</code> number is
rounded to the given precision in the direction specified by the rounding
mode.
If the precision is zero with rounding to nearest mode and one of the
following &lsquo;<samp>conv</samp>&rsquo; specifiers: &lsquo;<samp>a</samp>&rsquo;, &lsquo;<samp>A</samp>&rsquo;, &lsquo;<samp>b</samp>&rsquo;, &lsquo;<samp>e</samp>&rsquo;,
&lsquo;<samp>E</samp>&rsquo;, tie case is rounded to even when it lies between two consecutive
values at the
wanted precision which have the same exponent, otherwise, it is rounded away
from zero.
For instance, 85 is displayed as &quot;8e+1&quot; and 95 is displayed as &quot;1e+2&quot; with the
format specification <code>&quot;%.0RNe&quot;</code>.
This also applies when the &lsquo;<samp>g</samp>&rsquo; (resp. &lsquo;<samp>G</samp>&rsquo;) conversion specifier uses
the &lsquo;<samp>e</samp>&rsquo; (resp. &lsquo;<samp>E</samp>&rsquo;) style.
If the precision is set to a value greater than the maximum value for an
<code>int</code>, it will be silently reduced down to <code>INT_MAX</code>.
</p>
<p>If the &lsquo;<samp>precision</samp>&rsquo; field is empty (as in <code>%Re</code> or <code>%.RE</code>) with
&lsquo;<samp>conv</samp>&rsquo; specifier &lsquo;<samp>e</samp>&rsquo; and &lsquo;<samp>E</samp>&rsquo;, the number is displayed with
enough digits so that it can be read back exactly, assuming that the input and
output variables have the same precision and that the input and output
rounding modes are both rounding to nearest (as for <code>mpfr_get_str</code>).
The default precision for an empty &lsquo;<samp>precision</samp>&rsquo; field with &lsquo;<samp>conv</samp>&rsquo;
specifiers &lsquo;<samp>f</samp>&rsquo;, &lsquo;<samp>F</samp>&rsquo;, &lsquo;<samp>g</samp>&rsquo;, and &lsquo;<samp>G</samp>&rsquo; is 6.
</p>

<a name="Functions"></a>
<h4 class="subsection">5.9.3 Functions</h4>

<p>For all the following functions, if the number of characters that ought to be
written exceeds the maximum limit <code>INT_MAX</code> for an <code>int</code>, nothing is
written in the stream (resp. to <code>stdout</code>, to <var>buf</var>, to <var>str</var>),
the function returns -1, sets the <em>erange</em> flag, and <code>errno</code>
is set to <code>EOVERFLOW</code> if the <code>EOVERFLOW</code> macro is defined (such as
on POSIX systems). Note, however, that <code>errno</code> might be changed to
another value by some internal library call if another error occurs there
(currently, this would come from the unallocation function).
</p>
<dl>
<dt><a name="index-mpfr_005ffprintf"></a>Function: <em>int</em> <strong>mpfr_fprintf</strong> <em>(FILE *<var>stream</var>, const char *<var>template</var>, &hellip;)</em></dt>
<dt><a name="index-mpfr_005fvfprintf"></a>Function: <em>int</em> <strong>mpfr_vfprintf</strong> <em>(FILE *<var>stream</var>, const char *<var>template</var>, va_list <var>ap</var>)</em></dt>
<dd><p>Print to the stream <var>stream</var> the optional arguments under the control of
the template string <var>template</var>.
Return the number of characters written or a negative value if an error
occurred.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fprintf"></a>Function: <em>int</em> <strong>mpfr_printf</strong> <em>(const char *<var>template</var>, &hellip;)</em></dt>
<dt><a name="index-mpfr_005fvprintf"></a>Function: <em>int</em> <strong>mpfr_vprintf</strong> <em>(const char *<var>template</var>, va_list <var>ap</var>)</em></dt>
<dd><p>Print to <code>stdout</code> the optional arguments under the control of the
template string <var>template</var>.
Return the number of characters written or a negative value if an error
occurred.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsprintf"></a>Function: <em>int</em> <strong>mpfr_sprintf</strong> <em>(char *<var>buf</var>, const char *<var>template</var>, &hellip;)</em></dt>
<dt><a name="index-mpfr_005fvsprintf"></a>Function: <em>int</em> <strong>mpfr_vsprintf</strong> <em>(char *<var>buf</var>, const char *<var>template</var>, va_list <var>ap</var>)</em></dt>
<dd><p>Form a null-terminated string corresponding to the optional arguments under
the control of the template string <var>template</var>, and print it in
<var>buf</var>. No overlap is permitted between
<var>buf</var> and the other arguments.
Return the number of characters written in the array <var>buf</var>
<em>not counting</em>
the terminating null character or a negative value if an error occurred.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsnprintf"></a>Function: <em>int</em> <strong>mpfr_snprintf</strong> <em>(char *<var>buf</var>, size_t <var>n</var>, const char *<var>template</var>, &hellip;)</em></dt>
<dt><a name="index-mpfr_005fvsnprintf"></a>Function: <em>int</em> <strong>mpfr_vsnprintf</strong> <em>(char *<var>buf</var>, size_t <var>n</var>, const char *<var>template</var>, va_list <var>ap</var>)</em></dt>
<dd><p>Form a null-terminated string corresponding to the optional arguments under
the control of the template string <var>template</var>, and print it in
<var>buf</var>. If <var>n</var> is zero, nothing is
written and <var>buf</var> may be a null pointer, otherwise, the <var>n</var>-1
first characters are written in <var>buf</var> and the <var>n</var>-th is a null character.
Return the number of characters that would have been written had <var>n</var> been
sufficiently large, <em>not counting</em>
the terminating null character, or a negative value if an error occurred.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fasprintf"></a>Function: <em>int</em> <strong>mpfr_asprintf</strong> <em>(char **<var>str</var>, const char *<var>template</var>, &hellip;)</em></dt>
<dt><a name="index-mpfr_005fvasprintf"></a>Function: <em>int</em> <strong>mpfr_vasprintf</strong> <em>(char **<var>str</var>, const char *<var>template</var>, va_list <var>ap</var>)</em></dt>
<dd><p>Write their output as a null terminated string in a block of memory allocated
using the allocation function (see <a href="#Memory-Handling">Memory Handling</a>). A pointer to the
block is stored in
<var>str</var>. The block of memory must be freed using <code>mpfr_free_str</code>.
The return value is the number of characters written in the string, excluding
the null-terminator, or a negative value if an error occurred, in which case
the contents of <var>str</var> are undefined.
</p></dd></dl>

<hr>
<a name="Integer-and-Remainder-Related-Functions"></a>
<div class="header">
<p>
Next: <a href="#Rounding_002dRelated-Functions" accesskey="n" rel="next">Rounding-Related Functions</a>, Previous: <a href="#Formatted-Output-Functions" accesskey="p" rel="prev">Formatted Output Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Integer-related-functions"></a>
<a name="index-Remainder-related-functions"></a>
<a name="Integer-and-Remainder-Related-Functions-1"></a>
<h3 class="section">5.10 Integer and Remainder Related Functions</h3>

<dl>
<dt><a name="index-mpfr_005frint"></a>Function: <em>int</em> <strong>mpfr_rint</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fceil"></a>Function: <em>int</em> <strong>mpfr_ceil</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>)</em></dt>
<dt><a name="index-mpfr_005ffloor"></a>Function: <em>int</em> <strong>mpfr_floor</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>)</em></dt>
<dt><a name="index-mpfr_005fround"></a>Function: <em>int</em> <strong>mpfr_round</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>)</em></dt>
<dt><a name="index-mpfr_005froundeven"></a>Function: <em>int</em> <strong>mpfr_roundeven</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>)</em></dt>
<dt><a name="index-mpfr_005ftrunc"></a>Function: <em>int</em> <strong>mpfr_trunc</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>)</em></dt>
<dd><p>Set <var>rop</var> to <var>op</var> rounded to an integer.
<code>mpfr_rint</code> rounds to the nearest representable integer in the
given direction <var>rnd</var>, and the other five functions behave in a
similar way with some fixed rounding mode:
</p><ul>
<li> <code>mpfr_ceil</code>: to the next higher or equal representable integer
      (like <code>mpfr_rint</code> with <code>MPFR_RNDU</code>);
</li><li> <code>mpfr_floor</code> to the next lower or equal representable integer
      (like <code>mpfr_rint</code> with <code>MPFR_RNDD</code>);
</li><li> <code>mpfr_round</code> to the nearest representable integer,
      rounding halfway cases away from zero
      (as in the roundTiesToAway mode of IEEE 754-2008);
</li><li> <code>mpfr_roundeven</code> to the nearest representable integer,
      rounding halfway cases with the even-rounding rule
      (like <code>mpfr_rint</code> with <code>MPFR_RNDN</code>);
</li><li> <code>mpfr_trunc</code> to the next representable integer toward zero
      (like <code>mpfr_rint</code> with <code>MPFR_RNDZ</code>).
</li></ul>
<p>When <var>op</var> is a zero or an infinity, set <var>rop</var> to the same value
(with the same sign).
</p>
<p>The return value is zero when the result is exact, positive when it is
greater than the original value of <var>op</var>, and negative when it is smaller.
More precisely, the return value is 0 when <var>op</var> is an integer
representable in <var>rop</var>, 1 or -1 when <var>op</var> is an integer
that is not representable in <var>rop</var>, 2 or -2 when <var>op</var> is
not an integer.
</p>
<p>When <var>op</var> is NaN, the NaN flag is set as usual. In the other cases,
the inexact flag is set when <var>rop</var> differs from <var>op</var>, following
the ISO C99 rule for the <code>rint</code> function. If you want the behavior to
be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the
round-to-integer function is regarded as any other mathematical function,
you should use one the <code>mpfr_rint_*</code> functions instead.
</p>
<p>Note that no double rounding is performed; for instance, 10.5 (1010.1 in
binary) is rounded by <code>mpfr_rint</code> with rounding to nearest to 12 (1100
in binary) in 2-bit precision, because the two enclosing numbers representable
on two bits are 8 and 12, and the closest is 12.
(If one first rounded to an integer, one would round 10.5 to 10 with
even rounding, and then 10 would be rounded to 8 again with even rounding.)
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005frint_005fceil"></a>Function: <em>int</em> <strong>mpfr_rint_ceil</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005frint_005ffloor"></a>Function: <em>int</em> <strong>mpfr_rint_floor</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005frint_005fround"></a>Function: <em>int</em> <strong>mpfr_rint_round</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005frint_005froundeven"></a>Function: <em>int</em> <strong>mpfr_rint_roundeven</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005frint_005ftrunc"></a>Function: <em>int</em> <strong>mpfr_rint_trunc</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <var>op</var> rounded to an integer:
</p><ul>
<li> <code>mpfr_rint_ceil</code>: to the next higher or equal integer;
</li><li> <code>mpfr_rint_floor</code>: to the next lower or equal integer;
</li><li> <code>mpfr_rint_round</code>: to the nearest integer,
      rounding halfway cases away from zero;
</li><li> <code>mpfr_rint_roundeven</code>: to the nearest integer,
      rounding halfway cases to the nearest even integer;
</li><li> <code>mpfr_rint_trunc</code> to the next integer toward zero.
</li></ul>
<p>If the result is not representable, it is rounded in the direction <var>rnd</var>.
When <var>op</var> is a zero or an infinity, set <var>rop</var> to the same value
(with the same sign).
The return value is the ternary value associated with the considered
round-to-integer function (regarded in the same way as any other
mathematical function).
</p>
<p>Contrary to <code>mpfr_rint</code>, those functions do perform a double rounding:
first <var>op</var> is rounded to the nearest integer in the direction given by
the function name, then this nearest integer (if not representable) is
rounded in the given direction <var>rnd</var>.  Thus these round-to-integer
functions behave more like the other mathematical functions, i.e., the
returned result is the correct rounding of the exact result of the function
in the real numbers.
</p>
<p>For example, <code>mpfr_rint_round</code> with rounding to nearest and a precision
of two bits rounds 6.5 to 7 (halfway cases away from zero), then 7 is
rounded to 8 by the round-even rule, despite the fact that 6 is also
representable on two bits, and is closer to 6.5 than 8.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ffrac"></a>Function: <em>int</em> <strong>mpfr_frac</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the fractional part of <var>op</var>, having the same sign as
<var>op</var>, rounded in the direction <var>rnd</var> (unlike in <code>mpfr_rint</code>,
<var>rnd</var> affects only how the exact fractional part is rounded, not how
the fractional part is generated).
When <var>op</var> is an integer or an infinity, set <var>rop</var> to zero with
the same sign as <var>op</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fmodf"></a>Function: <em>int</em> <strong>mpfr_modf</strong> <em>(mpfr_t <var>iop</var>, mpfr_t <var>fop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set simultaneously <var>iop</var> to the integral part of <var>op</var> and <var>fop</var> to
the fractional part of <var>op</var>, rounded in the direction <var>rnd</var> with the
corresponding precision of <var>iop</var> and <var>fop</var> (equivalent to
<code>mpfr_trunc(<var>iop</var>, <var>op</var>, <var>rnd</var>)</code> and
<code>mpfr_frac(<var>fop</var>, <var>op</var>, <var>rnd</var>)</code>). The variables <var>iop</var> and
<var>fop</var> must be different. Return 0 iff both results are exact (see
<code>mpfr_sin_cos</code> for a more detailed description of the return value).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ffmod"></a>Function: <em>int</em> <strong>mpfr_fmod</strong> <em>(mpfr_t <var>r</var>, mpfr_t <var>x</var>, mpfr_t <var>y</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005ffmodquo"></a>Function: <em>int</em> <strong>mpfr_fmodquo</strong> <em>(mpfr_t <var>r</var>, long* <var>q</var>, mpfr_t <var>x</var>, mpfr_t <var>y</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fremainder"></a>Function: <em>int</em> <strong>mpfr_remainder</strong> <em>(mpfr_t <var>r</var>, mpfr_t <var>x</var>, mpfr_t <var>y</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fremquo"></a>Function: <em>int</em> <strong>mpfr_remquo</strong> <em>(mpfr_t <var>r</var>, long* <var>q</var>, mpfr_t <var>x</var>, mpfr_t <var>y</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>r</var> to the value of <em><var>x</var> - <var>n</var><var>y</var></em>, rounded
according to the direction <var>rnd</var>, where <var>n</var> is the integer quotient
of <var>x</var> divided by <var>y</var>, defined as follows: <var>n</var> is rounded
toward zero for <code>mpfr_fmod</code> and <code>mpfr_fmodquo</code>,
and to the nearest integer (ties rounded to even) for <code>mpfr_remainder</code>
and <code>mpfr_remquo</code>.
</p>
<p>Special values are handled as described in Section F.9.7.1 of
the ISO C99 standard:
If <var>x</var> is infinite or <var>y</var> is zero, <var>r</var> is NaN.
If <var>y</var> is infinite and <var>x</var> is finite, <var>r</var> is <var>x</var> rounded
to the precision of <var>r</var>.
If <var>r</var> is zero, it has the sign of <var>x</var>.
The return value is the ternary value corresponding to <var>r</var>.
</p>
<p>Additionally, <code>mpfr_fmodquo</code> and <code>mpfr_remquo</code> store
the low significant bits from the quotient <var>n</var> in <var>*q</var>
(more precisely the number of bits in a <code>long</code> minus one),
with the sign of <var>x</var> divided by <var>y</var>
(except if those low bits are all zero, in which case zero is returned).
Note that <var>x</var> may be so large in magnitude relative to <var>y</var> that an
exact representation of the quotient is not practical.
The <code>mpfr_remainder</code> and <code>mpfr_remquo</code> functions are useful for
additive argument reduction.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005finteger_005fp"></a>Function: <em>int</em> <strong>mpfr_integer_p</strong> <em>(mpfr_t <var>op</var>)</em></dt>
<dd><p>Return non-zero iff <var>op</var> is an integer.
</p></dd></dl>

<hr>
<a name="Rounding_002dRelated-Functions"></a>
<div class="header">
<p>
Next: <a href="#Miscellaneous-Functions" accesskey="n" rel="next">Miscellaneous Functions</a>, Previous: <a href="#Integer-and-Remainder-Related-Functions" accesskey="p" rel="prev">Integer and Remainder Related Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Rounding-mode-related-functions"></a>
<a name="Rounding_002dRelated-Functions-1"></a>
<h3 class="section">5.11 Rounding-Related Functions</h3>

<dl>
<dt><a name="index-mpfr_005fset_005fdefault_005frounding_005fmode"></a>Function: <em>void</em> <strong>mpfr_set_default_rounding_mode</strong> <em>(mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set the default rounding mode to <var>rnd</var>.
The default rounding mode is to nearest initially.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005fdefault_005frounding_005fmode"></a>Function: <em>mpfr_rnd_t</em> <strong>mpfr_get_default_rounding_mode</strong> <em>(void)</em></dt>
<dd><p>Get the default rounding mode.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fprec_005fround"></a>Function: <em>int</em> <strong>mpfr_prec_round</strong> <em>(mpfr_t <var>x</var>, mpfr_prec_t <var>prec</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Round <var>x</var> according to <var>rnd</var> with precision <var>prec</var>, which
must be an integer between <code>MPFR_PREC_MIN</code> and <code>MPFR_PREC_MAX</code>
(otherwise the behavior is undefined).
If <var>prec</var> is greater or equal to the precision of <var>x</var>, then new
space is allocated for the significand, and it is filled with zeros.
Otherwise, the significand is rounded to precision <var>prec</var> with the given
direction. In both cases, the precision of <var>x</var> is changed to <var>prec</var>.
</p>
<p>Here is an example of how to use <code>mpfr_prec_round</code> to implement
Newton&rsquo;s algorithm to compute the inverse of <var>a</var>, assuming <var>x</var> is
already an approximation to <var>n</var> bits:
</p><div class="example">
<pre class="example">  mpfr_set_prec (t, 2 * n);
  mpfr_set (t, a, MPFR_RNDN);         /* round a to 2n bits */
  mpfr_mul (t, t, x, MPFR_RNDN);      /* t is correct to 2n bits */
  mpfr_ui_sub (t, 1, t, MPFR_RNDN);   /* high n bits cancel with 1 */
  mpfr_prec_round (t, n, MPFR_RNDN);  /* t is correct to n bits */
  mpfr_mul (t, t, x, MPFR_RNDN);      /* t is correct to n bits */
  mpfr_prec_round (x, 2 * n, MPFR_RNDN); /* exact */
  mpfr_add (x, x, t, MPFR_RNDN);      /* x is correct to 2n bits */
</pre></div>

<p>Warning! You must not use this function if <var>x</var> was initialized
with <code>MPFR_DECL_INIT</code> or with <code>mpfr_custom_init_set</code>
(see <a href="#Custom-Interface">Custom Interface</a>).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcan_005fround"></a>Function: <em>int</em> <strong>mpfr_can_round</strong> <em>(mpfr_t <var>b</var>, mpfr_exp_t <var>err</var>, mpfr_rnd_t <var>rnd1</var>, mpfr_rnd_t <var>rnd2</var>, mpfr_prec_t <var>prec</var>)</em></dt>
<dd><p>Assuming <var>b</var> is an approximation of an unknown number
<var>x</var> in the direction <var>rnd1</var> with error at most two to the power
E(b)-<var>err</var> where E(b) is the exponent of <var>b</var>, return a non-zero
value if one is able to round correctly <var>x</var> to precision <var>prec</var>
with the direction <var>rnd2</var> assuming an unbounded exponent range, and
0 otherwise (including for NaN and Inf).
In other words, if the error on <var>b</var> is bounded by two to the power
<var>k</var> ulps, and <var>b</var> has precision <var>prec</var>,
you should give <var>err</var>=<var>prec</var>-<var>k</var>.
This function <strong>does not modify</strong> its arguments.
</p>
<p>If <var>rnd1</var> is <code>MPFR_RNDN</code> or <code>MPFR_RNDF</code>,
the error is considered to be either
positive or negative, thus the possible range
is twice as large as with a directed rounding for <var>rnd1</var> (with the
same value of <var>err</var>).
</p>
<p>When <var>rnd2</var> is <code>MPFR_RNDF</code>, let <var>rnd3</var> be the opposite direction
if <var>rnd1</var> is a directed rounding, and <code>MPFR_RNDN</code>
if <var>rnd1</var> is <code>MPFR_RNDN</code> or <code>MPFR_RNDF</code>.
The returned value of <code>mpfr_can_round (b, err, rnd1, MPFR_RNDF, prec)</code>
is non-zero iff after
the call <code>mpfr_set (y, b, rnd3)</code> with <var>y</var> of precision <var>prec</var>,
<var>y</var> is guaranteed to be a faithful rounding of <var>x</var>.
</p>
<p>Note: The <a href="#ternary-value">ternary value</a> cannot be determined in general with this
function. However, if it is known that the exact value is not exactly
representable in precision <var>prec</var>, then one can use the following
trick to determine the (non-zero) ternary value in any rounding mode
<var>rnd2</var> (note that <code>MPFR_RNDZ</code> below can be replaced by any
directed rounding mode):
</p><div class="example">
<pre class="example">if (mpfr_can_round (b, err, MPFR_RNDN, MPFR_RNDZ,
                    prec + (rnd2 == MPFR_RNDN)))
  {
    /* round the approximation 'b' to the result 'r' of 'prec' bits
       with rounding mode 'rnd2' and get the ternary value 'inex' */
    inex = mpfr_set (r, b, rnd2);
  }
</pre></div>
<p>Indeed, if <var>rnd2</var> is <code>MPFR_RNDN</code>, this will check if one can
round to <var>prec</var>+1 bits with a directed rounding:
if so, one can surely round to nearest to <var>prec</var> bits,
and in addition one can determine the correct ternary value, which would not
be the case when <var>b</var> is near from a value exactly representable on
<var>prec</var> bits.
</p>
<p>A detailed example is available in the <samp>examples</samp> subdirectory,
file <samp>can_round.c</samp>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fmin_005fprec"></a>Function: <em>mpfr_prec_t</em> <strong>mpfr_min_prec</strong> <em>(mpfr_t <var>x</var>)</em></dt>
<dd><p>Return the minimal number of bits required to store the significand of
<var>x</var>, and 0 for special values, including 0.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fprint_005frnd_005fmode"></a>Function: <em>const char *</em> <strong>mpfr_print_rnd_mode</strong> <em>(mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Return a string (&quot;MPFR_RNDD&quot;, &quot;MPFR_RNDU&quot;, &quot;MPFR_RNDN&quot;, &quot;MPFR_RNDZ&quot;,
&quot;MPFR_RNDA&quot;) corresponding to the rounding mode <var>rnd</var>, or a null pointer
if <var>rnd</var> is an invalid rounding mode.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fround_005fnearest_005faway"></a>Macro: <em>int</em> <strong>mpfr_round_nearest_away</strong> <em>(int (<var>foo</var>)(mpfr_t, type1_t, ..., mpfr_rnd_t), mpfr_t <var>rop</var>, type1_t <var>op</var>, ...)</em></dt>
<dd><p>Given a function <var>foo</var> and one or more values <var>op</var> (which may be
a <code>mpfr_t</code>, a <code>long</code>, a <code>double</code>, etc.), put in <var>rop</var>
the round-to-nearest-away rounding of <code><var>foo</var>(<var>op</var>,...)</code>.
This rounding is defined in the same way as round-to-nearest-even,
except in case of tie, where the value away from zero is returned.
The function <var>foo</var> takes as input, from second to
penultimate argument(s), the argument list given after <var>rop</var>,
a rounding mode as final argument,
puts in its first argument the value <code><var>foo</var>(<var>op</var>,...)</code> rounded
according to this rounding mode, and returns the corresponding ternary value
(which is expected to be correct, otherwise <code>mpfr_round_nearest_away</code>
will not work as desired).
Due to implementation constraints, this function must not be called when
the minimal exponent <code>emin</code> is the smallest possible one.
This macro has been made such that the compiler is able to detect
mismatch between the argument list <var>op</var>
and the function prototype of <var>foo</var>.
Multiple input arguments <var>op</var> are supported only with C99 compilers.
Otherwise, for C89 compilers, only one such argument is supported.
</p>
<p>Note: this macro is experimental and its interface might change in future
versions.
</p><div class="example">
<pre class="example">unsigned long ul;
mpfr_t f, r;
/* Code that inits and sets r, f, and ul, and if needed sets emin */
int i = mpfr_round_nearest_away (mpfr_add_ui, r, f, ul);
</pre></div>
</dd></dl>

<hr>
<a name="Miscellaneous-Functions"></a>
<div class="header">
<p>
Next: <a href="#Exception-Related-Functions" accesskey="n" rel="next">Exception Related Functions</a>, Previous: <a href="#Rounding_002dRelated-Functions" accesskey="p" rel="prev">Rounding-Related Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Miscellaneous-float-functions"></a>
<a name="Miscellaneous-Functions-1"></a>
<h3 class="section">5.12 Miscellaneous Functions</h3>

<dl>
<dt><a name="index-mpfr_005fnexttoward"></a>Function: <em>void</em> <strong>mpfr_nexttoward</strong> <em>(mpfr_t <var>x</var>, mpfr_t <var>y</var>)</em></dt>
<dd><p>If <var>x</var> or <var>y</var> is NaN, set <var>x</var> to NaN; note that the NaN flag
is set as usual.
If <var>x</var> and <var>y</var> are equal, <var>x</var> is unchanged.
Otherwise, if <var>x</var> is different from <var>y</var>, replace <var>x</var> by the
next floating-point number (with the precision of <var>x</var> and the current
exponent range) in the direction of <var>y</var>
(the infinite values are seen as the smallest and largest floating-point
numbers). If the result is zero, it keeps the same sign. No underflow,
overflow, or inexact exception is raised.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fnextabove"></a>Function: <em>void</em> <strong>mpfr_nextabove</strong> <em>(mpfr_t <var>x</var>)</em></dt>
<dt><a name="index-mpfr_005fnextbelow"></a>Function: <em>void</em> <strong>mpfr_nextbelow</strong> <em>(mpfr_t <var>x</var>)</em></dt>
<dd><p>Equivalent to <code>mpfr_nexttoward</code> where <var>y</var> is plus infinity
(resp. minus infinity).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fmin"></a>Function: <em>int</em> <strong>mpfr_min</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fmax"></a>Function: <em>int</em> <strong>mpfr_max</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the minimum (resp. maximum)
of <var>op1</var> and <var>op2</var>. If <var>op1</var>
and <var>op2</var> are both NaN, then <var>rop</var> is set to NaN. If <var>op1</var>
or <var>op2</var> is NaN, then <var>rop</var> is set to the numeric value. If
<var>op1</var> and <var>op2</var> are zeros of different signs, then <var>rop</var>
is set to -0 (resp. +0).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005furandomb"></a>Function: <em>int</em> <strong>mpfr_urandomb</strong> <em>(mpfr_t <var>rop</var>, gmp_randstate_t <var>state</var>)</em></dt>
<dd><p>Generate a uniformly distributed random float in the interval
<em>0 &lt;= <var>rop</var> &lt; 1</em>. More precisely, the number can be seen as a
float with a random non-normalized significand and exponent 0, which is then
normalized (thus if <var>e</var> denotes the exponent after normalization, then
the least <em>-<var>e</var></em> significant bits of the significand are always 0).
</p>
<p>Return 0, unless the exponent is not in the current exponent range, in
which case <var>rop</var> is set to NaN and a non-zero value is returned (this
should never happen in practice, except in very specific cases). The
second argument is a <code>gmp_randstate_t</code> structure which should be
created using the GMP <code>gmp_randinit</code> function (see the GMP manual).
</p>
<p>Note: for a given version of MPFR, the returned value of <var>rop</var> and the
new value of <var>state</var> (which controls further random values) do not depend
on the machine word size.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005furandom"></a>Function: <em>int</em> <strong>mpfr_urandom</strong> <em>(mpfr_t <var>rop</var>, gmp_randstate_t <var>state</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Generate a uniformly distributed random float.
The floating-point number <var>rop</var> can be seen as if a random real number is
generated according to the continuous uniform distribution on the interval
[0, 1] and then rounded in the direction <var>rnd</var>.
</p>
<p>The second argument is a <code>gmp_randstate_t</code> structure which should be
created using the GMP <code>gmp_randinit</code> function (see the GMP manual).
</p>
<p>Note: the note for <code>mpfr_urandomb</code> holds too. Moreover, the exact number
(the random value to be rounded) and the next random state do not depend on
the current exponent range and the rounding mode. However, they depend on
the target precision: from the same state of the random generator, if the
precision of the destination is changed, then the value may be completely
different (and the state of the random generator is different too).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fnrandom"></a>Function: <em>int</em> <strong>mpfr_nrandom</strong> <em>(mpfr_t <var>rop1</var>, gmp_randstate_t <var>state</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fgrandom"></a>Function: <em>int</em> <strong>mpfr_grandom</strong> <em>(mpfr_t <var>rop1</var>, mpfr_t <var>rop2</var>, gmp_randstate_t <var>state</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Generate one (possibly two for <code>mpfr_grandom</code>) random floating-point
number according to a standard normal Gaussian distribution (with mean zero
and variance one). For <code>mpfr_grandom</code>, if <var>rop2</var> is a null pointer,
then only one value is generated and stored in <var>rop1</var>.
</p>
<p>The floating-point number <var>rop1</var> (and <var>rop2</var>) can be seen as if a
random real number were generated according to the standard normal Gaussian
distribution and then rounded in the direction <var>rnd</var>.
</p>
<p>The <code>gmp_randstate_t</code> argument should be
created using the GMP <code>gmp_randinit</code> function (see the GMP manual).
</p>
<p>For <code>mpfr_grandom</code>,
the combination of the ternary values is returned like with
<code>mpfr_sin_cos</code>. If <var>rop2</var> is a null pointer, the second ternary
value is assumed to be 0 (note that the encoding of the only ternary value
is not the same as the usual encoding for functions that return only one
result). Otherwise the ternary value of a random number is always non-zero.
</p>
<p>Note: the note for <code>mpfr_urandomb</code> holds too. In addition, the exponent
range and the rounding mode might have a side effect on the next random state.
</p>
<p>Note: <code>mpfr_nrandom</code> is much more efficient than <code>mpfr_grandom</code>,
especially for large precision. Thus <code>mpfr_grandom</code> is marked as
deprecated and will be removed in a future release.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005ferandom"></a>Function: <em>int</em> <strong>mpfr_erandom</strong> <em>(mpfr_t <var>rop1</var>, gmp_randstate_t <var>state</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Generate one random floating-point number according to an exponential
distribution, with mean one.
Other characteristics are identical to <code>mpfr_nrandom</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005fexp"></a>Function: <em>mpfr_exp_t</em> <strong>mpfr_get_exp</strong> <em>(mpfr_t <var>x</var>)</em></dt>
<dd><p>Return the exponent of <var>x</var>, assuming that <var>x</var> is a non-zero ordinary
number and the significand is considered in [1/2,1). For this function,
<var>x</var> is allowed to be outside of the current range of acceptable values.
The behavior for NaN, infinity or zero is undefined.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fset_005fexp"></a>Function: <em>int</em> <strong>mpfr_set_exp</strong> <em>(mpfr_t <var>x</var>, mpfr_exp_t <var>e</var>)</em></dt>
<dd><p>Set the exponent of <var>x</var> to <var>e</var> if <var>x</var> is a non-zero ordinary
number and <var>e</var> is in the current exponent range, and return 0;
otherwise, return a non-zero value (<var>x</var> is not changed).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsignbit"></a>Function: <em>int</em> <strong>mpfr_signbit</strong> <em>(mpfr_t <var>op</var>)</em></dt>
<dd><p>Return a non-zero value iff <var>op</var> has its sign bit set (i.e., if it is
negative, -0, or a NaN whose representation has its sign bit set).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsetsign"></a>Function: <em>int</em> <strong>mpfr_setsign</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, int <var>s</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set the value of <var>rop</var> from <var>op</var>, rounded toward the given
direction <var>rnd</var>, then set (resp. clear) its sign bit if <var>s</var>
is non-zero (resp. zero), even when <var>op</var> is a NaN.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcopysign"></a>Function: <em>int</em> <strong>mpfr_copysign</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set the value of <var>rop</var> from <var>op1</var>, rounded toward the given
direction <var>rnd</var>, then set its sign bit to that of <var>op2</var> (even
when <var>op1</var> or <var>op2</var> is a NaN). This function is equivalent to
<code>mpfr_setsign (<var>rop</var>, <var>op1</var>, mpfr_signbit (<var>op2</var>), <var>rnd</var>)</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005fversion"></a>Function: <em>const char *</em> <strong>mpfr_get_version</strong> <em>(void)</em></dt>
<dd><p>Return the MPFR version, as a null-terminated string.
</p></dd></dl>

<dl>
<dt><a name="index-MPFR_005fVERSION"></a>Macro: <strong>MPFR_VERSION</strong></dt>
<dt><a name="index-MPFR_005fVERSION_005fMAJOR"></a>Macro: <strong>MPFR_VERSION_MAJOR</strong></dt>
<dt><a name="index-MPFR_005fVERSION_005fMINOR"></a>Macro: <strong>MPFR_VERSION_MINOR</strong></dt>
<dt><a name="index-MPFR_005fVERSION_005fPATCHLEVEL"></a>Macro: <strong>MPFR_VERSION_PATCHLEVEL</strong></dt>
<dt><a name="index-MPFR_005fVERSION_005fSTRING"></a>Macro: <strong>MPFR_VERSION_STRING</strong></dt>
<dd><p><code>MPFR_VERSION</code> is the version of MPFR as a preprocessing constant.
<code>MPFR_VERSION_MAJOR</code>, <code>MPFR_VERSION_MINOR</code> and
<code>MPFR_VERSION_PATCHLEVEL</code> are respectively the major, minor and patch
level of MPFR version, as preprocessing constants.
<code>MPFR_VERSION_STRING</code> is the version (with an optional suffix, used
in development and pre-release versions) as a string constant, which can
be compared to the result of <code>mpfr_get_version</code> to check at run time
the header file and library used match:
</p><div class="example">
<pre class="example">if (strcmp (mpfr_get_version (), MPFR_VERSION_STRING))
  fprintf (stderr, &quot;Warning: header and library do not match\n&quot;);
</pre></div>
<p>Note: Obtaining different strings is not necessarily an error, as
in general, a program compiled with some old MPFR version can be
dynamically linked with a newer MPFR library version (if allowed
by the library versioning system).
</p></dd></dl>

<dl>
<dt><a name="index-MPFR_005fVERSION_005fNUM"></a>Macro: <em>long</em> <strong>MPFR_VERSION_NUM</strong> <em>(<var>major</var>, <var>minor</var>, <var>patchlevel</var>)</em></dt>
<dd><p>Create an integer in the same format as used by <code>MPFR_VERSION</code> from the
given <var>major</var>, <var>minor</var> and <var>patchlevel</var>.
Here is an example of how to check the MPFR version at compile time:
</p><div class="example">
<pre class="example">#if (!defined(MPFR_VERSION) || (MPFR_VERSION&lt;MPFR_VERSION_NUM(3,0,0)))
# error &quot;Wrong MPFR version.&quot;
#endif
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005fpatches"></a>Function: <em>const char *</em> <strong>mpfr_get_patches</strong> <em>(void)</em></dt>
<dd><p>Return a null-terminated string containing the ids of the patches applied to
the MPFR library (contents of the <samp>PATCHES</samp> file), separated by spaces.
Note: If the program has been compiled with an older MPFR version and is
dynamically linked with a new MPFR library version, the identifiers of the
patches applied to the old (compile-time) MPFR version are not available
(however this information should not have much interest in general).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fbuildopt_005ftls_005fp"></a>Function: <em>int</em> <strong>mpfr_buildopt_tls_p</strong> <em>(void)</em></dt>
<dd><p>Return a non-zero value if MPFR was compiled as thread safe using
compiler-level Thread Local Storage (that is, MPFR was built with the
&lsquo;<samp>--enable-thread-safe</samp>&rsquo; configure option, see <code>INSTALL</code> file),
return zero otherwise.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fbuildopt_005ffloat128_005fp"></a>Function: <em>int</em> <strong>mpfr_buildopt_float128_p</strong> <em>(void)</em></dt>
<dd><p>Return a non-zero value if MPFR was compiled with &lsquo;<samp>__float128</samp>&rsquo; support
(that is, MPFR was built with the &lsquo;<samp>--enable-float128</samp>&rsquo; configure option),
return zero otherwise.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fbuildopt_005fdecimal_005fp"></a>Function: <em>int</em> <strong>mpfr_buildopt_decimal_p</strong> <em>(void)</em></dt>
<dd><p>Return a non-zero value if MPFR was compiled with decimal float support (that
is, MPFR was built with the &lsquo;<samp>--enable-decimal-float</samp>&rsquo; configure option),
return zero otherwise.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fbuildopt_005fgmpinternals_005fp"></a>Function: <em>int</em> <strong>mpfr_buildopt_gmpinternals_p</strong> <em>(void)</em></dt>
<dd><p>Return a non-zero value if MPFR was compiled with GMP internals
(that is, MPFR was built with either &lsquo;<samp>--with-gmp-build</samp>&rsquo; or
&lsquo;<samp>--enable-gmp-internals</samp>&rsquo; configure option), return zero otherwise.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fbuildopt_005fsharedcache_005fp"></a>Function: <em>int</em> <strong>mpfr_buildopt_sharedcache_p</strong> <em>(void)</em></dt>
<dd><p>Return a non-zero value if MPFR was compiled so that all threads share
the same cache for one MPFR constant, like <code>mpfr_const_pi</code> or
<code>mpfr_const_log2</code> (that is, MPFR was built with the
&lsquo;<samp>--enable-shared-cache</samp>&rsquo; configure option), return zero otherwise.
If the return value is non-zero, MPFR applications may need to be compiled
with the &lsquo;<samp>-pthread</samp>&rsquo; option.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fbuildopt_005ftune_005fcase"></a>Function: <em>const char *</em> <strong>mpfr_buildopt_tune_case</strong> <em>(void)</em></dt>
<dd><p>Return a string saying which thresholds file has been used at compile time.
This file is normally selected from the processor type.
</p></dd></dl>

<hr>
<a name="Exception-Related-Functions"></a>
<div class="header">
<p>
Next: <a href="#Compatibility-with-MPF" accesskey="n" rel="next">Compatibility with MPF</a>, Previous: <a href="#Miscellaneous-Functions" accesskey="p" rel="prev">Miscellaneous Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Exception-related-functions"></a>
<a name="Exception-Related-Functions-1"></a>
<h3 class="section">5.13 Exception Related Functions</h3>

<dl>
<dt><a name="index-mpfr_005fget_005femin"></a>Function: <em>mpfr_exp_t</em> <strong>mpfr_get_emin</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fget_005femax"></a>Function: <em>mpfr_exp_t</em> <strong>mpfr_get_emax</strong> <em>(void)</em></dt>
<dd><p>Return the (current) smallest and largest exponents allowed for a
floating-point variable. The smallest positive value of a floating-point
variable is <em>one half times 2 raised to the
smallest exponent</em> and the largest value has the form <em>(1 - epsilon) times 2 raised to the largest exponent</em>,
where <em>epsilon</em> depends on the precision of the considered
variable.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fset_005femin"></a>Function: <em>int</em> <strong>mpfr_set_emin</strong> <em>(mpfr_exp_t <var>exp</var>)</em></dt>
<dt><a name="index-mpfr_005fset_005femax"></a>Function: <em>int</em> <strong>mpfr_set_emax</strong> <em>(mpfr_exp_t <var>exp</var>)</em></dt>
<dd><p>Set the smallest and largest exponents allowed for a floating-point variable.
Return a non-zero value when <var>exp</var> is not in the range accepted by the
implementation (in that case the smallest or largest exponent is not changed),
and zero otherwise.
</p>
<p>For the subsequent operations, it is the user&rsquo;s responsibility to check
that any floating-point value used as an input is in the new exponent range
(for example using <code>mpfr_check_range</code>). If a floating-point value
outside the new exponent range is used as an input, the default behavior
is undefined, in the sense of the ISO C standard; the behavior may also be
explicitly documented, such as for <code>mpfr_check_range</code>.
</p>
<p>Note: Caches may still have values outside the current exponent range.
This is not an issue as the user cannot use these caches directly via
the API (MPFR extends the exponent range internally when need be).
</p>
<p>If <em><code>emin</code> &gt; <code>emax</code></em> and a floating-point value needs to
be produced as output, the behavior is undefined (<code>mpfr_set_emin</code>
and <code>mpfr_set_emax</code> do not check this condition as it might occur
between successive calls to these two functions).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fget_005femin_005fmin"></a>Function: <em>mpfr_exp_t</em> <strong>mpfr_get_emin_min</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fget_005femin_005fmax"></a>Function: <em>mpfr_exp_t</em> <strong>mpfr_get_emin_max</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fget_005femax_005fmin"></a>Function: <em>mpfr_exp_t</em> <strong>mpfr_get_emax_min</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fget_005femax_005fmax"></a>Function: <em>mpfr_exp_t</em> <strong>mpfr_get_emax_max</strong> <em>(void)</em></dt>
<dd><p>Return the minimum and maximum of the exponents
allowed for <code>mpfr_set_emin</code> and <code>mpfr_set_emax</code> respectively.
These values are implementation dependent, thus a program using
<code>mpfr_set_emax(mpfr_get_emax_max())</code>
or <code>mpfr_set_emin(mpfr_get_emin_min())</code> may not be portable.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcheck_005frange"></a>Function: <em>int</em> <strong>mpfr_check_range</strong> <em>(mpfr_t <var>x</var>, int <var>t</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>This function assumes that <var>x</var> is the correctly rounded value of some
real value <var>y</var> in the direction <var>rnd</var> and some extended exponent
range, and that <var>t</var> is the corresponding <a href="#ternary-value">ternary value</a>.
For example, one performed <code>t = mpfr_log (x, u, rnd)</code>, and <var>y</var> is the
exact logarithm of <var>u</var>.
Thus <var>t</var> is negative if <var>x</var> is smaller than <var>y</var>,
positive if <var>x</var> is larger than <var>y</var>, and zero if <var>x</var> equals <var>y</var>.
This function modifies <var>x</var> if needed
to be in the current range of acceptable values: It
generates an underflow or an overflow if the exponent of <var>x</var> is
outside the current allowed range; the value of <var>t</var> may be used
to avoid a double rounding. This function returns zero if the new value of
<var>x</var> equals the exact one <var>y</var>, a positive value if that new value
is larger than <var>y</var>, and a negative value if it is smaller than <var>y</var>.
Note that unlike most functions,
the new result <var>x</var> is compared to the (unknown) exact one <var>y</var>,
not the input value <var>x</var>, i.e., the ternary value is propagated.
</p>
<p>Note: If <var>x</var> is an infinity and <var>t</var> is different from zero (i.e.,
if the rounded result is an inexact infinity), then the overflow flag is
set. This is useful because <code>mpfr_check_range</code> is typically called
(at least in MPFR functions) after restoring the flags that could have
been set due to internal computations.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fsubnormalize"></a>Function: <em>int</em> <strong>mpfr_subnormalize</strong> <em>(mpfr_t <var>x</var>, int <var>t</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>This function rounds <var>x</var> emulating subnormal number arithmetic:
if <var>x</var> is outside the subnormal exponent range of the emulated
floating-point system, this function just propagates the
<a href="#ternary-value">ternary value</a> <var>t</var>; otherwise, it rounds <var>x</var> to precision
<code>EXP(x)-emin+1</code> according to rounding mode <var>rnd</var> and previous
ternary value <var>t</var>, avoiding double rounding problems.
More precisely in the subnormal domain, denoting by <var>e</var> the value of
<code>emin</code>, <var>x</var> is rounded in fixed-point
arithmetic to an integer multiple of <em>two to the power
<var>e</var>-1</em>; as a consequence, <em>1.5 multiplied by two to the power <var>e</var>-1</em> when <var>t</var> is zero
is rounded to <em>two to the power <var>e</var></em> with rounding to nearest.
</p>
<p><code>PREC(x)</code> is not modified by this function.
<var>rnd</var> and <var>t</var> must be the rounding mode
and the returned ternary value used when computing <var>x</var>
(as in <code>mpfr_check_range</code>).
The subnormal exponent range is from <code>emin</code> to <code>emin+PREC(x)-1</code>.
If the result cannot be represented in the current exponent range of MPFR
(due to a too small <code>emax</code>), the behavior is undefined.
Note that unlike most functions, the result is compared to the exact one,
not the input value <var>x</var>, i.e., the ternary value is propagated.
</p>
<p>As usual, if the returned ternary value is non zero, the inexact flag is set.
Moreover, if a second rounding occurred (because the input <var>x</var> was in the
subnormal range), the underflow flag is set.
</p>
<p>Warning! If you change <code>emin</code> (with <code>mpfr_set_emin</code>) just before
calling <code>mpfr_subnormalize</code>, you need to make sure that the value is
in the current exponent range of MPFR. But it is better to change
<code>emin</code> before any computation, if possible.
</p></dd></dl>

<p>This is an example of how to emulate binary double IEEE 754 arithmetic
(binary64 in IEEE 754-2008) using MPFR:
</p>
<div class="example">
<pre class="example">{
  mpfr_t xa, xb; int i; volatile double a, b;

  mpfr_set_default_prec (53);
  mpfr_set_emin (-1073); mpfr_set_emax (1024);

  mpfr_init (xa); mpfr_init (xb);

  b = 34.3; mpfr_set_d (xb, b, MPFR_RNDN);
  a = 0x1.1235P-1021; mpfr_set_d (xa, a, MPFR_RNDN);

  a /= b;
  i = mpfr_div (xa, xa, xb, MPFR_RNDN);
  i = mpfr_subnormalize (xa, i, MPFR_RNDN); /* new ternary value */

  mpfr_clear (xa); mpfr_clear (xb);
}
</pre></div>

<p>Note that <code>mpfr_set_emin</code> and <code>mpfr_set_emax</code> are called early
enough in order to make sure that all computed values are in the current
exponent range.
Warning! This emulates a double IEEE 754 arithmetic with correct rounding
in the subnormal range, which may not be the case for your hardware.
</p>
<p>Below is another example showing how to emulate fixed-point arithmetic
in a specific case.
Here we compute the sine of the integers 1 to 17 with a result in a
fixed-point arithmetic rounded at <em>2 power -42</em> (using the
fact that the result is at most 1 in absolute value):
</p>
<div class="example">
<pre class="example">{
  mpfr_t x; int i, inex;

  mpfr_set_emin (-41);
  mpfr_init2 (x, 42);
  for (i = 1; i &lt;= 17; i++)
    {
      mpfr_set_ui (x, i, MPFR_RNDN);
      inex = mpfr_sin (x, x, MPFR_RNDZ);
      mpfr_subnormalize (x, inex, MPFR_RNDZ);
      mpfr_dump (x);
    }
  mpfr_clear (x);
}
</pre></div>

<dl>
<dt><a name="index-mpfr_005fclear_005funderflow"></a>Function: <em>void</em> <strong>mpfr_clear_underflow</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fclear_005foverflow"></a>Function: <em>void</em> <strong>mpfr_clear_overflow</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fclear_005fdivby0"></a>Function: <em>void</em> <strong>mpfr_clear_divby0</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fclear_005fnanflag"></a>Function: <em>void</em> <strong>mpfr_clear_nanflag</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fclear_005finexflag"></a>Function: <em>void</em> <strong>mpfr_clear_inexflag</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fclear_005ferangeflag"></a>Function: <em>void</em> <strong>mpfr_clear_erangeflag</strong> <em>(void)</em></dt>
<dd><p>Clear (lower) the underflow, overflow, divide-by-zero, invalid,
inexact and <em>erange</em> flags.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fclear_005fflags"></a>Function: <em>void</em> <strong>mpfr_clear_flags</strong> <em>(void)</em></dt>
<dd><p>Clear (lower) all global flags (underflow, overflow, divide-by-zero, invalid,
inexact, <em>erange</em>). Note: a group of flags can be cleared by using
<code>mpfr_flags_clear</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fset_005funderflow"></a>Function: <em>void</em> <strong>mpfr_set_underflow</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fset_005foverflow"></a>Function: <em>void</em> <strong>mpfr_set_overflow</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fset_005fdivby0"></a>Function: <em>void</em> <strong>mpfr_set_divby0</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fset_005fnanflag"></a>Function: <em>void</em> <strong>mpfr_set_nanflag</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fset_005finexflag"></a>Function: <em>void</em> <strong>mpfr_set_inexflag</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fset_005ferangeflag"></a>Function: <em>void</em> <strong>mpfr_set_erangeflag</strong> <em>(void)</em></dt>
<dd><p>Set (raise) the underflow, overflow, divide-by-zero, invalid,
inexact and <em>erange</em> flags.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005funderflow_005fp"></a>Function: <em>int</em> <strong>mpfr_underflow_p</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005foverflow_005fp"></a>Function: <em>int</em> <strong>mpfr_overflow_p</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fdivby0_005fp"></a>Function: <em>int</em> <strong>mpfr_divby0_p</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005fnanflag_005fp"></a>Function: <em>int</em> <strong>mpfr_nanflag_p</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005finexflag_005fp"></a>Function: <em>int</em> <strong>mpfr_inexflag_p</strong> <em>(void)</em></dt>
<dt><a name="index-mpfr_005ferangeflag_005fp"></a>Function: <em>int</em> <strong>mpfr_erangeflag_p</strong> <em>(void)</em></dt>
<dd><p>Return the corresponding (underflow, overflow, divide-by-zero, invalid,
inexact, <em>erange</em>) flag, which is non-zero iff the flag is set.
</p></dd></dl>

<p>The <code>mpfr_flags_</code> functions below that take an argument <var>mask</var>
can operate on any subset of the exception flags: a flag is part of this
subset (or group) if and only if the corresponding bit of the argument
<var>mask</var> is set.  The <code>MPFR_FLAGS_</code> macros will normally be used
to build this argument.  See <a href="#Exceptions">Exceptions</a>.
</p>
<dl>
<dt><a name="index-mpfr_005fflags_005fclear"></a>Function: <em>void</em> <strong>mpfr_flags_clear</strong> <em>(mpfr_flags_t <var>mask</var>)</em></dt>
<dd><p>Clear (lower) the group of flags specified by <var>mask</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fflags_005fset"></a>Function: <em>void</em> <strong>mpfr_flags_set</strong> <em>(mpfr_flags_t <var>mask</var>)</em></dt>
<dd><p>Set (raise) the group of flags specified by <var>mask</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fflags_005ftest"></a>Function: <em>mpfr_flags_t</em> <strong>mpfr_flags_test</strong> <em>(mpfr_flags_t <var>mask</var>)</em></dt>
<dd><p>Return the flags specified by <var>mask</var>.  To test whether any flag from
<var>mask</var> is set, compare the return value to 0.  You can also test
individual flags by AND&rsquo;ing the result with <code>MPFR_FLAGS_</code> macros.
Example:
</p><div class="example">
<pre class="example">mpfr_flags_t t = mpfr_flags_test (MPFR_FLAGS_UNDERFLOW|
                                  MPFR_FLAGS_OVERFLOW)
&hellip;
if (t)  /* underflow and/or overflow (unlikely) */
  {
    if (t &amp; MPFR_FLAGS_UNDERFLOW)  { /* handle underflow */ }
    if (t &amp; MPFR_FLAGS_OVERFLOW)   { /* handle overflow  */ }
  }
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-mpfr_005fflags_005fsave"></a>Function: <em>mpfr_flags_t</em> <strong>mpfr_flags_save</strong> <em>(void)</em></dt>
<dd><p>Return all the flags. It is equivalent to
<code>mpfr_flags_test(MPFR_FLAGS_ALL)</code>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fflags_005frestore"></a>Function: <em>void</em> <strong>mpfr_flags_restore</strong> <em>(mpfr_flags_t <var>flags</var>, mpfr_flags_t <var>mask</var>)</em></dt>
<dd><p>Restore the flags specified by <var>mask</var> to their state represented
in <var>flags</var>.
</p></dd></dl>

<hr>
<a name="Compatibility-with-MPF"></a>
<div class="header">
<p>
Next: <a href="#Custom-Interface" accesskey="n" rel="next">Custom Interface</a>, Previous: <a href="#Exception-Related-Functions" accesskey="p" rel="prev">Exception Related Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Compatibility-with-MPF"></a>
<a name="Compatibility-With-MPF"></a>
<h3 class="section">5.14 Compatibility With MPF</h3>

<p>A header file <samp>mpf2mpfr.h</samp> is included in the distribution of MPFR for
compatibility with the GNU MP class MPF.
By inserting the following two lines after the <code>#include &lt;gmp.h&gt;</code> line,
</p><div class="example">
<pre class="example">#include &lt;mpfr.h&gt;
#include &lt;mpf2mpfr.h&gt;
</pre></div>
<p>many programs written for MPF can be compiled directly against MPFR
without any changes.
All operations are then performed with the default MPFR rounding mode,
which can be reset with <code>mpfr_set_default_rounding_mode</code>.
</p>
<p>Warning! There are some differences. In particular:
</p><ul>
<li> The precision is different: MPFR rounds to the exact number of bits
(zeroing trailing bits in the internal representation). Users may need to
increase the precision of their variables.
</li><li> The exponent range is also different.
</li><li> The formatted output functions (<code>gmp_printf</code>, etc.)  will not work
for arguments of arbitrary-precision floating-point type (<code>mpf_t</code>, which
<samp>mpf2mpfr.h</samp> redefines as <code>mpfr_t</code>).
</li></ul>

<dl>
<dt><a name="index-mpfr_005fset_005fprec_005fraw"></a>Function: <em>void</em> <strong>mpfr_set_prec_raw</strong> <em>(mpfr_t <var>x</var>, mpfr_prec_t <var>prec</var>)</em></dt>
<dd><p>Reset the precision of <var>x</var> to be <strong>exactly</strong> <var>prec</var> bits.
The only difference with <code>mpfr_set_prec</code> is that <var>prec</var> is assumed to
be small enough so that the significand fits into the current allocated memory
space for <var>x</var>. Otherwise the behavior is undefined.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005feq"></a>Function: <em>int</em> <strong>mpfr_eq</strong> <em>(mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, unsigned long int <var>op3</var>)</em></dt>
<dd><p>Return non-zero if <var>op1</var> and <var>op2</var> are both non-zero ordinary
numbers with the same exponent and the same first <var>op3</var> bits, both
zero, or both infinities of the same sign. Return zero otherwise.
This function is defined for compatibility with MPF, we do not recommend
to use it otherwise.
Do not use it either if
you want to know whether two numbers are close to each other; for instance,
1.011111 and 1.100000 are regarded as different for any value of
<var>op3</var> larger than 1.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005freldiff"></a>Function: <em>void</em> <strong>mpfr_reldiff</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Compute the relative difference between <var>op1</var> and <var>op2</var>
and store the result in <var>rop</var>.
This function does not guarantee the correct rounding on the relative
difference; it just computes <em>|<var>op1</var>-<var>op2</var>|/<var>op1</var></em>, using the
precision of <var>rop</var> and the rounding mode <var>rnd</var> for all operations.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fmul_005f2exp"></a>Function: <em>int</em> <strong>mpfr_mul_2exp</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dt><a name="index-mpfr_005fdiv_005f2exp"></a>Function: <em>int</em> <strong>mpfr_div_2exp</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>These functions are identical to <code>mpfr_mul_2ui</code> and <code>mpfr_div_2ui</code>
respectively.
These functions are only kept for compatibility with MPF, one should
prefer <code>mpfr_mul_2ui</code> and <code>mpfr_div_2ui</code> otherwise.
</p></dd></dl>


<hr>
<a name="Custom-Interface"></a>
<div class="header">
<p>
Next: <a href="#Internals" accesskey="n" rel="next">Internals</a>, Previous: <a href="#Compatibility-with-MPF" accesskey="p" rel="prev">Compatibility with MPF</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Custom-interface"></a>
<a name="Custom-Interface-1"></a>
<h3 class="section">5.15 Custom Interface</h3>

<p>Some applications use a stack to handle the memory and their objects.
However, the MPFR memory design is not well suited for such a thing. So that
such applications are able to use MPFR, an auxiliary memory interface has
been created: the Custom Interface.
</p>
<p>The following interface allows one to use MPFR in two ways:
</p>
<ul>
<li> Either directly store a floating-point number as a <code>mpfr_t</code>
on the stack.

</li><li> Either store its own representation on the
stack and construct a new temporary <code>mpfr_t</code> each time it is needed.

</li></ul>

<p>Nothing has to be done to destroy the floating-point
numbers except garbaging the used
memory: all the memory management (allocating, destroying, garbaging) is left
to the application.
</p>
<p>Each function in this interface is also implemented as a macro for
efficiency reasons: for example <code>mpfr_custom_init (s, p)</code>
uses the macro, while <code>(mpfr_custom_init) (s, p)</code> uses the function.
</p>
<p>Note 1: MPFR functions may still initialize temporary floating-point numbers
using <code>mpfr_init</code> and similar functions. See Custom Allocation (GNU MP).
</p>
<p>Note 2: MPFR functions may use the cached functions (<code>mpfr_const_pi</code> for
example), even if they are not explicitly called. You have to call
<code>mpfr_free_cache</code> each time you garbage the memory iff <code>mpfr_init</code>,
through GMP Custom Allocation, allocates its memory on the application stack.
</p>
<dl>
<dt><a name="index-mpfr_005fcustom_005fget_005fsize"></a>Function: <em>size_t</em> <strong>mpfr_custom_get_size</strong> <em>(mpfr_prec_t <var>prec</var>)</em></dt>
<dd><p>Return the needed size in bytes to store the significand of a floating-point
number of precision <var>prec</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcustom_005finit"></a>Function: <em>void</em> <strong>mpfr_custom_init</strong> <em>(void *<var>significand</var>, mpfr_prec_t <var>prec</var>)</em></dt>
<dd><p>Initialize a significand of precision <var>prec</var>, where
<var>significand</var> must be an area of <code>mpfr_custom_get_size (prec)</code> bytes
at least and be suitably aligned for an array of <code>mp_limb_t</code> (GMP type,
see <a href="#Internals">Internals</a>).
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcustom_005finit_005fset"></a>Function: <em>void</em> <strong>mpfr_custom_init_set</strong> <em>(mpfr_t <var>x</var>, int <var>kind</var>, mpfr_exp_t <var>exp</var>, mpfr_prec_t <var>prec</var>, void *<var>significand</var>)</em></dt>
<dd><p>Perform a dummy initialization of a <code>mpfr_t</code> and set it to:
</p><ul>
<li> if abs(<var>kind</var>) = <code>MPFR_NAN_KIND</code>, <var>x</var> is set to NaN;
</li><li> if abs(<var>kind</var>) = <code>MPFR_INF_KIND</code>, <var>x</var> is set to the
infinity of the same sign as <var>kind</var>;
</li><li> if abs(<var>kind</var>) = <code>MPFR_ZERO_KIND</code>, <var>x</var> is set to the
zero of the same sign as <var>kind</var>;
</li><li> if abs(<var>kind</var>) = <code>MPFR_REGULAR_KIND</code>, <var>x</var> is set to
the regular number whose sign is the one of <var>kind</var>, and whose exponent
and significand are given by <var>exp</var> and <var>significand</var>.
</li></ul>
<p>In all cases, <var>significand</var> will be used directly for further computing
involving <var>x</var>. This function does not allocate anything.
A floating-point number initialized with this function cannot be resized using
<code>mpfr_set_prec</code> or <code>mpfr_prec_round</code>,
or cleared using <code>mpfr_clear</code>!
The <var>significand</var> must have been initialized with <code>mpfr_custom_init</code>
using the same precision <var>prec</var>.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcustom_005fget_005fkind"></a>Function: <em>int</em> <strong>mpfr_custom_get_kind</strong> <em>(mpfr_t <var>x</var>)</em></dt>
<dd><p>Return the current kind of a <code>mpfr_t</code> as created by
<code>mpfr_custom_init_set</code>.
The behavior of this function for any <code>mpfr_t</code> not initialized
with <code>mpfr_custom_init_set</code> is undefined.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcustom_005fget_005fsignificand"></a>Function: <em>void *</em> <strong>mpfr_custom_get_significand</strong> <em>(mpfr_t <var>x</var>)</em></dt>
<dd><p>Return a pointer to the significand used by a <code>mpfr_t</code> initialized with
<code>mpfr_custom_init_set</code>.
The behavior of this function for any <code>mpfr_t</code> not initialized
with <code>mpfr_custom_init_set</code> is undefined.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcustom_005fget_005fexp"></a>Function: <em>mpfr_exp_t</em> <strong>mpfr_custom_get_exp</strong> <em>(mpfr_t <var>x</var>)</em></dt>
<dd><p>Return the exponent of <var>x</var>, assuming that <var>x</var> is a non-zero ordinary
number and the significand is considered in [1/2,1).
But if <var>x</var> is NaN, infinity or zero, contrary to <code>mpfr_get_exp</code>
(where the behavior is undefined), the return value is here an unspecified,
valid value of the <code>mpfr_exp_t</code> type.
The behavior of this function for any <code>mpfr_t</code> not initialized
with <code>mpfr_custom_init_set</code> is undefined.
</p></dd></dl>

<dl>
<dt><a name="index-mpfr_005fcustom_005fmove"></a>Function: <em>void</em> <strong>mpfr_custom_move</strong> <em>(mpfr_t <var>x</var>, void *<var>new_position</var>)</em></dt>
<dd><p>Inform MPFR that the significand of <var>x</var> has moved due to a garbage collect
and update its new position to <code>new_position</code>.
However the application has to move the significand and the <code>mpfr_t</code>
itself.
The behavior of this function for any <code>mpfr_t</code> not initialized
with <code>mpfr_custom_init_set</code> is undefined.
</p></dd></dl>

<hr>
<a name="Internals"></a>
<div class="header">
<p>
Previous: <a href="#Custom-Interface" accesskey="p" rel="prev">Custom Interface</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="index-Internals"></a>
<a name="Internals-1"></a>
<h3 class="section">5.16 Internals</h3>

<a name="index-Limb"></a>
<p>A <em>limb</em> means the part of a multi-precision number that fits in a single
word. Usually a limb contains
32 or 64 bits.  The C data type for a limb is <code>mp_limb_t</code>.
</p>
<p>The <code>mpfr_t</code> type is internally defined as a one-element
array of a structure, and <code>mpfr_ptr</code> is the C data type representing
a pointer to this structure.
The <code>mpfr_t</code> type consists of four fields:
</p>
<ul>
<li> The <code>_mpfr_prec</code> field is used to store the precision of
the variable (in bits); this is not less than <code>MPFR_PREC_MIN</code>.

</li><li> The <code>_mpfr_sign</code> field is used to store the sign of the variable.

</li><li> The <code>_mpfr_exp</code> field stores the exponent.
An exponent of 0 means a radix point just above the most significant
limb.  Non-zero values <em>n</em> are a multiplier <em>2^n</em> relative to that
point.
A NaN, an infinity and a zero are indicated by special values of the exponent
field.

</li><li> Finally, the <code>_mpfr_d</code> field is a pointer to the limbs, least
significant limbs stored first.
The number of limbs in use is controlled by <code>_mpfr_prec</code>, namely
ceil(<code>_mpfr_prec</code>/<code>mp_bits_per_limb</code>).
Non-singular (i.e., different from NaN, Infinity or zero)
values always have the most significant bit of the most
significant limb set to 1.  When the precision does not correspond to a
whole number of limbs, the excess bits at the low end of the data are zeros.

</li></ul>

<hr>
<a name="API-Compatibility"></a>
<div class="header">
<p>
Next: <a href="#MPFR-and-the-IEEE-754-Standard" accesskey="n" rel="next">MPFR and the IEEE 754 Standard</a>, Previous: <a href="#MPFR-Interface" accesskey="p" rel="prev">MPFR Interface</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="API-Compatibility-1"></a>
<h2 class="chapter">6 API Compatibility</h2>

<p>The goal of this section is to describe some API changes that occurred
from one version of MPFR to another, and how to write code that can be compiled
and run with older MPFR versions.  The minimum MPFR version that is
considered here is 2.2.0 (released on 20 September 2005).
</p>
<p>API changes can only occur between major or minor versions.  Thus the
patchlevel (the third number in the MPFR version) will be ignored in
the following.  If a program does not use MPFR internals, changes in
the behavior between two versions differing only by the patchlevel
should only result from what was regarded as a bug or unspecified behavior.
</p>
<p>As a general rule, a program written for some MPFR version should work
with later versions, possibly except at a new major version, where
some features (described as obsolete for some time) can be removed.
In such a case, a failure should occur during compilation or linking.
If a result becomes incorrect because of such a change, please look
at the various changes below (they are minimal, and most software
should be unaffected), at the FAQ and at the MPFR web page for your
version (a bug could have been introduced and be already fixed);
and if the problem is not mentioned, please send us a bug report
(see <a href="#Reporting-Bugs">Reporting Bugs</a>).
</p>
<p>However, a program written for the current MPFR version (as documented
by this manual) may not necessarily work with previous versions of
MPFR.  This section should help developers to write portable code.
</p>
<p>Note: Information given here may be incomplete.  API changes are
also described in the NEWS file (for each version, instead of being
classified like here), together with other changes.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Type-and-Macro-Changes" accesskey="1">Type and Macro Changes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Added-Functions" accesskey="2">Added Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Changed-Functions" accesskey="3">Changed Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Removed-Functions" accesskey="4">Removed Functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Other-Changes" accesskey="5">Other Changes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Type-and-Macro-Changes"></a>
<div class="header">
<p>
Next: <a href="#Added-Functions" accesskey="n" rel="next">Added Functions</a>, Previous: <a href="#API-Compatibility" accesskey="p" rel="prev">API Compatibility</a>, Up: <a href="#API-Compatibility" accesskey="u" rel="up">API Compatibility</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Type-and-Macro-Changes-1"></a>
<h3 class="section">6.1 Type and Macro Changes</h3>

<p>The official type for exponent values changed from <code>mp_exp_t</code> to
<code>mpfr_exp_t</code> in MPFR 3.0.  The type <code>mp_exp_t</code> will remain
available as it comes from GMP (with a different meaning).  These types
are currently the same (<code>mpfr_exp_t</code> is defined as <code>mp_exp_t</code>
with <code>typedef</code>), so that programs can still use <code>mp_exp_t</code>;
but this may change in the future.
Alternatively, using the following code after including <samp>mpfr.h</samp>
will work with official MPFR versions, as <code>mpfr_exp_t</code> was never
defined in MPFR 2.x:
</p><div class="example">
<pre class="example">#if MPFR_VERSION_MAJOR &lt; 3
typedef mp_exp_t mpfr_exp_t;
#endif
</pre></div>

<p>The official types for precision values and for rounding modes
respectively changed from <code>mp_prec_t</code> and <code>mp_rnd_t</code>
to <code>mpfr_prec_t</code> and <code>mpfr_rnd_t</code> in MPFR 3.0.  This
change was actually done a long time ago in MPFR, at least since
MPFR 2.2.0, with the following code in <samp>mpfr.h</samp>:
</p><div class="example">
<pre class="example">#ifndef mp_rnd_t
# define mp_rnd_t  mpfr_rnd_t
#endif
#ifndef mp_prec_t
# define mp_prec_t mpfr_prec_t
#endif
</pre></div>
<p>This means that it is safe to use the new official types
<code>mpfr_prec_t</code> and <code>mpfr_rnd_t</code> in your programs.
The types <code>mp_prec_t</code> and <code>mp_rnd_t</code> (defined
in MPFR only) may be removed in the future, as the prefix
<code>mp_</code> is reserved by GMP.
</p>
<p>The precision type <code>mpfr_prec_t</code> (<code>mp_prec_t</code>) was unsigned
before MPFR 3.0; it is now signed.  <code>MPFR_PREC_MAX</code> has not changed,
though.  Indeed the MPFR code requires that <code>MPFR_PREC_MAX</code> be
representable in the exponent type, which may have the same size as
<code>mpfr_prec_t</code> but has always been signed.
The consequence is that valid code that does not assume anything about
the signedness of <code>mpfr_prec_t</code> should work with past and new MPFR
versions.
This change was useful as the use of unsigned types tends to convert
signed values to unsigned ones in expressions due to the usual arithmetic
conversions, which can yield incorrect results if a negative value is
converted in such a way.
Warning!  A program assuming (intentionally or not) that
<code>mpfr_prec_t</code> is signed may be affected by this problem when
it is built and run against MPFR 2.x.
</p>
<p>The rounding modes <code>GMP_RNDx</code> were renamed to <code>MPFR_RNDx</code>
in MPFR 3.0. However the old names <code>GMP_RNDx</code> have been kept for
compatibility (this might change in future versions), using:
</p><div class="example">
<pre class="example">#define GMP_RNDN MPFR_RNDN
#define GMP_RNDZ MPFR_RNDZ
#define GMP_RNDU MPFR_RNDU
#define GMP_RNDD MPFR_RNDD
</pre></div>
<p>The rounding mode &ldquo;round away from zero&rdquo; (<code>MPFR_RNDA</code>) was added in
MPFR 3.0 (however no rounding mode <code>GMP_RNDA</code> exists).
Faithful rounding (<code>MPFR_RNDF</code>) was added in MPFR 4.0, but currently,
it is partially supported.
</p>
<p>The flags-related macros, whose name starts with <code>MPFR_FLAGS_</code>,
were added in MPFR 4.0 (for the new functions <code>mpfr_flags_clear</code>,
<code>mpfr_flags_restore</code>, <code>mpfr_flags_set</code> and <code>mpfr_flags_test</code>,
in particular).
</p>
<hr>
<a name="Added-Functions"></a>
<div class="header">
<p>
Next: <a href="#Changed-Functions" accesskey="n" rel="next">Changed Functions</a>, Previous: <a href="#Type-and-Macro-Changes" accesskey="p" rel="prev">Type and Macro Changes</a>, Up: <a href="#API-Compatibility" accesskey="u" rel="up">API Compatibility</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Added-Functions-1"></a>
<h3 class="section">6.2 Added Functions</h3>

<p>We give here in alphabetical order the functions (and function-like macros)
that were added after MPFR 2.2, and in which MPFR version.
</p>

<ul>
<li> <code>mpfr_add_d</code> in MPFR 2.4.

</li><li> <code>mpfr_ai</code> in MPFR 3.0 (incomplete, experimental).

</li><li> <code>mpfr_asprintf</code> in MPFR 2.4.

</li><li> <code>mpfr_beta</code> in MPFR 4.0 (incomplete, experimental).

</li><li> <code>mpfr_buildopt_decimal_p</code> in MPFR 3.0.

</li><li> <code>mpfr_buildopt_float128_p</code> in MPFR 4.0.

</li><li> <code>mpfr_buildopt_gmpinternals_p</code> in MPFR 3.1.

</li><li> <code>mpfr_buildopt_sharedcache_p</code> in MPFR 4.0.

</li><li> <code>mpfr_buildopt_tls_p</code> in MPFR 3.0.

</li><li> <code>mpfr_buildopt_tune_case</code> in MPFR 3.1.

</li><li> <code>mpfr_clear_divby0</code> in MPFR 3.1 (new divide-by-zero exception).

</li><li> <code>mpfr_copysign</code> in MPFR 2.3.
Note: MPFR 2.2 had a <code>mpfr_copysign</code> function that was available,
but not documented,
and with a slight difference in the semantics (when
the second input operand is a NaN).

</li><li> <code>mpfr_custom_get_significand</code> in MPFR 3.0.
This function was named <code>mpfr_custom_get_mantissa</code> in previous
versions; <code>mpfr_custom_get_mantissa</code> is still available via a
macro in <samp>mpfr.h</samp>:
<div class="example">
<pre class="example">#define mpfr_custom_get_mantissa mpfr_custom_get_significand
</pre></div>
<p>Thus code that needs to work with both MPFR 2.x and MPFR 3.x should
use <code>mpfr_custom_get_mantissa</code>.
</p>
</li><li> <code>mpfr_d_div</code> and <code>mpfr_d_sub</code> in MPFR 2.4.

</li><li> <code>mpfr_digamma</code> in MPFR 3.0.

</li><li> <code>mpfr_divby0_p</code> in MPFR 3.1 (new divide-by-zero exception).

</li><li> <code>mpfr_div_d</code> in MPFR 2.4.

</li><li> <code>mpfr_erandom</code> in MPFR 4.0.

</li><li> <code>mpfr_flags_clear</code>, <code>mpfr_flags_restore</code>,
<code>mpfr_flags_save</code>, <code>mpfr_flags_set</code> and <code>mpfr_flags_test</code>
in MPFR 4.0.

</li><li> <code>mpfr_fmma</code> and <code>mpfr_fmms</code> in MPFR 4.0.

</li><li> <code>mpfr_fmod</code> in MPFR 2.4.

</li><li> <code>mpfr_fmodquo</code> in MPFR 4.0.

</li><li> <code>mpfr_fms</code> in MPFR 2.3.

</li><li> <code>mpfr_fpif_export</code> and <code>mpfr_fpif_import</code> in MPFR 4.0.

</li><li> <code>mpfr_fprintf</code> in MPFR 2.4.

</li><li> <code>mpfr_free_cache2</code> in MPFR 4.0.

</li><li> <code>mpfr_free_pool</code> in MPFR 4.0.

</li><li> <code>mpfr_frexp</code> in MPFR 3.1.

</li><li> <code>mpfr_gamma_inc</code> in MPFR 4.0.

</li><li> <code>mpfr_get_float128</code> in MPFR 4.0 if configured with
&lsquo;<samp>--enable-float128</samp>&rsquo;.

</li><li> <code>mpfr_get_flt</code> in MPFR 3.0.

</li><li> <code>mpfr_get_patches</code> in MPFR 2.3.

</li><li> <code>mpfr_get_q</code> in MPFR 4.0.

</li><li> <code>mpfr_get_z_2exp</code> in MPFR 3.0.
This function was named <code>mpfr_get_z_exp</code> in previous versions;
<code>mpfr_get_z_exp</code> is still available via a macro in <samp>mpfr.h</samp>:
<div class="example">
<pre class="example">#define mpfr_get_z_exp mpfr_get_z_2exp
</pre></div>
<p>Thus code that needs to work with both MPFR 2.x and MPFR 3.x should
use <code>mpfr_get_z_exp</code>.
</p>
</li><li> <code>mpfr_grandom</code> in MPFR 3.1.

</li><li> <code>mpfr_j0</code>, <code>mpfr_j1</code> and <code>mpfr_jn</code> in MPFR 2.3.

</li><li> <code>mpfr_lgamma</code> in MPFR 2.3.

</li><li> <code>mpfr_li2</code> in MPFR 2.4.

</li><li> <code>mpfr_log_ui</code> in MPFR 4.0.

</li><li> <code>mpfr_min_prec</code> in MPFR 3.0.

</li><li> <code>mpfr_modf</code> in MPFR 2.4.

</li><li> <code>mpfr_mp_memory_cleanup</code> in MPFR 4.0.

</li><li> <code>mpfr_mul_d</code> in MPFR 2.4.

</li><li> <code>mpfr_nrandom</code> in MPFR 4.0.

</li><li> <code>mpfr_printf</code> in MPFR 2.4.

</li><li> <code>mpfr_rec_sqrt</code> in MPFR 2.4.

</li><li> <code>mpfr_regular_p</code> in MPFR 3.0.

</li><li> <code>mpfr_remainder</code> and <code>mpfr_remquo</code> in MPFR 2.3.

</li><li> <code>mpfr_rint_roundeven</code> and <code>mpfr_roundeven</code> in MPFR 4.0.

</li><li> <code>mpfr_round_nearest_away</code> in MPFR 4.0.

</li><li> <code>mpfr_rootn_ui</code> in MPFR 4.0.

</li><li> <code>mpfr_set_divby0</code> in MPFR 3.1 (new divide-by-zero exception).

</li><li> <code>mpfr_set_float128</code> in MPFR 4.0 if configured with
&lsquo;<samp>--enable-float128</samp>&rsquo;.

</li><li> <code>mpfr_set_flt</code> in MPFR 3.0.

</li><li> <code>mpfr_set_z_2exp</code> in MPFR 3.0.

</li><li> <code>mpfr_set_zero</code> in MPFR 3.0.

</li><li> <code>mpfr_setsign</code> in MPFR 2.3.

</li><li> <code>mpfr_signbit</code> in MPFR 2.3.

</li><li> <code>mpfr_sinh_cosh</code> in MPFR 2.4.

</li><li> <code>mpfr_snprintf</code> and <code>mpfr_sprintf</code> in MPFR 2.4.

</li><li> <code>mpfr_sub_d</code> in MPFR 2.4.

</li><li> <code>mpfr_urandom</code> in MPFR 3.0.

</li><li> <code>mpfr_vasprintf</code>, <code>mpfr_vfprintf</code>, <code>mpfr_vprintf</code>,
      <code>mpfr_vsprintf</code> and <code>mpfr_vsnprintf</code> in MPFR 2.4.

</li><li> <code>mpfr_y0</code>, <code>mpfr_y1</code> and <code>mpfr_yn</code> in MPFR 2.3.

</li><li> <code>mpfr_z_sub</code> in MPFR 3.1.

</li></ul>

<hr>
<a name="Changed-Functions"></a>
<div class="header">
<p>
Next: <a href="#Removed-Functions" accesskey="n" rel="next">Removed Functions</a>, Previous: <a href="#Added-Functions" accesskey="p" rel="prev">Added Functions</a>, Up: <a href="#API-Compatibility" accesskey="u" rel="up">API Compatibility</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Changed-Functions-1"></a>
<h3 class="section">6.3 Changed Functions</h3>

<p>The following functions have changed after MPFR 2.2. Changes can affect
the behavior of code written for some MPFR version when built and run
against another MPFR version (older or newer), as described below.
</p>
<ul>
<li> <code>mpfr_abs</code>, <code>mpfr_neg</code> and <code>mpfr_set</code> changed in MPFR 4.0.
In previous MPFR versions, the sign bit of a NaN was unspecified; however,
in practice, it was set as now specified except for <code>mpfr_neg</code> with
a reused argument: <code>mpfr_neg(x,x,rnd)</code>.

</li><li> <code>mpfr_check_range</code> changed in MPFR 2.3.2 and MPFR 2.4.
If the value is an inexact infinity, the overflow flag is now set
(in case it was lost), while it was previously left unchanged.
This is really what is expected in practice (and what the MPFR code
was expecting), so that the previous behavior was regarded as a bug.
Hence the change in MPFR 2.3.2.

</li><li> <code>mpfr_eint</code> changed in MPFR 4.0.
This function now returns the value of the E1/eint1 function for
negative argument (before MPFR 4.0, it was returning NaN).

</li><li> <code>mpfr_get_f</code> changed in MPFR 3.0.
This function was returning zero, except for NaN and Inf, which do not
exist in MPF. The <em>erange</em> flag is now set in these cases,
and <code>mpfr_get_f</code> now returns the usual ternary value.

</li><li> <code>mpfr_get_si</code>, <code>mpfr_get_sj</code>, <code>mpfr_get_ui</code>
and <code>mpfr_get_uj</code> changed in MPFR 3.0.
In previous MPFR versions, the cases where the <em>erange</em> flag
is set were unspecified.

</li><li> <code>mpfr_get_str</code> changed in MPFR 4.0.
This function now sets the NaN flag on NaN input (to follow the usual MPFR
rules on NaN and IEEE 754-2008 recommendations on string conversions from
Subclause 5.12.1) and sets the inexact flag when the conversion is inexact.

</li><li> <code>mpfr_get_z</code> changed in MPFR 3.0.
The return type was <code>void</code>; it is now <code>int</code>, and the usual
ternary value is returned.  Thus programs that need to work with both
MPFR 2.x and 3.x must not use the return value.  Even in this case,
C code using <code>mpfr_get_z</code> as the second or third term of
a conditional operator may also be affected. For instance, the
following is correct with MPFR 3.0, but not with MPFR 2.x:
<div class="example">
<pre class="example">  bool ? mpfr_get_z(...) : mpfr_add(...);
</pre></div>
<p>On the other hand, the following is correct with MPFR 2.x, but not
with MPFR 3.0:
</p><div class="example">
<pre class="example">  bool ? mpfr_get_z(...) : (void) mpfr_add(...);
</pre></div>
<p>Portable code should cast <code>mpfr_get_z(...)</code> to <code>void</code> to
use the type <code>void</code> for both terms of the conditional operator,
as in:
</p><div class="example">
<pre class="example">  bool ? (void) mpfr_get_z(...) : (void) mpfr_add(...);
</pre></div>
<p>Alternatively, <code>if ... else</code> can be used instead of the
conditional operator.
</p>
<p>Moreover the cases where the <em>erange</em> flag is set were unspecified
in MPFR 2.x.
</p>
</li><li> <code>mpfr_get_z_exp</code> changed in MPFR 3.0.
In previous MPFR versions, the cases where the <em>erange</em> flag
is set were unspecified.
Note: this function has been renamed to <code>mpfr_get_z_2exp</code>
in MPFR 3.0, but <code>mpfr_get_z_exp</code> is still available for
compatibility reasons.

</li><li> <code>mpfr_set_exp</code> changed in MPFR 4.0.
Before MPFR 4.0, the exponent was set whatever the contents of the MPFR
object in argument. In practice, this could be useful as a low-level
function when the MPFR number was being constructed by setting the fields
of its internal structure, but the API does not provide a way to do this
except by using internals. Thus, for the API, this behavior was useless
and could quickly lead to undefined behavior due to the fact that the
generated value could have an invalid format if the MPFR object contained
a special value (NaN, infinity or zero).

</li><li> <code>mpfr_strtofr</code> changed in MPFR 2.3.1 and MPFR 2.4.
This was actually a bug fix since the code and the documentation did
not match.  But both were changed in order to have a more consistent
and useful behavior.  The main changes in the code are as follows.
The binary exponent is now accepted even without the <code>0b</code> or
<code>0x</code> prefix.  Data corresponding to NaN can now have an optional
sign (such data were previously invalid).

</li><li> <code>mpfr_strtofr</code> changed in MPFR 3.0.
This function now accepts bases from 37 to 62 (no changes for the other
bases).  Note: if an unsupported base is provided to this function,
the behavior is undefined; more precisely, in MPFR 2.3.1 and later,
providing an unsupported base yields an assertion failure (this
behavior may change in the future).

</li><li> <code>mpfr_subnormalize</code> changed in MPFR 3.1.
This was actually regarded as a bug fix. The <code>mpfr_subnormalize</code>
implementation up to MPFR 3.0.0 did not change the flags. In particular,
it did not follow the generic rule concerning the inexact flag (and no
special behavior was specified). The case of the underflow flag was more
a lack of specification.

</li><li> <code>mpfr_sum</code> changed in MPFR 4.0.
The <code>mpfr_sum</code> function has completely been rewritten for MPFR 4.0,
with an update of the specification: the sign of an exact zero result
is now specified, and the return value is now the usual ternary value.
The old <code>mpfr_sum</code> implementation could also take all the memory
and crash on inputs of very different magnitude.

</li><li> <code>mpfr_urandom</code> and <code>mpfr_urandomb</code> changed in MPFR 3.1.
Their behavior no longer depends on the platform (assuming this is also true
for GMP&rsquo;s random generator, which is not the case between GMP 4.1 and 4.2 if
<code>gmp_randinit_default</code> is used).  As a consequence, the returned values
can be different between MPFR 3.1 and previous MPFR versions.
Note: as the reproducibility of these functions was not specified
before MPFR 3.1, the MPFR 3.1 behavior is <em>not</em> regarded as
backward incompatible with previous versions.

</li><li> <code>mpfr_urandom</code> changed in MPFR 4.0.
The next random state no longer depends on the current exponent range and
the rounding mode. The exceptions due to the rounding of the random number
are now correctly generated, following the uniform distribution.
As a consequence, the returned values can be different between MPFR 4.0
and previous MPFR versions.

</li></ul>

<hr>
<a name="Removed-Functions"></a>
<div class="header">
<p>
Next: <a href="#Other-Changes" accesskey="n" rel="next">Other Changes</a>, Previous: <a href="#Changed-Functions" accesskey="p" rel="prev">Changed Functions</a>, Up: <a href="#API-Compatibility" accesskey="u" rel="up">API Compatibility</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Removed-Functions-1"></a>
<h3 class="section">6.4 Removed Functions</h3>

<p>Functions <code>mpfr_random</code> and <code>mpfr_random2</code> have been
removed in MPFR 3.0 (this only affects old code built against
MPFR 3.0 or later).
(The function <code>mpfr_random</code> had been deprecated since at least MPFR 2.2.0,
and <code>mpfr_random2</code> since MPFR 2.4.0.)
</p>
<p>Macros <code>mpfr_add_one_ulp</code> and <code>mpfr_sub_one_ulp</code> have been
removed in MPFR 4.0. They were no longer documented since MPFR 2.1.0
and were announced as deprecated since MPFR 3.1.0.
</p>
<p>Function <code>mpfr_grandom</code> is marked as deprecated in MPFR 4.0.
It will be removed in a future release.
</p>
<hr>
<a name="Other-Changes"></a>
<div class="header">
<p>
Previous: <a href="#Removed-Functions" accesskey="p" rel="prev">Removed Functions</a>, Up: <a href="#API-Compatibility" accesskey="u" rel="up">API Compatibility</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Other-Changes-1"></a>
<h3 class="section">6.5 Other Changes</h3>

<p>For users of a C++ compiler, the way how the availability of <code>intmax_t</code>
is detected has changed in MPFR 3.0.
In MPFR 2.x, if a macro <code>INTMAX_C</code> or <code>UINTMAX_C</code> was defined
(e.g. when the <code>__STDC_CONSTANT_MACROS</code> macro had been defined
before <code>&lt;stdint.h&gt;</code> or <code>&lt;inttypes.h&gt;</code> has been included),
<code>intmax_t</code> was assumed to be defined.
However this was not always the case (more precisely, <code>intmax_t</code>
can be defined only in the namespace <code>std</code>, as with Boost), so
that compilations could fail.
Thus the check for <code>INTMAX_C</code> or <code>UINTMAX_C</code> is now disabled for
C++ compilers, with the following consequences:
</p>
<ul>
<li> Programs written for MPFR 2.x that need <code>intmax_t</code> may no longer
be compiled against MPFR 3.0: a <code>#define MPFR_USE_INTMAX_T</code> may be
necessary before <samp>mpfr.h</samp> is included.

</li><li> The compilation of programs that work with MPFR 3.0 may fail with
MPFR 2.x due to the problem described above.  Workarounds are possible,
such as defining <code>intmax_t</code> and <code>uintmax_t</code> in the global
namespace, though this is not clean.

</li></ul>

<p>The divide-by-zero exception is new in MPFR 3.1. However it should
not introduce incompatible changes for programs that strictly follow
the MPFR API since the exception can only be seen via new functions.
</p>
<p>As of MPFR 3.1, the <samp>mpfr.h</samp> header can be included several times,
while still supporting optional functions (see <a href="#Headers-and-Libraries">Headers and Libraries</a>).
</p>
<p>The way memory is allocated by MPFR should be regarded as well-specified
only as of MPFR 4.0.
</p>
<hr>
<a name="MPFR-and-the-IEEE-754-Standard"></a>
<div class="header">
<p>
Next: <a href="#Contributors" accesskey="n" rel="next">Contributors</a>, Previous: <a href="#API-Compatibility" accesskey="p" rel="prev">API Compatibility</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="MPFR-and-the-IEEE-754-Standard-1"></a>
<h2 class="chapter">7 MPFR and the IEEE 754 Standard</h2>

<p>This section describes differences between MPFR and the IEEE 754 standard,
and behaviors that are not specified yet in IEEE 754.
</p>
<p>The MPFR numbers do not include subnormals. The reason is that subnormals
are less useful than in IEEE 754 as the default exponent range in MPFR is
large and they would have made the implementation more complex.
However, subnormals can be emulated using <code>mpfr_subnormalize</code>.
</p>
<p>MPFR has a single NaN. The behavior is similar either to a signaling NaN or
to a quiet NaN, depending on the context. For any function returning a NaN
(either produced or propagated), the NaN flag is set, while in IEEE 754,
some operations are quiet (even on a signaling NaN).
</p>
<p>The <code>mpfr_rec_sqrt</code> function differs from IEEE 754 on -0,
where it gives +Inf (like for +0), following the usual limit rules,
instead of -Inf.
</p>
<p>The <code>mpfr_root</code> function predates IEEE 754-2008 and behaves differently
from its rootn operation.
It is deprecated and <code>mpfr_rootn_ui</code> should be used instead.
</p>

<p>Operations with an unsigned zero: For functions taking an argument of
integer or rational type, a zero of such a type is unsigned unlike the
floating-point zero (this includes the zero of type <code>unsigned long</code>,
which is a mathematical, exact zero, as opposed to a floating-point zero,
which may come from an underflow and whose sign would correspond to the
sign of the real non-zero value). Unless documented otherwise, this zero
is regarded as +0, as if it were first converted to a MPFR number with
<code>mpfr_set_ui</code> or <code>mpfr_set_si</code> (thus the result may not agree
with the usual limit rules applied to a mathematical zero). This is not
the case of addition and subtraction (<code>mpfr_add_ui</code>, etc.), but for
these functions, only the sign of a zero result would be affected, with
+0 and -0 considered equal.
Such operations are currently out of the scope of the IEEE 754 standard,
and at the time of specification in MPFR, the Floating-Point Working Group
in charge of the revision of IEEE 754 did not want to discuss issues with
non-floating-point types in general.
</p>
<p>Note also that some obvious differences may come from the fact that in
MPFR, each variable has its own precision. For instance, a subtraction
of two numbers of the same sign may yield an overflow; idem for a call
to <code>mpfr_set</code>, <code>mpfr_neg</code> or <code>mpfr_abs</code>, if the destination
variable has a smaller precision.
</p>
<hr>
<a name="Contributors"></a>
<div class="header">
<p>
Next: <a href="#References" accesskey="n" rel="next">References</a>, Previous: <a href="#MPFR-and-the-IEEE-754-Standard" accesskey="p" rel="prev">MPFR and the IEEE 754 Standard</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Contributors-1"></a>
<h2 class="unnumbered">Contributors</h2>

<p>The main developers of MPFR are Guillaume Hanrot, Vincent Lef&egrave;vre,
Patrick P&eacute;lissier, Philippe Th&eacute;veny and Paul Zimmermann.
</p>
<p>Sylvie Boldo from ENS-Lyon, France,
contributed the functions <code>mpfr_agm</code> and <code>mpfr_log</code>.
Sylvain Chevillard contributed the <code>mpfr_ai</code> function.
David Daney contributed the hyperbolic and inverse hyperbolic functions,
the base-2 exponential, and the factorial function.
Alain Delplanque contributed the new version of the <code>mpfr_get_str</code>
function.
Mathieu Dutour contributed the functions <code>mpfr_acos</code>, <code>mpfr_asin</code>
and <code>mpfr_atan</code>, and a previous version of <code>mpfr_gamma</code>.
Laurent Fousse contributed the original version of the <code>mpfr_sum</code>
function (used up to MPFR 3.1).
Emmanuel Jeandel, from ENS-Lyon too,
contributed the generic hypergeometric code,
as well as the internal function <code>mpfr_exp3</code>,
a first implementation of the sine and cosine,
and improved versions of
<code>mpfr_const_log2</code> and <code>mpfr_const_pi</code>.
Ludovic Meunier helped in the design of the <code>mpfr_erf</code> code.
Jean-Luc R&eacute;my contributed the <code>mpfr_zeta</code> code.
Fabrice Rouillier contributed the <code>mpfr_xxx_z</code> and <code>mpfr_xxx_q</code>
functions, and helped to the Microsoft Windows porting.
Damien Stehl&eacute; contributed the <code>mpfr_get_ld_2exp</code> function.
Charles Karney contributed the <code>mpfr_nrandom</code> and <code>mpfr_erandom</code>
functions.
</p>
<p>We would like to thank Jean-Michel Muller and Joris van der Hoeven for very
fruitful discussions at the beginning of that project, Torbj&ouml;rn Granlund
and Kevin Ryde for their help about design issues,
and Nathalie Revol for her careful reading of a previous version of
this documentation. In particular
Kevin Ryde did a tremendous job for the portability of MPFR in 2002-2004.
</p>
<p>The development of the MPFR library would not have been possible without
the continuous support of INRIA, and of the LORIA (Nancy, France) and LIP
(Lyon, France) laboratories. In particular the main authors were or are
members of the PolKA, Spaces, Cacao, Caramel and Caramba
project-teams at LORIA and of the
Ar&eacute;naire and AriC project-teams at LIP.
This project was started during the Fiable (reliable in French) action
supported by INRIA, and continued during the AOC action.
The development of MPFR was also supported by a grant
(202F0659 00 MPN 121) from the Conseil R&eacute;gional de Lorraine in 2002,
from INRIA by an &quot;associate engineer&quot; grant (2003-2005),
an &quot;op&eacute;ration de d&eacute;veloppement logiciel&quot; grant (2007-2009),
and the post-doctoral grant of Sylvain Chevillard in 2009-2010.
The MPFR-MPC workshop in June 2012 was partly supported by the ERC
grant ANTICS of Andreas Enge.
The MPFR-MPC workshop in January 2013 was partly supported by the ERC
grant ANTICS, the GDR IM and the Caramel project-team, during which
Mickaël Gastineau contributed the MPFRbench program, and
Fredrik Johansson a faster version of <code>mpfr_const_euler</code>.
</p>
<hr>
<a name="References"></a>
<div class="header">
<p>
Next: <a href="#GNU-Free-Documentation-License" accesskey="n" rel="next">GNU Free Documentation License</a>, Previous: <a href="#Contributors" accesskey="p" rel="prev">Contributors</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="References-1"></a>
<h2 class="unnumbered">References</h2>

<ul>
<li> Richard Brent and Paul Zimmermann,
&quot;Modern Computer Arithmetic&quot;,
Cambridge University Press,
Cambridge Monographs on Applied and Computational Mathematics,
Number 18, 2010.
Electronic version freely available at
<a href="https://members.loria.fr/PZimmermann/mca/pub226.html">https://members.loria.fr/PZimmermann/mca/pub226.html</a>.

</li><li> Laurent Fousse, Guillaume Hanrot, Vincent Lef&egrave;vre,
Patrick P&eacute;lissier and Paul Zimmermann,
&quot;MPFR: A Multiple-Precision Binary Floating-Point Library With Correct Rounding&quot;,
ACM Transactions on Mathematical Software,
volume 33, issue 2, article 13, 15 pages, 2007,
<a href="http://doi.acm.org/10.1145/1236463.1236468">http://doi.acm.org/10.1145/1236463.1236468</a>.

</li><li> Torbj&ouml;rn Granlund, &quot;GNU MP: The GNU Multiple Precision Arithmetic Library&quot;,
  version 6.1.2, 2016, <a href="https://gmplib.org/">https://gmplib.org/</a>.

</li><li> IEEE standard for binary floating-point arithmetic, Technical Report
ANSI-IEEE Standard 754-1985, New York, 1985.
Approved March 21, 1985: IEEE Standards Board; approved July 26,
  1985: American National Standards Institute, 18 pages.

</li><li> IEEE Standard for Floating-Point Arithmetic,
ANSI-IEEE Standard 754-2008, 2008.
Revision of ANSI-IEEE Standard 754-1985,
approved June 12, 2008: IEEE Standards Board, 70 pages.

</li><li> Donald E. Knuth, &quot;The Art of Computer Programming&quot;, vol 2,
&quot;Seminumerical Algorithms&quot;, 2nd edition, Addison-Wesley, 1981.

</li><li> Jean-Michel Muller, &quot;Elementary Functions, Algorithms and Implementation&quot;,
Birkh&auml;user, Boston, 3rd edition, 2016.

</li><li> Jean-Michel Muller, Nicolas Brisebarre, Florent de Dinechin,
Claude-Pierre Jeannerod, Vincent Lef&egrave;vre, Guillaume Melquiond,
Nathalie Revol, Damien Stehl&eacute; and Serge Torr&egrave;s,
&quot;Handbook of Floating-Point Arithmetic&quot;,
Birkh&auml;user, Boston, 2009.

</li></ul>


<hr>
<a name="GNU-Free-Documentation-License"></a>
<div class="header">
<p>
Next: <a href="#Concept-Index" accesskey="n" rel="next">Concept Index</a>, Previous: <a href="#References" accesskey="p" rel="prev">References</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="GNU-Free-Documentation-License-1"></a>
<h2 class="appendix">Appendix A GNU Free Documentation License</h2>
<a name="index-GNU-Free-Documentation-License"></a>

<a name="index-GNU-Free-Documentation-License-1"></a>
<div align="center">Version 1.2, November 2002
</div>
<div class="display">
<pre class="display">Copyright &copy; 2000,2001,2002 Free Software Foundation, Inc.
51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</pre></div>

<ol start="0">
<li> PREAMBLE

<p>The purpose of this License is to make a manual, textbook, or other
functional and useful document <em>free</em> in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.
</p>
<p>This License is a kind of &ldquo;copyleft&rdquo;, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.
</p>
<p>We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.
</p>
</li><li> APPLICABILITY AND DEFINITIONS

<p>This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The &ldquo;Document&rdquo;, below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as &ldquo;you&rdquo;.  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.
</p>
<p>A &ldquo;Modified Version&rdquo; of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.
</p>
<p>A &ldquo;Secondary Section&rdquo; is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document&rsquo;s overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.
</p>
<p>The &ldquo;Invariant Sections&rdquo; are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.
</p>
<p>The &ldquo;Cover Texts&rdquo; are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.
</p>
<p>A &ldquo;Transparent&rdquo; copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not &ldquo;Transparent&rdquo; is called &ldquo;Opaque&rdquo;.
</p>
<p>Examples of suitable formats for Transparent copies include plain
<small>ASCII</small> without markup, Texinfo input format, LaTeX input
format, <acronym>SGML</acronym> or <acronym>XML</acronym> using a publicly available
<acronym>DTD</acronym>, and standard-conforming simple <acronym>HTML</acronym>,
PostScript or <acronym>PDF</acronym> designed for human modification.  Examples
of transparent image formats include <acronym>PNG</acronym>, <acronym>XCF</acronym> and
<acronym>JPG</acronym>.  Opaque formats include proprietary formats that can be
read and edited only by proprietary word processors, <acronym>SGML</acronym> or
<acronym>XML</acronym> for which the <acronym>DTD</acronym> and/or processing tools are
not generally available, and the machine-generated <acronym>HTML</acronym>,
PostScript or <acronym>PDF</acronym> produced by some word processors for
output purposes only.
</p>
<p>The &ldquo;Title Page&rdquo; means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, &ldquo;Title Page&rdquo; means
the text near the most prominent appearance of the work&rsquo;s title,
preceding the beginning of the body of the text.
</p>
<p>A section &ldquo;Entitled XYZ&rdquo; means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as &ldquo;Acknowledgements&rdquo;,
&ldquo;Dedications&rdquo;, &ldquo;Endorsements&rdquo;, or &ldquo;History&rdquo;.)  To &ldquo;Preserve the Title&rdquo;
of such a section when you modify the Document means that it remains a
section &ldquo;Entitled XYZ&rdquo; according to this definition.
</p>
<p>The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.
</p>
</li><li> VERBATIM COPYING

<p>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.
</p>
<p>You may also lend copies, under the same conditions stated above, and
you may publicly display copies.
</p>
</li><li> COPYING IN QUANTITY

<p>If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document&rsquo;s license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.
</p>
<p>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.
</p>
<p>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.
</p>
<p>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.
</p>
</li><li> MODIFICATIONS

<p>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:
</p>
<ol type="A" start="1">
<li> Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

</li><li> List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has fewer than five),
unless they release you from this requirement.

</li><li> State on the Title page the name of the publisher of the
Modified Version, as the publisher.

</li><li> Preserve all the copyright notices of the Document.

</li><li> Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

</li><li> Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

</li><li> Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document&rsquo;s license notice.

</li><li> Include an unaltered copy of this License.

</li><li> Preserve the section Entitled &ldquo;History&rdquo;, Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled &ldquo;History&rdquo; in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

</li><li> Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the &ldquo;History&rdquo; section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

</li><li> For any section Entitled &ldquo;Acknowledgements&rdquo; or &ldquo;Dedications&rdquo;, Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.

</li><li> Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

</li><li> Delete any section Entitled &ldquo;Endorsements&rdquo;.  Such a section
may not be included in the Modified Version.

</li><li> Do not retitle any existing section to be Entitled &ldquo;Endorsements&rdquo; or
to conflict in title with any Invariant Section.

</li><li> Preserve any Warranty Disclaimers.
</li></ol>

<p>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version&rsquo;s license notice.
These titles must be distinct from any other section titles.
</p>
<p>You may add a section Entitled &ldquo;Endorsements&rdquo;, provided it contains
nothing but endorsements of your Modified Version by various
parties&mdash;for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.
</p>
<p>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.
</p>
<p>The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.
</p>
</li><li> COMBINING DOCUMENTS

<p>You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.
</p>
<p>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.
</p>
<p>In the combination, you must combine any sections Entitled &ldquo;History&rdquo;
in the various original documents, forming one section Entitled
&ldquo;History&rdquo;; likewise combine any sections Entitled &ldquo;Acknowledgements&rdquo;,
and any sections Entitled &ldquo;Dedications&rdquo;.  You must delete all
sections Entitled &ldquo;Endorsements.&rdquo;
</p>
</li><li> COLLECTIONS OF DOCUMENTS

<p>You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.
</p>
<p>You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.
</p>
</li><li> AGGREGATION WITH INDEPENDENT WORKS

<p>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an &ldquo;aggregate&rdquo; if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation&rsquo;s users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.
</p>
<p>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document&rsquo;s Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.
</p>
</li><li> TRANSLATION

<p>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.
</p>
<p>If a section in the Document is Entitled &ldquo;Acknowledgements&rdquo;,
&ldquo;Dedications&rdquo;, or &ldquo;History&rdquo;, the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.
</p>
</li><li> TERMINATION

<p>You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.
</p>
</li><li> FUTURE REVISIONS OF THIS LICENSE

<p>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
<a href="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</a>.
</p>
<p>Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License &ldquo;or any later version&rdquo; applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.
</p></li></ol>

<a name="ADDENDUM_003a-How-to-Use-This-License-For-Your-Documents"></a>
<h3 class="appendixsec">A.1 ADDENDUM: How to Use This License For Your Documents</h3>

<p>To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:
</p>
<div class="smallexample">
<pre class="smallexample">  Copyright (C)  <var>year</var>  <var>your name</var>.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.2
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
</pre></div>

<p>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the &ldquo;with...Texts.&rdquo; line with this:
</p>
<div class="smallexample">
<pre class="smallexample">    with the Invariant Sections being <var>list their titles</var>, with
    the Front-Cover Texts being <var>list</var>, and with the Back-Cover Texts
    being <var>list</var>.
</pre></div>

<p>If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.
</p>
<p>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.
</p>



<hr>
<a name="Concept-Index"></a>
<div class="header">
<p>
Next: <a href="#Function-and-Type-Index" accesskey="n" rel="next">Function and Type Index</a>, Previous: <a href="#GNU-Free-Documentation-License" accesskey="p" rel="prev">GNU Free Documentation License</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Concept-Index-1"></a>
<h2 class="unnumbered">Concept Index</h2>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Concept-Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-U"><b>U</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-cp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-A">A</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Accuracy">Accuracy</a>:</td><td>&nbsp;</td><td valign="top"><a href="#MPFR-Interface">MPFR Interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arithmetic-functions">Arithmetic functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Assignment-functions">Assignment functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-B">B</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Basic-arithmetic-functions">Basic arithmetic functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Combined-initialization-and-assignment-functions">Combined initialization and assignment functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Comparison-functions">Comparison functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Compatibility-with-MPF">Compatibility with MPF</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-with-MPF">Compatibility with MPF</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Conditions-for-copying-MPFR">Conditions for copying MPFR</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Copying">Copying</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Conversion-functions">Conversion functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Copying-conditions">Copying conditions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Copying">Copying</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Custom-interface">Custom interface</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Custom-Interface">Custom Interface</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-E">E</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Exception-related-functions">Exception related functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Float-arithmetic-functions">Float arithmetic functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Float-comparisons-functions">Float comparisons functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Float-functions">Float functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#MPFR-Interface">MPFR Interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Float-input-and-output-functions">Float input and output functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Input-and-Output-Functions">Input and Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Float-output-functions">Float output functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Floating_002dpoint-functions">Floating-point functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#MPFR-Interface">MPFR Interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Floating_002dpoint-number">Floating-point number</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nomenclature-and-Types">Nomenclature and Types</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU-Free-Documentation-License">GNU Free Documentation License</a>:</td><td>&nbsp;</td><td valign="top"><a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU-Free-Documentation-License-1">GNU Free Documentation License</a>:</td><td>&nbsp;</td><td valign="top"><a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Group-of-flags">Group of flags</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nomenclature-and-Types">Nomenclature and Types</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-I">I</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-I_002fO-functions">I/O functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Input-and-Output-Functions">Input and Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-I_002fO-functions-1">I/O functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Initialization-functions">Initialization functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Initialization-Functions">Initialization Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Input-functions">Input functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Input-and-Output-Functions">Input and Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Installation">Installation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Installing-MPFR">Installing MPFR</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Integer-related-functions">Integer related functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Internals">Internals</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Internals">Internals</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-intmax_005ft"><code>intmax_t</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Headers-and-Libraries">Headers and Libraries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-inttypes_002eh"><code>inttypes.h</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Headers-and-Libraries">Headers and Libraries</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-L">L</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-libmpfr"><code>libmpfr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Headers-and-Libraries">Headers and Libraries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Libraries">Libraries</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Headers-and-Libraries">Headers and Libraries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Libtool">Libtool</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Headers-and-Libraries">Headers and Libraries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Limb">Limb</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Internals">Internals</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Linking">Linking</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Headers-and-Libraries">Headers and Libraries</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-M">M</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Miscellaneous-float-functions">Miscellaneous float functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_002eh"><samp>mpfr.h</samp></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Headers-and-Libraries">Headers and Libraries</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-O">O</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Output-functions">Output functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Input-and-Output-Functions">Input and Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Output-functions-1">Output functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Precision">Precision</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nomenclature-and-Types">Nomenclature and Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Precision-1">Precision</a>:</td><td>&nbsp;</td><td valign="top"><a href="#MPFR-Interface">MPFR Interface</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-R">R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Remainder-related-functions">Remainder related functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Reporting-bugs">Reporting bugs</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reporting-Bugs">Reporting Bugs</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Rounding-mode-related-functions">Rounding mode related functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rounding_002dRelated-Functions">Rounding-Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Rounding-Modes">Rounding Modes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nomenclature-and-Types">Nomenclature and Types</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-S">S</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Special-functions">Special functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stdarg_002eh"><code>stdarg.h</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Headers-and-Libraries">Headers and Libraries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stdint_002eh"><code>stdint.h</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Headers-and-Libraries">Headers and Libraries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stdio_002eh"><code>stdio.h</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Headers-and-Libraries">Headers and Libraries</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-T">T</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Ternary-value">Ternary value</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rounding-Modes">Rounding Modes</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-U">U</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-uintmax_005ft"><code>uintmax_t</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Headers-and-Libraries">Headers and Libraries</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Concept-Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-U"><b>U</b></a>
 &nbsp; 
</td></tr></table>

<hr>
<a name="Function-and-Type-Index"></a>
<div class="header">
<p>
Previous: <a href="#Concept-Index" accesskey="p" rel="prev">Concept Index</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Function-and-Type-Index-1"></a>
<h2 class="unnumbered">Function and Type Index</h2>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Function-and-Type-Index_fn_letter-M"><b>M</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-fn" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-and-Type-Index_fn_letter-M">M</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fabs"><code>mpfr_abs</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005facos"><code>mpfr_acos</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005facosh"><code>mpfr_acosh</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fadd"><code>mpfr_add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fadd_005fd"><code>mpfr_add_d</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fadd_005fq"><code>mpfr_add_q</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fadd_005fsi"><code>mpfr_add_si</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fadd_005fui"><code>mpfr_add_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fadd_005fz"><code>mpfr_add_z</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fagm"><code>mpfr_agm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fai"><code>mpfr_ai</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fasin"><code>mpfr_asin</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fasinh"><code>mpfr_asinh</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fasprintf"><code>mpfr_asprintf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fatan"><code>mpfr_atan</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fatan2"><code>mpfr_atan2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fatanh"><code>mpfr_atanh</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fbeta"><code>mpfr_beta</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fbuildopt_005fdecimal_005fp"><code>mpfr_buildopt_decimal_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fbuildopt_005ffloat128_005fp"><code>mpfr_buildopt_float128_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fbuildopt_005fgmpinternals_005fp"><code>mpfr_buildopt_gmpinternals_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fbuildopt_005fsharedcache_005fp"><code>mpfr_buildopt_sharedcache_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fbuildopt_005ftls_005fp"><code>mpfr_buildopt_tls_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fbuildopt_005ftune_005fcase"><code>mpfr_buildopt_tune_case</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcan_005fround"><code>mpfr_can_round</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rounding_002dRelated-Functions">Rounding-Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcbrt"><code>mpfr_cbrt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fceil"><code>mpfr_ceil</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcheck_005frange"><code>mpfr_check_range</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fclear"><code>mpfr_clear</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Initialization-Functions">Initialization Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fclears"><code>mpfr_clears</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Initialization-Functions">Initialization Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fclear_005fdivby0"><code>mpfr_clear_divby0</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fclear_005ferangeflag"><code>mpfr_clear_erangeflag</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fclear_005fflags"><code>mpfr_clear_flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fclear_005finexflag"><code>mpfr_clear_inexflag</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fclear_005fnanflag"><code>mpfr_clear_nanflag</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fclear_005foverflow"><code>mpfr_clear_overflow</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fclear_005funderflow"><code>mpfr_clear_underflow</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcmp"><code>mpfr_cmp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcmpabs"><code>mpfr_cmpabs</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcmp_005fd"><code>mpfr_cmp_d</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcmp_005ff"><code>mpfr_cmp_f</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcmp_005fld"><code>mpfr_cmp_ld</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcmp_005fq"><code>mpfr_cmp_q</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcmp_005fsi"><code>mpfr_cmp_si</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcmp_005fsi_005f2exp"><code>mpfr_cmp_si_2exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcmp_005fui"><code>mpfr_cmp_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcmp_005fui_005f2exp"><code>mpfr_cmp_ui_2exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcmp_005fz"><code>mpfr_cmp_z</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fconst_005fcatalan"><code>mpfr_const_catalan</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fconst_005feuler"><code>mpfr_const_euler</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fconst_005flog2"><code>mpfr_const_log2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fconst_005fpi"><code>mpfr_const_pi</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcopysign"><code>mpfr_copysign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcos"><code>mpfr_cos</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcosh"><code>mpfr_cosh</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcot"><code>mpfr_cot</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcoth"><code>mpfr_coth</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcsc"><code>mpfr_csc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcsch"><code>mpfr_csch</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcustom_005fget_005fexp"><code>mpfr_custom_get_exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Custom-Interface">Custom Interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcustom_005fget_005fkind"><code>mpfr_custom_get_kind</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Custom-Interface">Custom Interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcustom_005fget_005fsignificand"><code>mpfr_custom_get_significand</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Custom-Interface">Custom Interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcustom_005fget_005fsize"><code>mpfr_custom_get_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Custom-Interface">Custom Interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcustom_005finit"><code>mpfr_custom_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Custom-Interface">Custom Interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcustom_005finit_005fset"><code>mpfr_custom_init_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Custom-Interface">Custom Interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fcustom_005fmove"><code>mpfr_custom_move</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Custom-Interface">Custom Interface</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MPFR_005fDECL_005fINIT"><code>MPFR_DECL_INIT</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Initialization-Functions">Initialization Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdigamma"><code>mpfr_digamma</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdim"><code>mpfr_dim</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdiv"><code>mpfr_div</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdivby0_005fp"><code>mpfr_divby0_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdiv_005f2exp"><code>mpfr_div_2exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-with-MPF">Compatibility with MPF</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdiv_005f2si"><code>mpfr_div_2si</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdiv_005f2ui"><code>mpfr_div_2ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdiv_005fd"><code>mpfr_div_d</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdiv_005fq"><code>mpfr_div_q</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdiv_005fsi"><code>mpfr_div_si</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdiv_005fui"><code>mpfr_div_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdiv_005fz"><code>mpfr_div_z</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fdump"><code>mpfr_dump</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Input-and-Output-Functions">Input and Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fd_005fdiv"><code>mpfr_d_div</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fd_005fsub"><code>mpfr_d_sub</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005feint"><code>mpfr_eint</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005feq"><code>mpfr_eq</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-with-MPF">Compatibility with MPF</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fequal_005fp"><code>mpfr_equal_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ferandom"><code>mpfr_erandom</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ferangeflag_005fp"><code>mpfr_erangeflag_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ferf"><code>mpfr_erf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ferfc"><code>mpfr_erfc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fexp"><code>mpfr_exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fexp10"><code>mpfr_exp10</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fexp2"><code>mpfr_exp2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fexpm1"><code>mpfr_expm1</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffac_005fui"><code>mpfr_fac_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffits_005fintmax_005fp"><code>mpfr_fits_intmax_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffits_005fsint_005fp"><code>mpfr_fits_sint_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffits_005fslong_005fp"><code>mpfr_fits_slong_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffits_005fsshort_005fp"><code>mpfr_fits_sshort_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffits_005fuintmax_005fp"><code>mpfr_fits_uintmax_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffits_005fuint_005fp"><code>mpfr_fits_uint_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffits_005fulong_005fp"><code>mpfr_fits_ulong_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffits_005fushort_005fp"><code>mpfr_fits_ushort_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fflags_005fclear"><code>mpfr_flags_clear</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fflags_005frestore"><code>mpfr_flags_restore</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fflags_005fsave"><code>mpfr_flags_save</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fflags_005fset"><code>mpfr_flags_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fflags_005ft"><code>mpfr_flags_t</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nomenclature-and-Types">Nomenclature and Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fflags_005ftest"><code>mpfr_flags_test</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffloor"><code>mpfr_floor</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffma"><code>mpfr_fma</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffmma"><code>mpfr_fmma</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffmms"><code>mpfr_fmms</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffmod"><code>mpfr_fmod</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffmodquo"><code>mpfr_fmodquo</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffms"><code>mpfr_fms</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffpif_005fexport"><code>mpfr_fpif_export</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Input-and-Output-Functions">Input and Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffpif_005fimport"><code>mpfr_fpif_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Input-and-Output-Functions">Input and Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffprintf"><code>mpfr_fprintf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffrac"><code>mpfr_frac</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffree_005fcache"><code>mpfr_free_cache</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffree_005fcache2"><code>mpfr_free_cache2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffree_005fpool"><code>mpfr_free_pool</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffree_005fstr"><code>mpfr_free_str</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ffrexp"><code>mpfr_frexp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fgamma"><code>mpfr_gamma</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fgamma_005finc"><code>mpfr_gamma_inc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fd"><code>mpfr_get_d</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fdecimal64"><code>mpfr_get_decimal64</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fdefault_005fprec"><code>mpfr_get_default_prec</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Initialization-Functions">Initialization Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fdefault_005frounding_005fmode"><code>mpfr_get_default_rounding_mode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rounding_002dRelated-Functions">Rounding-Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fd_005f2exp"><code>mpfr_get_d_2exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005femax"><code>mpfr_get_emax</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005femax_005fmax"><code>mpfr_get_emax_max</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005femax_005fmin"><code>mpfr_get_emax_min</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005femin"><code>mpfr_get_emin</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005femin_005fmax"><code>mpfr_get_emin_max</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005femin_005fmin"><code>mpfr_get_emin_min</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fexp"><code>mpfr_get_exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005ff"><code>mpfr_get_f</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005ffloat128"><code>mpfr_get_float128</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fflt"><code>mpfr_get_flt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fld"><code>mpfr_get_ld</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fld_005f2exp"><code>mpfr_get_ld_2exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fpatches"><code>mpfr_get_patches</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fprec"><code>mpfr_get_prec</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Initialization-Functions">Initialization Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fq"><code>mpfr_get_q</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fsi"><code>mpfr_get_si</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fsj"><code>mpfr_get_sj</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fstr"><code>mpfr_get_str</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fui"><code>mpfr_get_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fuj"><code>mpfr_get_uj</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fversion"><code>mpfr_get_version</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fz"><code>mpfr_get_z</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fget_005fz_005f2exp"><code>mpfr_get_z_2exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conversion-Functions">Conversion Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fgrandom"><code>mpfr_grandom</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fgreaterequal_005fp"><code>mpfr_greaterequal_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fgreater_005fp"><code>mpfr_greater_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fhypot"><code>mpfr_hypot</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finexflag_005fp"><code>mpfr_inexflag_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finf_005fp"><code>mpfr_inf_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finit"><code>mpfr_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Initialization-Functions">Initialization Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finit2"><code>mpfr_init2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Initialization-Functions">Initialization Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finits"><code>mpfr_inits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Initialization-Functions">Initialization Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finits2"><code>mpfr_inits2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Initialization-Functions">Initialization Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finit_005fset"><code>mpfr_init_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finit_005fset_005fd"><code>mpfr_init_set_d</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finit_005fset_005ff"><code>mpfr_init_set_f</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finit_005fset_005fld"><code>mpfr_init_set_ld</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finit_005fset_005fq"><code>mpfr_init_set_q</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finit_005fset_005fsi"><code>mpfr_init_set_si</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finit_005fset_005fstr"><code>mpfr_init_set_str</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finit_005fset_005fui"><code>mpfr_init_set_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finit_005fset_005fz"><code>mpfr_init_set_z</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finp_005fstr"><code>mpfr_inp_str</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Input-and-Output-Functions">Input and Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005finteger_005fp"><code>mpfr_integer_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fj0"><code>mpfr_j0</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fj1"><code>mpfr_j1</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fjn"><code>mpfr_jn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005flessequal_005fp"><code>mpfr_lessequal_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005flessgreater_005fp"><code>mpfr_lessgreater_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fless_005fp"><code>mpfr_less_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005flgamma"><code>mpfr_lgamma</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fli2"><code>mpfr_li2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005flngamma"><code>mpfr_lngamma</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005flog"><code>mpfr_log</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005flog10"><code>mpfr_log10</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005flog1p"><code>mpfr_log1p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005flog2"><code>mpfr_log2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005flog_005fui"><code>mpfr_log_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmax"><code>mpfr_max</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmin"><code>mpfr_min</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmin_005fprec"><code>mpfr_min_prec</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rounding_002dRelated-Functions">Rounding-Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmodf"><code>mpfr_modf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmp_005fmemory_005fcleanup"><code>mpfr_mp_memory_cleanup</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmul"><code>mpfr_mul</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmul_005f2exp"><code>mpfr_mul_2exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-with-MPF">Compatibility with MPF</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmul_005f2si"><code>mpfr_mul_2si</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmul_005f2ui"><code>mpfr_mul_2ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmul_005fd"><code>mpfr_mul_d</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmul_005fq"><code>mpfr_mul_q</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmul_005fsi"><code>mpfr_mul_si</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmul_005fui"><code>mpfr_mul_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fmul_005fz"><code>mpfr_mul_z</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fnanflag_005fp"><code>mpfr_nanflag_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fnan_005fp"><code>mpfr_nan_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fneg"><code>mpfr_neg</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fnextabove"><code>mpfr_nextabove</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fnextbelow"><code>mpfr_nextbelow</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fnexttoward"><code>mpfr_nexttoward</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fnrandom"><code>mpfr_nrandom</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fnumber_005fp"><code>mpfr_number_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fout_005fstr"><code>mpfr_out_str</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Input-and-Output-Functions">Input and Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005foverflow_005fp"><code>mpfr_overflow_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fpow"><code>mpfr_pow</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fpow_005fsi"><code>mpfr_pow_si</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fpow_005fui"><code>mpfr_pow_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fpow_005fz"><code>mpfr_pow_z</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fprec_005fround"><code>mpfr_prec_round</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rounding_002dRelated-Functions">Rounding-Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fprec_005ft"><code>mpfr_prec_t</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nomenclature-and-Types">Nomenclature and Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fprintf"><code>mpfr_printf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fprint_005frnd_005fmode"><code>mpfr_print_rnd_mode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rounding_002dRelated-Functions">Rounding-Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005frec_005fsqrt"><code>mpfr_rec_sqrt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fregular_005fp"><code>mpfr_regular_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005freldiff"><code>mpfr_reldiff</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-with-MPF">Compatibility with MPF</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fremainder"><code>mpfr_remainder</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fremquo"><code>mpfr_remquo</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005frint"><code>mpfr_rint</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005frint_005fceil"><code>mpfr_rint_ceil</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005frint_005ffloor"><code>mpfr_rint_floor</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005frint_005fround"><code>mpfr_rint_round</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005frint_005froundeven"><code>mpfr_rint_roundeven</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005frint_005ftrunc"><code>mpfr_rint_trunc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005frnd_005ft"><code>mpfr_rnd_t</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nomenclature-and-Types">Nomenclature and Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005froot"><code>mpfr_root</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005frootn_005fui"><code>mpfr_rootn_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fround"><code>mpfr_round</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005froundeven"><code>mpfr_roundeven</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fround_005fnearest_005faway"><code>mpfr_round_nearest_away</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rounding_002dRelated-Functions">Rounding-Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsec"><code>mpfr_sec</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsech"><code>mpfr_sech</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset"><code>mpfr_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsetsign"><code>mpfr_setsign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fd"><code>mpfr_set_d</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fdecimal64"><code>mpfr_set_decimal64</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fdefault_005fprec"><code>mpfr_set_default_prec</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Initialization-Functions">Initialization Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fdefault_005frounding_005fmode"><code>mpfr_set_default_rounding_mode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rounding_002dRelated-Functions">Rounding-Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fdivby0"><code>mpfr_set_divby0</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005femax"><code>mpfr_set_emax</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005femin"><code>mpfr_set_emin</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005ferangeflag"><code>mpfr_set_erangeflag</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fexp"><code>mpfr_set_exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005ff"><code>mpfr_set_f</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005ffloat128"><code>mpfr_set_float128</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fflt"><code>mpfr_set_flt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005finexflag"><code>mpfr_set_inexflag</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005finf"><code>mpfr_set_inf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fld"><code>mpfr_set_ld</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fnan"><code>mpfr_set_nan</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fnanflag"><code>mpfr_set_nanflag</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005foverflow"><code>mpfr_set_overflow</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fprec"><code>mpfr_set_prec</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Initialization-Functions">Initialization Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fprec_005fraw"><code>mpfr_set_prec_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-with-MPF">Compatibility with MPF</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fq"><code>mpfr_set_q</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fsi"><code>mpfr_set_si</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fsi_005f2exp"><code>mpfr_set_si_2exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fsj"><code>mpfr_set_sj</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fsj_005f2exp"><code>mpfr_set_sj_2exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fstr"><code>mpfr_set_str</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fui"><code>mpfr_set_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fui_005f2exp"><code>mpfr_set_ui_2exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fuj"><code>mpfr_set_uj</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fuj_005f2exp"><code>mpfr_set_uj_2exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005funderflow"><code>mpfr_set_underflow</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fz"><code>mpfr_set_z</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fzero"><code>mpfr_set_zero</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fset_005fz_005f2exp"><code>mpfr_set_z_2exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsgn"><code>mpfr_sgn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsignbit"><code>mpfr_signbit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsin"><code>mpfr_sin</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsinh"><code>mpfr_sinh</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsinh_005fcosh"><code>mpfr_sinh_cosh</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsin_005fcos"><code>mpfr_sin_cos</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsi_005fdiv"><code>mpfr_si_div</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsi_005fsub"><code>mpfr_si_sub</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsnprintf"><code>mpfr_snprintf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsprintf"><code>mpfr_sprintf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsqr"><code>mpfr_sqr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsqrt"><code>mpfr_sqrt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsqrt_005fui"><code>mpfr_sqrt_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fstrtofr"><code>mpfr_strtofr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsub"><code>mpfr_sub</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsubnormalize"><code>mpfr_subnormalize</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsub_005fd"><code>mpfr_sub_d</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsub_005fq"><code>mpfr_sub_q</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsub_005fsi"><code>mpfr_sub_si</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsub_005fui"><code>mpfr_sub_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsub_005fz"><code>mpfr_sub_z</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fsum"><code>mpfr_sum</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fswap"><code>mpfr_swap</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Functions">Assignment Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ft"><code>mpfr_t</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nomenclature-and-Types">Nomenclature and Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ftan"><code>mpfr_tan</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ftanh"><code>mpfr_tanh</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005ftrunc"><code>mpfr_trunc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fui_005fdiv"><code>mpfr_ui_div</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fui_005fpow"><code>mpfr_ui_pow</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fui_005fpow_005fui"><code>mpfr_ui_pow_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fui_005fsub"><code>mpfr_ui_sub</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005funderflow_005fp"><code>mpfr_underflow_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exception-Related-Functions">Exception Related Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005funordered_005fp"><code>mpfr_unordered_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005furandom"><code>mpfr_urandom</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005furandomb"><code>mpfr_urandomb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fvasprintf"><code>mpfr_vasprintf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MPFR_005fVERSION"><code>MPFR_VERSION</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MPFR_005fVERSION_005fMAJOR"><code>MPFR_VERSION_MAJOR</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MPFR_005fVERSION_005fMINOR"><code>MPFR_VERSION_MINOR</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MPFR_005fVERSION_005fNUM"><code>MPFR_VERSION_NUM</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MPFR_005fVERSION_005fPATCHLEVEL"><code>MPFR_VERSION_PATCHLEVEL</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MPFR_005fVERSION_005fSTRING"><code>MPFR_VERSION_STRING</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fvfprintf"><code>mpfr_vfprintf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fvprintf"><code>mpfr_vprintf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fvsnprintf"><code>mpfr_vsnprintf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fvsprintf"><code>mpfr_vsprintf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formatted-Output-Functions">Formatted Output Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fy0"><code>mpfr_y0</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fy1"><code>mpfr_y1</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fyn"><code>mpfr_yn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fzero_005fp"><code>mpfr_zero_p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Functions">Comparison Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fzeta"><code>mpfr_zeta</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fzeta_005fui"><code>mpfr_zeta_ui</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Special-Functions">Special Functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mpfr_005fz_005fsub"><code>mpfr_z_sub</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Function-and-Type-Index_fn_letter-M"><b>M</b></a>
 &nbsp; 
</td></tr></table>

<hr>



</body>
</html>
