*** set_str_raw.c	2001/01/11 16:45:01	1.19
--- set_str_raw.c	2001/01/11 17:25:28	1.20
***************
*** 1,6 ****
  /* mpfr_set_str_raw -- set a floating-point number from a binary string
  
! Copyright (C) 1999 Free Software Foundation.
  
  This file is part of the MPFR Library.
  
--- 1,6 ----
  /* mpfr_set_str_raw -- set a floating-point number from a binary string
  
! Copyright (C) 1999-2001 Free Software Foundation.
  
  This file is part of the MPFR Library.
  
***************
*** 98,130 ****
    else expn=k;
  
    endstr2 = str2;
!   *str2 = (char) 0; /* end of string */
!   l = (strlen(str0) - 1) / BITS_PER_MP_LIMB + 1; str2 = str0;
!   if (l > xsize) {
!     fprintf (stderr, "Error: mantissa larger than precision of destination variable in mpfr_set_str_raw\n");
!     exit (1);
    }
! 
!   /* str2[0]..endstr2[-1] contains the mantissa */
!   for (k = 1; k <= l; k++)
!     {
!       j = 0; 
!       xp[xsize - k] = 0; 
!       while (str2<endstr2 && j < BITS_PER_MP_LIMB)
! 	{
! 	  xp[xsize - k] = (xp[xsize - k] << 1) + (*str2 - '0'); 
! 	  str2++; j++; 
! 	}
!       xp[xsize - k] <<= (BITS_PER_MP_LIMB - j); 
      }
  
!   for (; k <= xsize; k++) { xp[xsize - k] = 0; }
  
!   count_leading_zeros(cnt, xp[xsize - 1]); 
!   if (cnt) mpn_lshift(xp, xp, xsize, cnt); 
  
!   MPFR_EXP(x) = expn - cnt; 
!   MPFR_SIZE(x) = xsize; if (negative) MPFR_CHANGE_SIGN(x);
  
    (*__gmp_free_func) (str0, alloc);
    
--- 98,137 ----
    else expn=k;
  
    endstr2 = str2;
!   l = endstr2 - str0; /* length of mantissa */
!   if (l == 0) { /* input is zero */
!     MPFR_SET_ZERO(x);
    }
!   else {
!     l = (l-1) / BITS_PER_MP_LIMB + 1;
!     str2 = str0;
! 
!     if (l > xsize) {
!       fprintf (stderr, "Error: mantissa larger than precision of destination variable in mpfr_set_str_raw\n");
!       exit (1);
      }
  
!     /* str2[0]..endstr2[-1] contains the mantissa */
!     for (k = 1; k <= l; k++)
!       {
! 	j = 0; 
! 	xp[xsize - k] = 0; 
! 	while (str2<endstr2 && j < BITS_PER_MP_LIMB)
! 	  {
! 	    xp[xsize - k] = (xp[xsize - k] << 1) + (*str2 - '0'); 
! 	    str2++; j++; 
! 	  }
! 	xp[xsize - k] <<= (BITS_PER_MP_LIMB - j); 
!       }
  
!     for (; k <= xsize; k++) { xp[xsize - k] = 0; }
  
!     count_leading_zeros(cnt, xp[xsize - 1]); 
!     if (cnt) mpn_lshift(xp, xp, xsize, cnt); 
! 
!     MPFR_EXP(x) = expn - cnt; 
!     MPFR_SIZE(x) = xsize; if (negative) MPFR_CHANGE_SIGN(x);
!   }
  
    (*__gmp_free_func) (str0, alloc);
