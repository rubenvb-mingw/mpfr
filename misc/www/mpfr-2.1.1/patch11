diff -Naur mpfr-2.1.1-p10/strtofr.c mpfr-2.1.1-p11/strtofr.c
--- mpfr-2.1.1-p10/strtofr.c	2005-01-27 14:47:26.000000000 +0000
+++ mpfr-2.1.1-p11/strtofr.c	2005-07-11 17:38:34.000000000 +0000
@@ -1,6 +1,6 @@
 /* mpfr_strtofr -- set a floating-point number from a string
 
-Copyright 2004 Free Software Foundation, Inc.
+Copyright 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -186,6 +186,27 @@
   return MPFR_LIKELY (digit < base) ? digit : -1;
 }
 
+/* Compatible with any locale, but one still assumes that 'a', 'b', 'c',
+   ..., 'z', and 'A', 'B', 'C', ..., 'Z' are consecutive values (like
+   in any ASCII-based character set). */
+static int
+fast_casecmp (const char *s1, const char *s2)
+{
+  unsigned char c1, c2;
+
+  do
+    {
+      c2 = *(const unsigned char *) s2++;
+      if (c2 == '\0')
+        return 0;
+      c1 = *(const unsigned char *) s1++;
+      if (c1 >= 'A' && c1 <= 'Z')
+        c1 = c1 - 'A' + 'a';
+    }
+  while (c1 == c2);
+  return 1;
+}
+
 /* Parse a string and fill pstr.
    Return the advanced ptr too.
    It returns:
@@ -214,12 +235,12 @@
   while (isspace((unsigned char) *str)) str++;
 
   /* Can be case-insensitive NAN */
-  if (strncasecmp (str, "@nan@", 5) == 0)
+  if (fast_casecmp (str, "@nan@") == 0)
     {
       str += 5;
       goto set_nan;
     }
-  if (base <= 16 && strncasecmp (str, "nan", 3) == 0)
+  if (base <= 16 && fast_casecmp (str, "nan") == 0)
     {
       str += 3;
     set_nan:
@@ -249,17 +270,17 @@
     str++;
 
   /* Can be case-insensitive INF */
-  if (strncasecmp (str, "@inf@", 5) == 0)
+  if (fast_casecmp (str, "@inf@") == 0)
     {
       str += 5;
       goto set_inf;
     }
-  if (base <= 16 && strncasecmp (str, "infinity", 8) == 0)
+  if (base <= 16 && fast_casecmp (str, "infinity") == 0)
     {
       str += 8;
       goto set_inf;
     }
-  if (base <= 16 && strncasecmp (str, "inf", 3) == 0)
+  if (base <= 16 && fast_casecmp (str, "inf") == 0)
     {
       str += 3;
     set_inf:
