<html lang="en">
<head>
<title>MPFR 2.2.0</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="description" content="How to install and use MPFR, a library for reliable multiple precision floating-point arithmetic, version 2.2.0.">
<meta name="generator" content="makeinfo 4.7">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version 2.2.0.

Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
2003, 2004, 2005 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being ``A GNU Manual'', and with the Back-Cover
Texts being ``You have freedom to copy and modify this GNU Manual, like GNU
software''.  A copy of the license is included in *Note GNU Free Documentation License::.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc { font-variant:small-caps }
  span.roman { font-family: serif; font-weight: normal; } 
--></style>
</head>
<body>
<div class="node">
<p><hr>
<a name="Top"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Copying">Copying</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>
<br>
</div>

<h2 class="unnumbered">MPFR</h2>

   <p>This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version 2.2.0.

   <p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
2003, 2004, 2005 Free Software Foundation, Inc.

   <p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being &ldquo;A GNU Manual&rdquo;, and with the Back-Cover
Texts being &ldquo;You have freedom to copy and modify this GNU Manual, like GNU
software&rdquo;.  A copy of the license is included in <a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>.
   <pre class="sp">

</pre>

<!-- Don't bother with contents for html, the menus seem adequate. -->
<ul class="menu">
<li><a accesskey="1" href="#Copying">Copying</a>:                      MPFR Copying Conditions (LGPL). 
<li><a accesskey="2" href="#Introduction-to-MPFR">Introduction to MPFR</a>:         Brief introduction to MPFR. 
<li><a accesskey="3" href="#Installing-MPFR">Installing MPFR</a>:              How to configure and compile the MPFR library. 
<li><a accesskey="4" href="#Reporting-Bugs">Reporting Bugs</a>:               How to usefully report bugs. 
<li><a accesskey="5" href="#MPFR-Basics">MPFR Basics</a>:                  What every MPFR user should now. 
<li><a accesskey="6" href="#MPFR-Interface">MPFR Interface</a>:               MPFR functions and macros. 
<li><a accesskey="7" href="#Contributors">Contributors</a>
<li><a accesskey="8" href="#References">References</a>
<li><a accesskey="9" href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>
<li><a href="#Concept-Index">Concept Index</a>
<li><a href="#Function-Index">Function Index</a>
</ul>

<!-- @m{T,N} is $T$ in tex or @math{N} otherwise.  This is an easy way to give -->
<!-- different forms for math in tex and info.  Commas in N or T don't work, -->
<!-- but @C{} can be used instead.  \, works in info but not in tex. -->
<!-- Usage: @GMPabs{x} -->
<!-- Give either |x| in tex, or abs(x) in info or html. -->
<!-- Usage: @GMPtimes{} -->
<!-- Give either \times or the word "times". -->
<!-- New math operators. -->
<!-- @abs{} can be used in both tex and info, or just \abs in tex. -->
<!-- @times{} made available as a "*" in info and html (already works in tex). -->
<!-- Math operators already available in tex, made available in info too. -->
<!-- For example @log{} can be used in both tex and info. -->
<!-- @pom{} definition -->
<div class="node">
<p><hr>
<a name="Copying"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction-to-MPFR">Introduction to MPFR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<!-- node-name, next, previous,  up -->
<h2 class="unnumbered">MPFR Copying Conditions</h2>

<p><a name="index-Copying-conditions-1"></a><a name="index-Conditions-for-copying-MPFR-2"></a>
This library is <dfn>free</dfn>; this means that everyone is free to use it and
free to redistribute it on a free basis.  The library is not in the public
domain; it is copyrighted and there are restrictions on its distribution, but
these restrictions are designed to permit everything that a good cooperating
citizen would want to do.  What is not allowed is to try to prevent others
from further sharing any version of this library that they might get from
you.

   <p>Specifically, we want to make sure that you have the right to give away copies
of the library, that you receive source code or else can get it if you want
it, that you can change this library or use pieces of it in new free programs,
and that you know you can do these things.

   <p>To make sure that everyone has such rights, we have to forbid you to deprive
anyone else of these rights.  For example, if you distribute copies of the
MPFR library, you must give the recipients all the rights that you have.  You
must make sure that they, too, receive or can get the source code.  And you
must tell them their rights.

   <p>Also, for our own protection, we must make certain that everyone finds out
that there is no warranty for the MPFR library.  If it is modified by
someone else and passed on, we want their recipients to know that what they
have is not what we distributed, so that any problems introduced by others
will not reflect on our reputation.

   <p>The precise conditions of the license for the MPFR library are found in the
Lesser General Public License that accompanies the source code. 
See the file COPYING.LIB.

<div class="node">
<p><hr>
<a name="Introduction-to-MPFR"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Installing-MPFR">Installing MPFR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Copying">Copying</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">1 Introduction to MPFR</h2>

<p>MPFR is a portable library written in C for arbitrary precision arithmetic
on floating-point numbers. It is based on the GNU MP library. 
It aims to extend the class of floating-point numbers provided by the
GNU MP library by a precise semantics. The main differences
with the <code>mpf</code> class from GNU MP are:

     <ul>
<li>the <code>mpfr</code> code is portable, i.e. the result of any operation
does not depend (or should not) on the machine word size
<code>mp_bits_per_limb</code> (32 or 64 on most machines);
<li>the precision in bits can be set exactly to any valid value
for each variable (including very small precision);
<li><code>mpfr</code> provides the four rounding modes from the IEEE 754-1985
standard. 
</ul>

   <p>In particular, with a precision of 53 bits, <code>mpfr</code> should be able
to exactly reproduce all computations with double-precision machine
floating-point
numbers (<code>double</code> type in C), except the default exponent range
is much wider and subnormal numbers are not implemented but can be emulated.

   <p>This version of MPFR is released under the GNU Lesser General Public
License. 
It is permitted to link MPFR to non-free programs, as long as when
distributing them the MPFR source code and a means to re-link with a
modified MPFR library is provided.

<h3 class="section">1.1 How to use this Manual</h3>

<p>Everyone should read <a href="#MPFR-Basics">MPFR Basics</a>.  If you need to install the library
yourself, you need to read <a href="#Installing-MPFR">Installing MPFR</a>, too.

   <p>The rest of the manual can be used for later reference, although it is
probably a good idea to glance through it.

<div class="node">
<p><hr>
<a name="Installing-MPFR"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Reporting-Bugs">Reporting Bugs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-to-MPFR">Introduction to MPFR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">2 Installing MPFR</h2>

<p><a name="index-Installation-3"></a>

<h3 class="section">2.1 How to install</h3>

<p>Here are the steps needed to install the library on Unix systems
(more details are provided in the <span class="file">INSTALL</span> file):

     <ol type=1 start=1>
<li>To build MPFR, you first have to install GNU MP
(version 4.1 or higher) on your computer. 
You need a C compiler, preferably GCC, but any reasonable compiler should
work.  And you need a standard Unix <span class="samp">make</span> program, plus some other
standard Unix utility programs.

     <li>In the MPFR build directory, type
<span class="samp">./configure</span>

     <p>This will prepare the build and setup the options according to your system. 
If you get error messages, you might check that you use the same compiler
and compile options as for GNU MP (see the <span class="file">INSTALL</span> file).

     <li><span class="samp">make</span>

     <p>This will compile MPFR, and create a library archive file <span class="file">libmpfr.a</span>. 
A dynamic library may be produced too (see configure).

     <li><span class="samp">make check</span>

     <p>This will make sure MPFR was built correctly. 
If you get error messages, please
report this to <span class="samp">mpfr@loria.fr</span>.  (See <a href="#Reporting-Bugs">Reporting Bugs</a>, for
information on what to include in useful bug reports.)

     <li><span class="samp">make install</span>

     <p>This will copy the files <span class="file">mpfr.h</span> and <span class="file">mpf2mpfr.h</span> to the directory
<span class="file">/usr/local/include</span>, the file <span class="file">libmpfr.a</span> to the directory
<span class="file">/usr/local/lib</span>, and the file <span class="file">mpfr.info</span> to the directory
<span class="file">/usr/local/info</span> (or if you passed the <span class="samp">--prefix</span> option to
 <span class="file">configure</span>, using the prefix directory given as argument to
<span class="samp">--prefix</span> instead of <span class="file">/usr/local</span>).
        </ol>

<h3 class="section">2.2 Other make targets</h3>

<p>There are some other useful make targets:

     <ul>
<li><span class="samp">mpfr.info</span> or <span class="samp">info</span>

     <p>Create an info version of the manual, in <span class="file">mpfr.info</span>.

     <li><span class="samp">mpfr.dvi</span> or <span class="samp">dvi</span>

     <p>Create a DVI version of the manual, in <span class="file">mpfr.dvi</span>.

     <li><span class="samp">mpfr.ps</span>

     <p>Create a Postscript version of the manual, in <span class="file">mpfr.ps</span>.

     <!-- @item -->
<!-- @samp{html} -->
<!-- Create a HTML version of the manual, in @file{mpfr.html}. -->
<li><span class="samp">clean</span>

     <p>Delete all object files and archive files, but not the configuration files.

     <li><span class="samp">distclean</span>

     <p>Delete all files not included in the distribution.

     <li><span class="samp">uninstall</span>

     <p>Delete all files copied by <span class="samp">make install</span>. 
</ul>

<h3 class="section">2.3 Known Build Problems</h3>

<p>MPFR suffers from all bugs from the GNU MP library, plus many more.

   <p>Please report other problems to <span class="samp">mpfr@loria.fr</span>. 
See <a href="#Reporting-Bugs">Reporting Bugs</a>. 
Some bug fixes are available on the MPFR web page
<a href="http://www.mpfr.org/">http://www.mpfr.org/</a>.

<h3 class="section">2.4 Getting the Latest Version of MPFR</h3>

<p>The latest version of MPFR is available from <a href="http://www.mpfr.org/">http://www.mpfr.org/</a>.

<div class="node">
<p><hr>
<a name="Reporting-Bugs"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#MPFR-Basics">MPFR Basics</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installing-MPFR">Installing MPFR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">3 Reporting Bugs</h2>

<p><a name="index-Reporting-bugs-4"></a>
If you think you have found a bug in the MPFR library, first have a look on the
MPFR web page <a href="http://www.mpfr.org/">http://www.mpfr.org/</a>: perhaps this bug is already known,
in which case you may find there a workaround for it. 
Otherwise, please investigate
and report it. We have made this library available to you, and it is not to ask
too much from you, to ask you to report the bugs that you find.

   <p>There are a few things you should think about when you put your bug report
together.

   <p>You have to send us a test case that makes it possible for us to reproduce the
bug.  Include instructions on how to run the test case.

   <p>You also have to explain what is wrong; if you get a crash, or if the results
printed are incorrect and in that case, in what way.

   <p>Please include compiler version information
in your bug report.  This can be extracted using <span class="samp">cc -V</span> on some
machines, or,
if you're using gcc, <span class="samp">gcc -v</span>.  Also, include the output from <span class="samp">uname
-a</span>.

   <p>If your bug report is good, we will do our best to help you to get a corrected
version of the library; if the bug report is poor, we won't do anything about
it (aside of chiding you to send better bug reports).

   <p>Send your bug report to: <span class="samp">mpfr@loria.fr</span>.

   <p>If you think something in this manual is unclear, or downright incorrect, or if
the language needs to be improved, please send a note to the same address.

<div class="node">
<p><hr>
<a name="MPFR-Basics"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#MPFR-Interface">MPFR Interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reporting-Bugs">Reporting Bugs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">4 MPFR Basics</h2>

<p><a name="index-_0040file_007bmpfr_002eh_007d-5"></a>All declarations needed to use MPFR are collected in the include file
<span class="file">mpfr.h</span>.  It is designed to work with both C and C++ compilers. 
You should include that file in any program using the MPFR library:
<pre class="verbatim">
#include &lt;mpfr.h>
</pre>

<h3 class="section">4.1 Nomenclature and Types</h3>

<p><a name="index-Floating_002dpoint-number-6"></a><a name="index-_0040code_007bmpfr_005ft_007d-7"></a>A <dfn>floating-point number</dfn> or <dfn>float</dfn> for short, is an arbitrary
precision mantissa with a limited precision exponent. The C data type
for such objects is <code>mpfr_t</code>. A floating-point number can have
three special values: Not-a-Number (NaN) or plus or minus Infinity. NaN
represents an uninitialized object, the result of an invalid operation
(like 0 divided by 0), or a value that cannot be determined (like
+Infinity minus +Infinity). Moreover, like in the IEEE 754-1985 standard,
zero is signed, i.e. there are both +0 and &minus;0; the behavior
is the same as in the IEEE 754-1985 standard and it is generalized to
the other functions supported by MPFR.

   <p><a name="index-Precision-8"></a><a name="index-_0040code_007bmp_005fprec_005ft_007d-9"></a>The <dfn>precision</dfn> is the number of bits used to represent the mantissa
of a floating-point number;
the corresponding C data type is <code>mp_prec_t</code>. 
The precision can be any integer between <code>MPFR_PREC_MIN</code> and
<code>MPFR_PREC_MAX</code>. In the current implementation, <code>MPFR_PREC_MIN</code>
is equal to 2.

   <p><a name="index-Rounding-Modes-10"></a><a name="index-_0040code_007bmp_005frnd_005ft_007d-11"></a>The <dfn>rounding mode</dfn> specifies the way to round the result of a
floating-point operation, in case the exact result can not be represented
exactly in the destination mantissa;
the corresponding C data type is <code>mp_rnd_t</code>.

   <p><a name="index-Limb-12"></a><!-- @tindex @code{mp_limb_t} -->
A <dfn>limb</dfn> means the part of a multi-precision number that fits in a single
word.  (We chose this word because a limb of the human body is analogous to a
digit, only larger, and containing several digits.)  Normally a limb contains
32 or 64 bits.  The C data type for a limb is <code>mp_limb_t</code>.

<h3 class="section">4.2 Function Classes</h3>

<p>There is only one class of functions in the MPFR library:

     <ol type=1 start=1>
<li>Functions for floating-point arithmetic, with names beginning with
<code>mpfr_</code>.  The associated type is <code>mpfr_t</code>.
        </ol>

<h3 class="section">4.3 MPFR Variable Conventions</h3>

<p>As a general rule, all MPFR functions expect output arguments before input
arguments.  This notation is based on an analogy with the assignment operator.

   <p>MPFR allows you to use the same variable for both input and output in the same
expression.  For example, the main function for floating-point multiplication,
<code>mpfr_mul</code>, can be used like this: <code>mpfr_mul (x, x, x, rnd_mode)</code>. 
This
computes the square of <var>x</var> with rounding mode <code>rnd_mode</code>
and puts the result back in <var>x</var>.

   <p>Before you can assign to an MPFR variable, you need to initialize it by calling
one of the special initialization functions.  When you're done with a
variable, you need to clear it out, using one of the functions for that
purpose.

   <p>A variable should only be initialized once, or at least cleared out between
each initialization.  After a variable has been initialized, it may be
assigned to any number of times.

   <p>For efficiency reasons, avoid to initialize and clear out a variable in loops. 
Instead, initialize it before entering the loop, and clear it out after the
loop has exited.

   <p>You don't need to be concerned about allocating additional space for MPFR
variables, since any variable has a mantissa of fixed size. 
Hence unless you change its precision, or clear and reinitialize it,
a floating-point variable will have the same allocated space during all its
life.

<h3 class="section">4.4 Rounding modes.</h3>

<p>The following four rounding modes are supported:

     <ul>
<li><code>GMP_RNDN</code>: round to nearest
<li><code>GMP_RNDZ</code>: round towards zero
<li><code>GMP_RNDU</code>: round towards plus infinity
<li><code>GMP_RNDD</code>: round towards minus infinity
</ul>

   <p>The <span class="samp">round to nearest</span> mode works as in the IEEE 754-1985 standard: in
case the number to be rounded lies exactly in the middle of two representable
numbers, it is rounded to the one with the least significant bit set to zero. 
For example, the number 5/2, which is represented by (10.1) in binary, is
rounded to (10.0)=2 with a precision of two bits, and not to (11.0)=3. 
This rule avoids the <dfn>drift</dfn> phenomenon mentioned by Knuth in volume 2
of The Art of Computer Programming (Section 4.2.2).

   <p>Most MPFR functions take as first argument the destination variable, as
second and following arguments the input variables, as last argument a
rounding mode, and have a return value of type <code>int</code>, called the
<dfn>ternary value</dfn>. The value stored in the destination variable is
exactly rounded, i.e. MPFR behaves as if it computed the result with
an infinite precision, then rounded it to the precision of this variable. 
The input variables are regarded as exact (in particular, their precision
does not affect the result).

   <p>Unless documented otherwise, functions returning an <code>int</code> return
a ternary value. 
If the ternary value is zero, it means that the value stored in the
destination variable is the exact result of the corresponding mathematical
function. If the ternary value is positive (resp. negative), it means
the value stored in the destination variable is greater (resp. lower)
than the exact result. For example with the <code>GMP_RNDU</code> rounding mode,
the ternary value is usually positive, except when the result is exact, in
which case it is zero. In the case of an infinite result, it is considered
as inexact when it was obtained by overflow, and exact otherwise. A NaN
result (Not-a-Number) always corresponds to an exact return value. 
The opposite of a returned ternary value is guaranteed to be representable
in an <code>int</code>.

   <p>Unless documented otherwise, functions returning a <code>1</code>
(or any other value specified in this manual)
for special cases (like <code>acos(0)</code>) should return an overflow or
an underflow if <code>1</code> is not representable in the current exponent range.

<div class="node">
<p><hr>
<a name="MPFR-Interface"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Contributors">Contributors</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#MPFR-Basics">MPFR Basics</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">5 MPFR Interface</h2>

<p><a name="index-Floating_002dpoint-functions-13"></a><a name="index-Float-functions-14"></a>
The floating-point functions expect arguments of type <code>mpfr_t</code>.

   <p>The MPFR floating-point functions have an interface that is similar to the
GNU MP
integer functions.  The function prefix for floating-point operations is
<code>mpfr_</code>.

   <p>There is one significant characteristic of floating-point numbers that has
motivated a difference between this function class and other GNU MP function
classes: the inherent inexactness of floating-point arithmetic.  The user has
to specify the precision for each variable.  A computation that assigns a
variable will take place with the precision of the assigned variable; the
cost of that computation should not depend from the
precision of variables used as input (on average).

   <p><a name="index-Precision-15"></a>The semantics of a calculation in MPFR is specified as follows: Compute the
requested operation exactly (with &ldquo;infinite accuracy&rdquo;), and round the result
to the precision of the destination variable, with the given rounding mode. 
The MPFR floating-point functions are intended to be a smooth extension
of the IEEE 754-1985 arithmetic. The results obtained on one computer should
not differ from the results obtained on a computer with a different word size.

   <p><a name="index-Accuracy-16"></a>MPFR does not keep track of the accuracy of a computation. This is left
to the user or to a higher layer. 
As a consequence, if two variables are used to store
only a few significant bits, and their product is stored in a variable with large
precision, then MPFR will still compute the result with full precision.

<ul class="menu">
<li><a accesskey="1" href="#Initialization-Functions">Initialization Functions</a>
<li><a accesskey="2" href="#Assignment-Functions">Assignment Functions</a>
<li><a accesskey="3" href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a>
<li><a accesskey="4" href="#Conversion-Functions">Conversion Functions</a>
<li><a accesskey="5" href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a>
<li><a accesskey="6" href="#Comparison-Functions">Comparison Functions</a>
<li><a accesskey="7" href="#Special-Functions">Special Functions</a>
<li><a accesskey="8" href="#Input-and-Output-Functions">Input and Output Functions</a>
<li><a accesskey="9" href="#Integer-Related-Functions">Integer Related Functions</a>
<li><a href="#Miscellaneous-Functions">Miscellaneous Functions</a>
<li><a href="#Rounding-Modes">Rounding Modes</a>
<li><a href="#Exceptions">Exceptions</a>
<li><a href="#Advanced-Functions">Advanced Functions</a>
<li><a href="#Compatibility-with-MPF">Compatibility with MPF</a>
<li><a href="#Custom-interface">Custom interface</a>
<li><a href="#Internals">Internals</a>
</ul>

<div class="node">
<p><hr>
<a name="Initialization-Functions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Assignment-Functions">Assignment Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#MPFR-Interface">MPFR Interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<p><a name="index-Initialization-functions-17"></a>

<h3 class="section">5.1 Initialization Functions</h3>

<p>An <code>mpfr_t</code> object must be initialized before storing the first value in
it.  The functions <code>mpfr_init</code> and <code>mpfr_init2</code> are used for that
purpose.

<div class="defun">
&mdash; Function: void <b>mpfr_init2</b> (<var>mpfr_t x, mp_prec_t prec</var>)<var><a name="index-mpfr_005finit2-18"></a></var><br>
<blockquote><p>Initialize <var>x</var>, set its precision to be <strong>exactly</strong>
<var>prec</var> bits and its value to NaN. (Warning: the corresponding
<code>mpf</code> functions initialize to zero instead.)

        <p>Normally, a variable should be initialized once only or at
least be cleared, using <code>mpfr_clear</code>, between initializations. 
To change the precision of a variable which has already been initialized,
use <code>mpfr_set_prec</code>. 
The precision <var>prec</var> must be an integer between <code>MPFR_PREC_MIN</code> and
<code>MPFR_PREC_MAX</code> (otherwise the behavior is undefined). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_clear</b> (<var>mpfr_t x</var>)<var><a name="index-mpfr_005fclear-19"></a></var><br>
<blockquote><p>Free the space occupied by <var>x</var>.  Make sure to call this function for all
<code>mpfr_t</code> variables when you are done with them. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_init</b> (<var>mpfr_t x</var>)<var><a name="index-mpfr_005finit-20"></a></var><br>
<blockquote><p>Initialize <var>x</var> and set its value to NaN.

        <p>Normally, a variable should be initialized once only
or at least be cleared, using <code>mpfr_clear</code>, between initializations.  The
precision of <var>x</var> is the default precision, which can be changed
by a call to <code>mpfr_set_default_prec</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_set_default_prec</b> (<var>mp_prec_t prec</var>)<var><a name="index-mpfr_005fset_005fdefault_005fprec-21"></a></var><br>
<blockquote><p>Set the default precision to be <strong>exactly</strong> <var>prec</var> bits.  The
precision of a variable means the number of bits used to store its mantissa. 
All
subsequent calls to <code>mpfr_init</code> will use this precision, but previously
initialized variables are unaffected. 
This default precision is set to 53 bits initially. 
The precision can be any integer between <code>MPFR_PREC_MIN</code> and
<code>MPFR_PREC_MAX</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: mp_prec_t <b>mpfr_get_default_prec</b> (<var>void</var>)<var><a name="index-mpfr_005fget_005fdefault_005fprec-22"></a></var><br>
<blockquote><p>Return the default MPFR precision in bits. 
</p></blockquote></div>

   <p>Here is an example on how to initialize floating-point variables:

<pre class="example">     {
       mpfr_t x, y;
       mpfr_init (x);			/* use default precision */
       mpfr_init2 (y, 256);		/* precision <em>exactly</em> 256 bits */
       ...
       /* When the program is about to exit, do ... */
       mpfr_clear (x);
       mpfr_clear (y);
     }
</pre>
   <p>The following functions are useful for changing the precision during a
calculation.  A typical use would be for adjusting the precision gradually in
iterative algorithms like Newton-Raphson, making the computation precision
closely match the actual accurate part of the numbers.

<div class="defun">
&mdash; Function: void <b>mpfr_set_prec</b> (<var>mpfr_t x, mp_prec_t prec</var>)<var><a name="index-mpfr_005fset_005fprec-23"></a></var><br>
<blockquote><p>Reset the precision of <var>x</var> to be <strong>exactly</strong> <var>prec</var> bits,
and set its value to NaN. 
The previous value stored in <var>x</var> is lost. It is equivalent to
a call to <code>mpfr_clear(x)</code> followed by a call to
<code>mpfr_init2(x, prec)</code>, but more efficient as no allocation is done in
case the current allocated space for the mantissa of <var>x</var> is enough. 
The precision <var>prec</var> can be any integer between <code>MPFR_PREC_MIN</code> and
<code>MPFR_PREC_MAX</code>.

        <p>In case you want to keep the previous value stored in <var>x</var>,
use <code>mpfr_prec_round</code> instead. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: mp_prec_t <b>mpfr_get_prec</b> (<var>mpfr_t x</var>)<var><a name="index-mpfr_005fget_005fprec-24"></a></var><br>
<blockquote><p>Return the precision actually used for assignments of <var>x</var>, i.e. the
number of bits used to store its mantissa. 
</p></blockquote></div>

<div class="node">
<p><hr>
<a name="Assignment-Functions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Initialization-Functions">Initialization Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<p><a name="index-Assignment-functions-25"></a>

<h3 class="section">5.2 Assignment Functions</h3>

<p>These functions assign new values to already initialized floats
(see <a href="#Initialization-Functions">Initialization Functions</a>). When using any functions using
<code>intmax_t</code>, you must include <code>&lt;stdint.h&gt;</code> or <code>&lt;inttypes.h&gt;</code>
before <span class="file">mpfr.h</span>, to allow <span class="file">mpfr.h</span> to define prototypes for
these functions.

<div class="defun">
&mdash; Function: int <b>mpfr_set</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset-26"></a></var><br>
&mdash; Function: int <b>mpfr_set_ui</b> (<var>mpfr_t rop, unsigned long int op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fui-27"></a></var><br>
&mdash; Function: int <b>mpfr_set_si</b> (<var>mpfr_t rop, long int op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fsi-28"></a></var><br>
&mdash; Function: int <b>mpfr_set_uj</b> (<var>mpfr_t rop, uintmax_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fuj-29"></a></var><br>
&mdash; Function: int <b>mpfr_set_sj</b> (<var>mpfr_t rop, intmax_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fsj-30"></a></var><br>
&mdash; Function: int <b>mpfr_set_d</b> (<var>mpfr_t rop, double op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fd-31"></a></var><br>
&mdash; Function: int <b>mpfr_set_ld</b> (<var>mpfr_t rop, long double op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fld-32"></a></var><br>
&mdash; Function: int <b>mpfr_set_z</b> (<var>mpfr_t rop, mpz_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fz-33"></a></var><br>
&mdash; Function: int <b>mpfr_set_q</b> (<var>mpfr_t rop, mpq_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fq-34"></a></var><br>
&mdash; Function: int <b>mpfr_set_f</b> (<var>mpfr_t rop, mpf_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005ff-35"></a></var><br>
<blockquote><p>Set the value of <var>rop</var> from <var>op</var>, rounded
towards the given direction <var>rnd</var>. 
Note that the input 0 is converted to +0 by <code>mpfr_set_ui</code>,
<code>mpfr_set_si</code>, <code>mpfr_set_sj</code>, <code>mpfr_set_uj</code>,
<code>mpfr_set_z</code>, <code>mpfr_set_q</code> and
<code>mpfr_set_f</code>, regardless of the rounding mode. 
If the system doesn't support the IEEE-754 standard, <code>mpfr_set_d</code> and
<code>mpfr_set_ld</code> might not preserve the signed zeros. 
<code>mpfr_set_q</code> might not be able to work if the numerator (or the
denominator) can not be representable as a <code>mpfr_t</code>.

        <p>Note: If you want to store a floating-point constant to a <code>mpfr_t</code>,
you should use <code>mpfr_set_str</code> instead of <code>mpfr_set_d</code> or
<code>mpfr_set_ld</code>. Otherwise the floating-point constant will be first
converted into a reduced-precision (e.g., 53-bit) binary number before
MPFR can work with it. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_set_ui_2exp</b> (<var>mpfr_t rop, unsigned long int op, mp_exp_t e, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fui_005f2exp-36"></a></var><br>
&mdash; Function: int <b>mpfr_set_si_2exp</b> (<var>mpfr_t rop, long int op, mp_exp_t e, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fsi_005f2exp-37"></a></var><br>
&mdash; Function: int <b>mpfr_set_uj_2exp</b> (<var>mpfr_t rop, uintmax_t op, intmax_t e, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fuj_005f2exp-38"></a></var><br>
&mdash; Function: int <b>mpfr_set_sj_2exp</b> (<var>mpfr_t rop, intmax_t op, intmax_t e, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fsj_005f2exp-39"></a></var><br>
<blockquote><p>Set the value of <var>rop</var> from <var>op</var> multiplied by
two to the power <var>e</var>, rounded towards the given direction <var>rnd</var>. 
Note that the input 0 is converted to +0. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_set_str</b> (<var>mpfr_t rop, const char *s, int base, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fstr-40"></a></var><br>
<blockquote><p>Set <var>rop</var> to the value of the whole string <var>s</var> in base <var>base</var>,
rounded in the direction <var>rnd</var>. 
See the documentation of <code>mpfr_strtofr</code> for a detailed description
of the valid string formats. 
<!-- Additionally, special values -->
<!-- @code{@@NaN@@}, @code{@@Inf@@}, @code{+@@Inf@@} and @code{-@@Inf@@}, -->
<!-- all case insensitive, without leading whitespace and possibly followed by -->
<!-- other characters, are accepted too (it may change). -->
This function returns 0 if the entire string up to the final null character
is a valid number in base <var>base</var>; otherwise it returns &minus;1, and
<var>rop</var> may have changed. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_strtofr</b> (<var>mpfr_t rop, const char *nptr, char **endptr, int base, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fstrtofr-41"></a></var><br>
<blockquote>
<p>Read a floating-point number from a string <var>nptr</var> in base <var>base</var>,
rounded in the direction <var>rnd</var>. If successful, the
result is stored in <var>rop</var> and <code>*</code><var>endptr</var> points to the
character just after those parsed. If <var>str</var> doesn't start with a
valid number then <var>rop</var> is set to zero and the value of <var>nptr</var>
is stored in the location referenced by <var>endptr</var>.

        <p>Parsing follows the standard C <code>strtod</code> function. This means optional
leading whitespace, an optional <code>+</code> or <code>-</code>, mantissa digits with
an optional decimal point, and an
optional exponent consisting of an <code>e</code> or <code>E</code> (if
<var>base</var> &lt;= 10) or <code>@</code>, an optional sign, and digits. 
The decimal point can be either the one defined by the current locale or
the period (the first one is accepted for consistency with the C standard
and the practice, the second one is accepted to allow the programmer to
provide MPFR numbers from strings in a way that does not depend on the
current locale). 
A hexadecimal mantissa can be given with a leading <code>0x</code> or <code>0X</code>, in
which case <code>p</code> or <code>P</code> may introduce an optional binary exponent,
indicating the power of 2 by which the mantissa is to be scaled. A binary
mantissa can be given with a leading <code>0b</code> or <code>0B</code>, in which case
<code>e</code>, <code>E</code>, <code>p</code>, <code>P</code> or <code>@</code> may introduce the
binary exponent. The exponent is always written in base 10.

        <p>In addition, <code>infinity</code>, <code>inf</code> (if <var>base</var> &lt;= 10)
or <code>@inf@</code> with an optional sign, or <code>nan</code>,
<code>nan(n-char-sequence)</code> (if <var>base</var> &lt;= 10), <code>@nan@</code>
or <code>@nan@(n-char-sequence)</code> all case insensitive (as Latin letters),
can be given. A <code>n-char-sequence</code> is a non-empty string containing
only digits, Latin letters and the underscore (0, 1, 2, ..., 9, a, b, ...,
z, A, B, ..., Z, _).

        <p>There must be at least one digit in the mantissa for the number to
be valid. If an exponent has no digits it's ignored and parsing
stops after the mantissa. If an <code>0x</code>, <code>0X</code>, <code>0b</code> or
<code>0B</code> is not followed by hexadecimal/binary digits, parsing stops
after the first <code>0</code>:
the subject sequence is defined as the longest initial
subsequence of the input string, starting with the first
non-white-space character, that is of the expected form. 
The subject sequence contains no characters if the input
string is not of the expected form.

        <p>Note that in the hex format the exponent <code>P</code> represents a power of 2,
whereas <code>@</code> represents a power of the base (i.e. 16).

        <p>If the argument <var>base</var> is different from 0, it must be in the range 2
to 36. 
<!-- For bases up to 36, -->
Case is ignored; uppercase and lowercase letters have the same
value. 
<!-- ; for bases 37 to 62, uppercase letters represent the usual -->
<!-- 10..35, while lowercase letters represent 36..61. -->

        <p>If <code>base</code> is 0, then it tries to identify the used base: if the
mantissa begins with the <code>0x</code> prefix, it assumes that <var>base</var> is 16. 
If it begins with <code>0b</code>, it assumes that <var>base</var> is 2. Otherwise, it
assumes it is 10.

        <p>It returns a usual ternary value. 
If <var>endptr</var> is not a null pointer, a pointer to the character after
the last character used in the conversion is stored in the location
referenced by <var>endptr</var>.

        </blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_set_inf</b> (<var>mpfr_t x, int sign</var>)<var><a name="index-mpfr_005fset_005finf-42"></a></var><br>
&mdash; Function: void <b>mpfr_set_nan</b> (<var>mpfr_t x</var>)<var><a name="index-mpfr_005fset_005fnan-43"></a></var><br>
<blockquote><p>Set the variable <var>x</var> to infinity or NaN (Not-a-Number) respectively. 
In <code>mpfr_set_inf</code>, <var>x</var> is set to plus infinity iff <var>sign</var> is
nonnegative. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_swap</b> (<var>mpfr_t x, mpfr_t y</var>)<var><a name="index-mpfr_005fswap-44"></a></var><br>
<blockquote><p>Swap the values <var>x</var> and <var>y</var> efficiently. Warning: the
precisions are exchanged too; in case the precisions are different,
<code>mpfr_swap</code> is thus not equivalent to three <code>mpfr_set</code> calls
using a third auxiliary variable. 
</p></blockquote></div>

<div class="node">
<p><hr>
<a name="Combined-Initialization-and-Assignment-Functions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Conversion-Functions">Conversion Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Assignment-Functions">Assignment Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<p><a name="index-Combined-initialization-and-assignment-functions-45"></a>

<h3 class="section">5.3 Combined Initialization and Assignment Functions</h3>

<div class="defun">
&mdash; Macro: int <b>mpfr_init_set</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005finit_005fset-46"></a></var><br>
&mdash; Macro: int <b>mpfr_init_set_ui</b> (<var>mpfr_t rop, unsigned long int op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005finit_005fset_005fui-47"></a></var><br>
&mdash; Macro: int <b>mpfr_init_set_si</b> (<var>mpfr_t rop, signed long int op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005finit_005fset_005fsi-48"></a></var><br>
&mdash; Macro: int <b>mpfr_init_set_d</b> (<var>mpfr_t rop, double op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005finit_005fset_005fd-49"></a></var><br>
&mdash; Macro: int <b>mpfr_init_set_ld</b> (<var>mpfr_t rop, long double op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005finit_005fset_005fld-50"></a></var><br>
&mdash; Macro: int <b>mpfr_init_set_z</b> (<var>mpfr_t rop, mpz_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005finit_005fset_005fz-51"></a></var><br>
&mdash; Macro: int <b>mpfr_init_set_q</b> (<var>mpfr_t rop, mpq_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005finit_005fset_005fq-52"></a></var><br>
&mdash; Macro: int <b>mpfr_init_set_f</b> (<var>mpfr_t rop, mpf_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005finit_005fset_005ff-53"></a></var><br>
<blockquote><p>Initialize <var>rop</var> and set its value from <var>op</var>, rounded in the direction
<var>rnd</var>. 
The precision of <var>rop</var> will be taken from the active default precision,
as set by <code>mpfr_set_default_prec</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_init_set_str</b> (<var>mpfr_t x, const char *s, int base, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005finit_005fset_005fstr-54"></a></var><br>
<blockquote><p>Initialize <var>x</var> and set its value from
the string <var>s</var> in base <var>base</var>,
rounded in the direction <var>rnd</var>. 
See <code>mpfr_set_str</code>. 
</p></blockquote></div>

<div class="node">
<p><hr>
<a name="Conversion-Functions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<p><a name="index-Conversion-functions-55"></a>

<h3 class="section">5.4 Conversion Functions</h3>

<div class="defun">
&mdash; Function: double <b>mpfr_get_d</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fget_005fd-56"></a></var><br>
&mdash; Function: long double <b>mpfr_get_ld</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fget_005fld-57"></a></var><br>
<blockquote><p>Convert <var>op</var> to a <code>double</code> (respectively <code>long double</code>),
using the rounding mode <var>rnd</var>. 
If the system doesn't support IEEE 754 standard, this function
 might not preserve the signed zeros. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: double <b>mpfr_get_d_2exp</b> (<var>long *exp, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fget_005fd_005f2exp-58"></a></var><br>
<blockquote><p>Return <var>d</var> and set <var>exp</var> such that 0.5&lt;=abs(<var>d</var>)&lt;1
and <var>d</var> times 2 raised to <var>exp</var> equals
<var>op</var> rounded to double precision, using the given rounding mode. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: long <b>mpfr_get_si</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fget_005fsi-59"></a></var><br>
&mdash; Function: unsigned long <b>mpfr_get_ui</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fget_005fui-60"></a></var><br>
&mdash; Function: intmax_t <b>mpfr_get_sj</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fget_005fsj-61"></a></var><br>
&mdash; Function: uintmax_t <b>mpfr_get_uj</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fget_005fuj-62"></a></var><br>
<blockquote><p>Convert <var>op</var> to a <code>long</code>, an <code>unsigned long</code>,
an <code>intmax_t</code> or an <code>uintmax_t</code> (respectively) after rounding
it with respect to <var>rnd</var>. 
If <var>op</var> is NaN, the result is undefined. 
If <var>op</var> is too big for the return type, it returns the maximum
or the minimum of the corresponding C type, depending on the direction
of the overflow. The flag erange is set too. 
See also <code>mpfr_fits_slong_p</code>, <code>mpfr_fits_ulong_p</code>,
<code>mpfr_fits_intmax_p</code> and <code>mpfr_fits_uintmax_p</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: mp_exp_t <b>mpfr_get_z_exp</b> (<var>mpz_t rop, mpfr_t op</var>)<var><a name="index-mpfr_005fget_005fz_005fexp-63"></a></var><br>
<blockquote><p>Put the scaled mantissa of <var>op</var> (regarded as an integer, with the
precision of <var>op</var>) into <var>rop</var>, and return the exponent <var>exp</var>
(which may be outside the current exponent range) such that <var>op</var>
exactly equals
<var>rop</var> multiplied by two exponent <var>exp</var>. 
If the exponent is not representable in the <code>mp_exp_t</code> type, the
behavior is undefined. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_get_z</b> (<var>mpz_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fget_005fz-64"></a></var><br>
<blockquote><p>Convert <var>op</var> to a <code>mpz_t</code>, after rounding it with respect to
<var>rnd</var>. If <var>op</var> is NaN or Inf, the result is undefined. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_get_f</b> (<var>mpf_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fget_005ff-65"></a></var><br>
<blockquote><p>Convert <var>op</var> to a <code>mpf_t</code>, after rounding it with respect to
<var>rnd</var>. Return zero iff no error occurred,
in particular a non-zero value is returned if
<var>op</var> is NaN or Inf, which do not exist in <code>mpf</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: char * <b>mpfr_get_str</b> (<var>char *str, mp_exp_t *expptr, int b, size_t n, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fget_005fstr-66"></a></var><br>
<blockquote><p>Convert <var>op</var> to a string of digits in base <var>b</var>, with rounding in
the direction <var>rnd</var>. The base may vary from 2 to 36.

        <p>The generated string is a fraction, with an implicit radix point immediately
to the left of the first digit.  For example, the number &minus;3.1416 would
be returned as "&minus;31416" in the string and 1 written at <var>expptr</var>. 
If <var>rnd</var> is to nearest, and <var>op</var> is exactly in the middle of two
possible outputs, the one with an even last digit is chosen
(for an odd base, this may not correspond to an even mantissa).

        <p>If <var>n</var> is zero, the number of digits of the mantissa is chosen
large enough so that re-reading the printed value with the same precision,
assuming both output and input use rounding to nearest, will recover
the original value of <var>op</var>. 
More precisely, the chosen precision is
1 + ceil(n*log(2)/log(b)). 
This is the minimal precision depending on <var>n</var> and <var>b</var> only that
satisfies the above property.

        <p>If <var>str</var> is a null pointer, space for the mantissa is allocated using
the current allocation function, and a pointer to the string is returned. 
To free the returned string, you must use <code>mpfr_free_str</code>.

        <p>If <var>str</var> is not a null pointer, it should point to a block of storage
large enough for the mantissa, i.e., at least <code>max(</code><var>n</var><code> + 2, 7)</code>. 
The extra two bytes are for a possible minus sign, and for the terminating null
character.

        <p>If <var>n</var> is 0, note that the space requirements for <var>str</var>
in this case will be impossible for the user to predetermine. Therefore,
one needs to pass a null pointer for the string argument whenever
<var>n</var> is 0.

        <p>If the input number is an ordinary number, the exponent is written through
the pointer <var>expptr</var> (the current minimal exponent for 0).

        <p>A pointer to the string is returned, unless there is an error, in which
case a null pointer is returned. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_free_str</b> (<var>char *str</var>)<var><a name="index-mpfr_005ffree_005fstr-67"></a></var><br>
<blockquote><p>Free a string allocated by <code>mpfr_get_str</code> using the current unallocation
function (preliminary interface). 
The block is assumed to be <code>strlen(</code><var>str</var><code>)+1</code> bytes. 
For more information about how it is done:
see Custom Allocation (GNU MP). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_fits_ulong_p</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ffits_005fulong_005fp-68"></a></var><br>
&mdash; Function: int <b>mpfr_fits_slong_p</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ffits_005fslong_005fp-69"></a></var><br>
&mdash; Function: int <b>mpfr_fits_uint_p</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ffits_005fuint_005fp-70"></a></var><br>
&mdash; Function: int <b>mpfr_fits_sint_p</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ffits_005fsint_005fp-71"></a></var><br>
&mdash; Function: int <b>mpfr_fits_ushort_p</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ffits_005fushort_005fp-72"></a></var><br>
&mdash; Function: int <b>mpfr_fits_sshort_p</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ffits_005fsshort_005fp-73"></a></var><br>
&mdash; Function: int <b>mpfr_fits_intmax_p</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ffits_005fintmax_005fp-74"></a></var><br>
&mdash; Function: int <b>mpfr_fits_uintmax_p</b> (<var>mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ffits_005fuintmax_005fp-75"></a></var><br>
<blockquote><p>Return non-zero if <var>op</var> would fit in the respective C data type, when
rounded to an integer in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="node">
<p><hr>
<a name="Basic-Arithmetic-Functions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Comparison-Functions">Comparison Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Conversion-Functions">Conversion Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.5 Basic Arithmetic Functions</h3>

<p><a name="index-Basic-arithmetic-functions-76"></a><a name="index-Float-arithmetic-functions-77"></a><a name="index-Arithmetic-functions-78"></a>

<div class="defun">
&mdash; Function: int <b>mpfr_add</b> (<var>mpfr_t rop, mpfr_t op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fadd-79"></a></var><br>
&mdash; Function: int <b>mpfr_add_ui</b> (<var>mpfr_t rop, mpfr_t op1, unsigned long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fadd_005fui-80"></a></var><br>
&mdash; Function: int <b>mpfr_add_si</b> (<var>mpfr_t rop, mpfr_t op1, long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fadd_005fsi-81"></a></var><br>
&mdash; Function: int <b>mpfr_add_z</b> (<var>mpfr_t rop, mpfr_t op1, mpz_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fadd_005fz-82"></a></var><br>
&mdash; Function: int <b>mpfr_add_q</b> (<var>mpfr_t rop, mpfr_t op1, mpq_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fadd_005fq-83"></a></var><br>
<blockquote><p>Set <var>rop</var> to <var>op1</var> + <var>op2</var> rounded in the direction <var>rnd</var>. For types having no signed zero, it is considered unsigned (i.e. (+0) + 0 = (+0) and (-0) + 0 = (-0)). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_sub</b> (<var>mpfr_t rop, mpfr_t op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsub-84"></a></var><br>
&mdash; Function: int <b>mpfr_ui_sub</b> (<var>mpfr_t rop, unsigned long int op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fui_005fsub-85"></a></var><br>
&mdash; Function: int <b>mpfr_sub_ui</b> (<var>mpfr_t rop, mpfr_t op1, unsigned long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsub_005fui-86"></a></var><br>
&mdash; Function: int <b>mpfr_si_sub</b> (<var>mpfr_t rop, long int op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsi_005fsub-87"></a></var><br>
&mdash; Function: int <b>mpfr_sub_si</b> (<var>mpfr_t rop, mpfr_t op1, long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsub_005fsi-88"></a></var><br>
&mdash; Function: int <b>mpfr_sub_z</b> (<var>mpfr_t rop, mpfr_t op1, mpz_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsub_005fz-89"></a></var><br>
&mdash; Function: int <b>mpfr_sub_q</b> (<var>mpfr_t rop, mpfr_t op1, mpq_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsub_005fq-90"></a></var><br>
<blockquote><p>Set <var>rop</var> to <var>op1</var> - <var>op2</var> rounded in the direction
<var>rnd</var>. For types having no signed zero, it is considered unsigned
(i.e. (+0) &minus; 0 = (+0), (&minus;0) &minus; 0 = (&minus;0),
0 &minus; (+0) = (&minus;0) and 0 &minus; (&minus;0) = (+0)). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_mul</b> (<var>mpfr_t rop, mpfr_t op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fmul-91"></a></var><br>
&mdash; Function: int <b>mpfr_mul_ui</b> (<var>mpfr_t rop, mpfr_t op1, unsigned long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fmul_005fui-92"></a></var><br>
&mdash; Function: int <b>mpfr_mul_si</b> (<var>mpfr_t rop, mpfr_t op1, long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fmul_005fsi-93"></a></var><br>
&mdash; Function: int <b>mpfr_mul_z</b> (<var>mpfr_t rop, mpfr_t op1, mpz_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fmul_005fz-94"></a></var><br>
&mdash; Function: int <b>mpfr_mul_q</b> (<var>mpfr_t rop, mpfr_t op1, mpq_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fmul_005fq-95"></a></var><br>
<blockquote><p>Set <var>rop</var> to <var>op1</var> times <var>op2</var> rounded in the
direction <var>rnd</var>. 
When a result is zero, its sign is the product of the signs of the operands
(for types having no signed zero, it is considered positive). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_sqr</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsqr-96"></a></var><br>
<blockquote><p>Set <var>rop</var> to the square of <var>op</var>
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_div</b> (<var>mpfr_t rop, mpfr_t op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fdiv-97"></a></var><br>
&mdash; Function: int <b>mpfr_ui_div</b> (<var>mpfr_t rop, unsigned long int op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fui_005fdiv-98"></a></var><br>
&mdash; Function: int <b>mpfr_div_ui</b> (<var>mpfr_t rop, mpfr_t op1, unsigned long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fdiv_005fui-99"></a></var><br>
&mdash; Function: int <b>mpfr_si_div</b> (<var>mpfr_t rop, long int op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsi_005fdiv-100"></a></var><br>
&mdash; Function: int <b>mpfr_div_si</b> (<var>mpfr_t rop, mpfr_t op1, long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fdiv_005fsi-101"></a></var><br>
&mdash; Function: int <b>mpfr_div_z</b> (<var>mpfr_t rop, mpfr_t op1, mpz_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fdiv_005fz-102"></a></var><br>
&mdash; Function: int <b>mpfr_div_q</b> (<var>mpfr_t rop, mpfr_t op1, mpq_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fdiv_005fq-103"></a></var><br>
<blockquote><p>Set <var>rop</var> to <var>op1</var>/<var>op2</var> rounded in the direction <var>rnd</var>. 
When a result is zero, its sign is the product of the signs of the operands
(for types having no signed zero, it is considered positive). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_sqrt</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsqrt-104"></a></var><br>
&mdash; Function: int <b>mpfr_sqrt_ui</b> (<var>mpfr_t rop, unsigned long int op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsqrt_005fui-105"></a></var><br>
<blockquote><p>Set <var>rop</var> to the square root of <var>op</var>
rounded in the direction <var>rnd</var>. Return &minus;0 if <var>op</var> is
&minus;0 (to be consistent with the IEEE 754-1985 standard). 
Set <var>rop</var> to NaN if <var>op</var> is negative. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_cbrt</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fcbrt-106"></a></var><br>
&mdash; Function: int <b>mpfr_root</b> (<var>mpfr_t rop, mpfr_t op, unsigned long int k, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005froot-107"></a></var><br>
<blockquote><p>Set <var>rop</var> to the cubic root (resp. the <var>k</var>th root)
of <var>op</var> rounded in the direction <var>rnd</var>. 
An odd (resp. even) root of a negative number (including &minus;Inf)
returns a negative number (resp. NaN). 
The <var>k</var>th root of &minus;0 is defined to be &minus;0,
whatever the parity of <var>k</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_pow</b> (<var>mpfr_t rop, mpfr_t op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fpow-108"></a></var><br>
&mdash; Function: int <b>mpfr_pow_ui</b> (<var>mpfr_t rop, mpfr_t op1, unsigned long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fpow_005fui-109"></a></var><br>
&mdash; Function: int <b>mpfr_pow_si</b> (<var>mpfr_t rop, mpfr_t op1, long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fpow_005fsi-110"></a></var><br>
&mdash; Function: int <b>mpfr_pow_z</b> (<var>mpfr_t rop, mpfr_t op1, mpz_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fpow_005fz-111"></a></var><br>
&mdash; Function: int <b>mpfr_ui_pow_ui</b> (<var>mpfr_t rop, unsigned long int op1, unsigned long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fui_005fpow_005fui-112"></a></var><br>
&mdash; Function: int <b>mpfr_ui_pow</b> (<var>mpfr_t rop, unsigned long int op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fui_005fpow-113"></a></var><br>
<blockquote><p>Set <var>rop</var> to <var>op1</var> raised to <var>op2</var>,
rounded in the direction <var>rnd</var>. 
Special values are currently handled as described in the ISO C99 standard
for the <code>pow</code> function (note this may change in future versions):
          <ul>
<li><code>pow(0, </code><var>y</var><code>)</code> returns plus or minus infinity for <var>y</var> a negative odd integer. 
<li><code>pow(0, </code><var>y</var><code>)</code> returns plus infinity for <var>y</var> negative and not an odd integer. 
<li><code>pow(0, </code><var>y</var><code>)</code> returns plus or minus zero for <var>y</var> a positive odd integer. 
<li><code>pow(0, </code><var>y</var><code>)</code> returns plus zero for <var>y</var> positive and not an odd integer. 
<li><code>pow(-1, inf)</code> returns 1. 
<li><code>pow(+1, </code><var>y</var><code>)</code> returns 1 for any <var>y</var>, even a NaN. 
<li><code>pow(</code><var>x</var><code>, </code><var>y</var><code>)</code> returns NaN for finite negative <var>x</var> and finite non-integer <var>y</var>. 
<li><code>pow(</code><var>x</var><code>, -inf)</code> returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
<li><code>pow(</code><var>x</var><code>, +inf)</code> returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
<li><code>pow(-inf, </code><var>y</var><code>)</code> returns minus zero for <var>y</var> a negative odd integer. 
<li><code>pow(-inf, </code><var>y</var><code>)</code> returns plus zero for <var>y</var> negative and not an odd integer. 
<li><code>pow(-inf, </code><var>y</var><code>)</code> returns minus infinity for <var>y</var> a positive odd integer. 
<li><code>pow(-inf, </code><var>y</var><code>)</code> returns plus infinity for <var>y</var> positive and not an odd integer. 
<li><code>pow(+inf, </code><var>y</var><code>)</code> returns plus zero for <var>y</var> negative, and plus infinity for <var>y</var> positive. 
</ul>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_neg</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fneg-114"></a></var><br>
<blockquote><p>Set <var>rop</var> to -<var>op</var> rounded in the direction <var>rnd</var>. 
Just changes the sign if <var>rop</var> and <var>op</var> are the same variable. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_abs</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fabs-115"></a></var><br>
<blockquote><p>Set <var>rop</var> to the absolute value of <var>op</var>,
rounded in the direction <var>rnd</var>. 
Just changes the sign if <var>rop</var> and <var>op</var> are the same variable. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_mul_2ui</b> (<var>mpfr_t rop, mpfr_t op1, unsigned long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fmul_005f2ui-116"></a></var><br>
&mdash; Function: int <b>mpfr_mul_2si</b> (<var>mpfr_t rop, mpfr_t op1, long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fmul_005f2si-117"></a></var><br>
<blockquote><p>Set <var>rop</var> to <var>op1</var> times 2 raised
to <var>op2</var>
rounded in the direction <var>rnd</var>. Just increases the exponent by <var>op2</var>
when <var>rop</var> and <var>op1</var> are identical. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_div_2ui</b> (<var>mpfr_t rop, mpfr_t op1, unsigned long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fdiv_005f2ui-118"></a></var><br>
&mdash; Function: int <b>mpfr_div_2si</b> (<var>mpfr_t rop, mpfr_t op1, long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fdiv_005f2si-119"></a></var><br>
<blockquote><p>Set <var>rop</var> to <var>op1</var> divided by 2 raised
to <var>op2</var>
rounded in the direction <var>rnd</var>. Just decreases the exponent by <var>op2</var>
when <var>rop</var> and <var>op1</var> are identical. 
</p></blockquote></div>

<div class="node">
<p><hr>
<a name="Comparison-Functions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Special-Functions">Special Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.6 Comparison Functions</h3>

<p><a name="index-Float-comparisons-functions-120"></a><a name="index-Comparison-functions-121"></a>

<div class="defun">
&mdash; Function: int <b>mpfr_cmp</b> (<var>mpfr_t op1, mpfr_t op2</var>)<var><a name="index-mpfr_005fcmp-122"></a></var><br>
&mdash; Function: int <b>mpfr_cmp_ui</b> (<var>mpfr_t op1, unsigned long int op2</var>)<var><a name="index-mpfr_005fcmp_005fui-123"></a></var><br>
&mdash; Function: int <b>mpfr_cmp_si</b> (<var>mpfr_t op1, signed long int op2</var>)<var><a name="index-mpfr_005fcmp_005fsi-124"></a></var><br>
&mdash; Function: int <b>mpfr_cmp_d</b> (<var>mpfr_t op1, double op2</var>)<var><a name="index-mpfr_005fcmp_005fd-125"></a></var><br>
&mdash; Function: int <b>mpfr_cmp_ld</b> (<var>mpfr_t op1, long double op2</var>)<var><a name="index-mpfr_005fcmp_005fld-126"></a></var><br>
&mdash; Function: int <b>mpfr_cmp_z</b> (<var>mpfr_t op1, mpz_t op2</var>)<var><a name="index-mpfr_005fcmp_005fz-127"></a></var><br>
&mdash; Function: int <b>mpfr_cmp_q</b> (<var>mpfr_t op1, mpq_t op2</var>)<var><a name="index-mpfr_005fcmp_005fq-128"></a></var><br>
&mdash; Function: int <b>mpfr_cmp_f</b> (<var>mpfr_t op1, mpf_t op2</var>)<var><a name="index-mpfr_005fcmp_005ff-129"></a></var><br>
<blockquote><p>Compare <var>op1</var> and <var>op2</var>.  Return a positive value if <var>op1</var> &gt;
<var>op2</var>, zero if <var>op1</var> = <var>op2</var>, and a negative value if
<var>op1</var> &lt; <var>op2</var>. 
Both <var>op1</var> and <var>op2</var> are considered to their full own precision,
which may differ. 
If one of the operands is NaN (Not-a-Number), return zero and set
the erange flag.

        <p>Note: These functions may be useful to distinguish the three possible cases. 
If you need to distinguish two cases only, it is recommended to use the
predicate functions (e.g., <code>mpfr_equal_p</code> for the equality) described
below; they behave like the IEEE-754 comparisons, in particular when one
or both arguments are NaN. But only floating-point numbers can be compared
(you may need to do a conversion first). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_cmp_ui_2exp</b> (<var>mpfr_t op1, unsigned long int op2, mp_exp_t e</var>)<var><a name="index-mpfr_005fcmp_005fui_005f2exp-130"></a></var><br>
&mdash; Function: int <b>mpfr_cmp_si_2exp</b> (<var>mpfr_t op1, long int op2, mp_exp_t e</var>)<var><a name="index-mpfr_005fcmp_005fsi_005f2exp-131"></a></var><br>
<blockquote><p>Compare <var>op1</var> and <var>op2</var> multiplied by two to
the power <var>e</var>. Similar as above. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_cmpabs</b> (<var>mpfr_t op1, mpfr_t op2</var>)<var><a name="index-mpfr_005fcmpabs-132"></a></var><br>
<blockquote><p>Compare |<var>op1</var>| and |<var>op2</var>|.  Return a positive value if
|<var>op1</var>| &gt; |<var>op2</var>|, zero if |<var>op1</var>| = |<var>op2</var>|, and
a negative value if |<var>op1</var>| &lt; |<var>op2</var>|. 
If one of the operands is NaN (Not-a-Number), return zero and set
the erange flag. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_nan_p</b> (<var>mpfr_t op</var>)<var><a name="index-mpfr_005fnan_005fp-133"></a></var><br>
&mdash; Function: int <b>mpfr_inf_p</b> (<var>mpfr_t op</var>)<var><a name="index-mpfr_005finf_005fp-134"></a></var><br>
&mdash; Function: int <b>mpfr_number_p</b> (<var>mpfr_t op</var>)<var><a name="index-mpfr_005fnumber_005fp-135"></a></var><br>
&mdash; Function: int <b>mpfr_zero_p</b> (<var>mpfr_t op</var>)<var><a name="index-mpfr_005fzero_005fp-136"></a></var><br>
<blockquote><p>Return non-zero if <var>op</var> is respectively Not-a-Number (NaN),
an infinity, an ordinary number (i.e. neither Not-a-Number nor
an infinity) or zero. Return zero otherwise. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: int <b>mpfr_sgn</b> (<var>mpfr_t op</var>)<var><a name="index-mpfr_005fsgn-137"></a></var><br>
<blockquote><p>Return a positive value if <var>op</var> &gt; 0, zero if <var>op</var> = 0,
and a negative value if <var>op</var> &lt; 0. 
Its result is undefined when <var>op</var> is NaN (Not-a-Number). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_greater_p</b> (<var>mpfr_t op1, mpfr_t op2</var>)<var><a name="index-mpfr_005fgreater_005fp-138"></a></var><br>
<blockquote><p>Return non-zero if <var>op1</var> &gt; <var>op2</var>, zero otherwise. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_greaterequal_p</b> (<var>mpfr_t op1, mpfr_t op2</var>)<var><a name="index-mpfr_005fgreaterequal_005fp-139"></a></var><br>
<blockquote><p>Return non-zero if <var>op1</var> &gt;= <var>op2</var>, zero otherwise. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_less_p</b> (<var>mpfr_t op1, mpfr_t op2</var>)<var><a name="index-mpfr_005fless_005fp-140"></a></var><br>
<blockquote><p>Return non-zero if <var>op1</var> &lt; <var>op2</var>, zero otherwise. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_lessequal_p</b> (<var>mpfr_t op1, mpfr_t op2</var>)<var><a name="index-mpfr_005flessequal_005fp-141"></a></var><br>
<blockquote><p>Return non-zero if <var>op1</var> &lt;= <var>op2</var>, zero otherwise. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_lessgreater_p</b> (<var>mpfr_t op1, mpfr_t op2</var>)<var><a name="index-mpfr_005flessgreater_005fp-142"></a></var><br>
<blockquote><p>Return non-zero if <var>op1</var> &lt; <var>op2</var> or
<var>op1</var> &gt; <var>op2</var> (i.e. neither <var>op1</var>, nor <var>op2</var> is
NaN, and <var>op1</var> &lt;&gt; <var>op2</var>), zero otherwise (i.e. <var>op1</var>
and/or <var>op2</var> are NaN, or <var>op1</var> = <var>op2</var>). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_equal_p</b> (<var>mpfr_t op1, mpfr_t op2</var>)<var><a name="index-mpfr_005fequal_005fp-143"></a></var><br>
<blockquote><p>Return non-zero if <var>op1</var> = <var>op2</var>, zero otherwise
(i.e. <var>op1</var> and/or <var>op2</var> are NaN, or
<var>op1</var> &lt;&gt; <var>op2</var>). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_unordered_p</b> (<var>mpfr_t op1, mpfr_t op2</var>)<var><a name="index-mpfr_005funordered_005fp-144"></a></var><br>
<blockquote><p>Return non-zero if <var>op1</var> or <var>op2</var> is a NaN (i.e. they cannot be
compared), zero otherwise. 
</p></blockquote></div>

<div class="node">
<p><hr>
<a name="Special-Functions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Input-and-Output-Functions">Input and Output Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Comparison-Functions">Comparison Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<h3 class="section">5.7 Special Functions</h3>

<p><a name="index-Special-functions-145"></a>
All those functions, except explicitly stated, return zero for an
exact return value, a positive value for a return value larger than the
exact result, and a negative value otherwise.

<div class="defun">
&mdash; Function: int <b>mpfr_log</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005flog-146"></a></var><br>
&mdash; Function: int <b>mpfr_log2</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005flog2-147"></a></var><br>
&mdash; Function: int <b>mpfr_log10</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005flog10-148"></a></var><br>
<blockquote><p>Set <var>rop</var> to the natural logarithm of <var>op</var>,
log2(<var>op</var>) or
log10(<var>op</var>), respectively,
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_exp</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fexp-149"></a></var><br>
&mdash; Function: int <b>mpfr_exp2</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fexp2-150"></a></var><br>
&mdash; Function: int <b>mpfr_exp10</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fexp10-151"></a></var><br>
<blockquote><p>Set <var>rop</var> to the exponential of <var>op</var>,
 to 2 power of <var>op</var>
or to 10 power of <var>op</var>, respectively,
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_cos</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fcos-152"></a></var><br>
&mdash; Function: int <b>mpfr_sin</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsin-153"></a></var><br>
&mdash; Function: int <b>mpfr_tan</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ftan-154"></a></var><br>
<blockquote><p>Set <var>rop</var> to the cosine of <var>op</var>, sine of <var>op</var>,
tangent of <var>op</var>, rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_sec</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsec-155"></a></var><br>
&mdash; Function: int <b>mpfr_csc</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fcsc-156"></a></var><br>
&mdash; Function: int <b>mpfr_cot</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fcot-157"></a></var><br>
<blockquote><p>Set <var>rop</var> to the secant of <var>op</var>, cosecant of <var>op</var>,
cotangent of <var>op</var>, rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_sin_cos</b> (<var>mpfr_t sop, mpfr_t cop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsin_005fcos-158"></a></var><br>
<blockquote><p>Set simultaneously <var>sop</var> to the sine of <var>op</var> and
                   <var>cop</var> to the cosine of <var>op</var>,
rounded in the direction <var>rnd</var> with the corresponding precisions of
<var>sop</var> and <var>cop</var>. 
Return 0 iff both results are exact. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_acos</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005facos-159"></a></var><br>
&mdash; Function: int <b>mpfr_asin</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fasin-160"></a></var><br>
&mdash; Function: int <b>mpfr_atan</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fatan-161"></a></var><br>
<blockquote><p>Set <var>rop</var> to the arc-cosine, arc-sine or arc-tangent of <var>op</var>,
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_atan2</b> (<var>mpfr_t rop, mpfr_t y, mpfr_t x, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fatan2-162"></a></var><br>
<blockquote><p>Set <var>rop</var> to the arc-tangent2 of <var>y</var> and <var>x</var>,
rounded in the direction <var>rnd</var>:
if <code>x &gt; 0</code>, <code>atan2(y, x) = atan (y/x)</code>;
if <code>x &lt; 0</code>, <code>atan2(y, x) = sign(y)*(PI - atan (abs(y/x)))</code>.

        <p><code>atan2(y, 0)</code> does not raise any floating-point exception. 
Special values are currently handled as described in the ISO C99 standard
for the <code>atan2</code> function (note this may change in future versions):
          <ul>
<li><code>atan2(+0, -0)</code> returns +Pi. 
<li><code>atan2(-0, -0)</code> returns -Pi. 
<li><code>atan2(+0, +0)</code> returns +0. 
<li><code>atan2(-0, +0)</code> returns &minus;0. 
<li><code>atan2(+0, x)</code> returns +Pi for x &lt; 0. 
<li><code>atan2(-0, x)</code> returns -Pi for x &lt; 0. 
<li><code>atan2(+0, x)</code> returns +0 for x &gt; 0. 
<li><code>atan2(-0, x)</code> returns &minus;0 for x &gt; 0. 
<li><code>atan2(y, 0)</code> returns -Pi/2 for y &lt; 0. 
<li><code>atan2(y, 0)</code> returns +Pi/2 for y &gt; 0. 
<li><code>atan2(+INF, -INF)</code> returns +3*Pi/4. 
<li><code>atan2(-INF, -INF)</code> returns -3*Pi/4. 
<li><code>atan2(+INF, +INF)</code> returns +Pi/4. 
<li><code>atan2(-INF, +INF)</code> returns -Pi/4. 
<li><code>atan2(+INF, x)</code> returns +Pi/2 for finite x. 
<li><code>atan2(-INF, x)</code> returns -Pi/2 for finite x. 
<li><code>atan2(y, -INF)</code> returns +Pi for finite y &gt; 0. 
<li><code>atan2(y, -INF)</code> returns -Pi for finite y &lt; 0. 
<li><code>atan2(y, +INF)</code> returns +0 for finite y &gt; 0. 
<li><code>atan2(y, +INF)</code> returns &minus;0 for finite y &lt; 0. 
</ul>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_cosh</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fcosh-163"></a></var><br>
&mdash; Function: int <b>mpfr_sinh</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsinh-164"></a></var><br>
&mdash; Function: int <b>mpfr_tanh</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ftanh-165"></a></var><br>
<blockquote><p>Set <var>rop</var> to the hyperbolic cosine, sine or tangent of <var>op</var>,
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_sech</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsech-166"></a></var><br>
&mdash; Function: int <b>mpfr_csch</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fcsch-167"></a></var><br>
&mdash; Function: int <b>mpfr_coth</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fcoth-168"></a></var><br>
<blockquote><p>Set <var>rop</var> to the hyperbolic secant of <var>op</var>, cosecant of <var>op</var>,
cotangent of <var>op</var>, rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_acosh</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005facosh-169"></a></var><br>
&mdash; Function: int <b>mpfr_asinh</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fasinh-170"></a></var><br>
&mdash; Function: int <b>mpfr_atanh</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fatanh-171"></a></var><br>
<blockquote><p>Set <var>rop</var> to the inverse hyperbolic cosine, sine or tangent of <var>op</var>,
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_fac_ui</b> (<var>mpfr_t rop, unsigned long int op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ffac_005fui-172"></a></var><br>
<blockquote><p>Set <var>rop</var> to the factorial of the <code>unsigned long int</code> <var>op</var>,
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_log1p</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005flog1p-173"></a></var><br>
<blockquote><p>Set <var>rop</var> to the logarithm of one plus <var>op</var>,
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_expm1</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fexpm1-174"></a></var><br>
<blockquote><p>Set <var>rop</var> to the exponential of <var>op</var> minus one,
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_eint</b> (<var>mpfr_t y, mpfr_t x, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005feint-175"></a></var><br>
<blockquote><p>Set <var>y</var> to the exponential integral of <var>x</var>,
rounded in the direction <var>rnd</var>. 
For positive <var>x</var>,
the exponential integral is the sum of Euler's constant, of the logarithm
of <var>x</var>, and of the sum for k from 1 to infinity of
<var>x</var> to the power k, divided by k and factorial(k). 
For negative <var>x</var>, the returned value is NaN. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_gamma</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fgamma-176"></a></var><br>
&mdash; Function: int <b>mpfr_lngamma</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005flngamma-177"></a></var><br>
<blockquote><p>Set <var>rop</var> to the value of the Gamma function on <var>op</var>,
and its logarithm respectively, rounded in the direction <var>rnd</var>. 
When <var>op</var> is a negative integer, NaN is returned. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_zeta</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fzeta-178"></a></var><br>
<blockquote><p>Set <var>rop</var> to the value of the Riemann Zeta function on <var>op</var>,
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_erf</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ferf-179"></a></var><br>
<blockquote><p>Set <var>rop</var> to the value of the error function on <var>op</var>,
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_erfc</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ferfc-180"></a></var><br>
<blockquote><p>Set <var>rop</var> to the value of the complementary error function on <var>op</var>,
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_fma</b> (<var>mpfr_t rop, mpfr_t op1, mpfr_t op2, mpfr_t op3, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ffma-181"></a></var><br>
<blockquote><p>Set <var>rop</var> to <var>op1</var> times <var>op2</var> + <var>op3</var>,
rounded in the direction <var>rnd</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_agm</b> (<var>mpfr_t rop, mpfr_t op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fagm-182"></a></var><br>
<blockquote><p>Set <var>rop</var> to the arithmetic-geometric mean of <var>op1</var> and <var>op2</var>,
rounded in the direction <var>rnd</var>. 
The arithmetic-geometric mean is the common limit of the sequences
u[n] and v[n], where u[0]=<var>op1</var>, v[0]=<var>op2</var>, u[n+1] is the
arithmetic mean of u[n] and v[n], and v[n+1] is the geometric mean of
u[n] and v[n]. 
If any operand is negative, the return value is NaN. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_hypot</b> (<var>mpfr_t rop, mpfr_t x, mpfr_t y, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fhypot-183"></a></var><br>
<blockquote><p>Set <var>rop</var> to the Euclidean norm of <var>x</var> and <var>y</var>,
i.e. 
the square root of the sum of the squares of <var>x</var> and <var>y</var>,
rounded in the direction <var>rnd</var>. 
Special values are currently handled as described in Section F.9.4.3 of
the ISO C99 standard, for the <code>hypot</code> function (note this may change
in future versions): If <var>x</var> or <var>y</var> is an infinity, then plus
infinity is returned in <var>rop</var>, even if the other number is NaN. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_const_log2</b> (<var>mpfr_t rop, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fconst_005flog2-184"></a></var><br>
&mdash; Function: int <b>mpfr_const_pi</b> (<var>mpfr_t rop, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fconst_005fpi-185"></a></var><br>
&mdash; Function: int <b>mpfr_const_euler</b> (<var>mpfr_t rop, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fconst_005feuler-186"></a></var><br>
&mdash; Function: int <b>mpfr_const_catalan</b> (<var>mpfr_t rop, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fconst_005fcatalan-187"></a></var><br>
<blockquote><p>Set <var>rop</var> to the logarithm of 2, the value of Pi,
of Euler's constant 0.577<small class="dots">...</small>, of Catalan's constant 0.915<small class="dots">...</small>,
respectively, rounded in the direction
<var>rnd</var>. These functions cache the computed values to avoid other
calculations if a lower or equal precision is requested. To free these caches,
use <code>mpfr_free_cache</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_free_cache</b> (<var>void</var>)<var><a name="index-mpfr_005ffree_005fcache-188"></a></var><br>
<blockquote><p>Free the cache used by the functions computing constants if needed
(currently
<code>mpfr_const_log2</code>, <code>mpfr_const_pi</code>,
<code>mpfr_const_euler</code> and <code>mpfr_const_catalan</code>). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_sum</b> (<var>mpfr_t rop, mpfr_ptr const tab</var>[]<var>, unsigned long n, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsum-189"></a></var><br>
<blockquote><p>Set <var>ret</var> to the sum of all elements of <var>tab</var> whose size is <var>n</var>,
rounded in the direction <var>rnd</var>. Warning, <var>tab</var> is a table of pointers
to mpfr_t, not a table of mpfr_t (preliminary interface). The returned
<code>int</code> value is zero when the computed value is the exact value,
and non-zero when this cannot be guaranteed, without giving the
direction of the error as the other functions do. 
</p></blockquote></div>

<div class="node">
<p><hr>
<a name="Input-and-Output-Functions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Integer-Related-Functions">Integer Related Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Special-Functions">Special Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.8 Input and Output Functions</h3>

<p><a name="index-Float-input-and-output-functions-190"></a><a name="index-Input-functions-191"></a><a name="index-Output-functions-192"></a><a name="index-I_002fO-functions-193"></a>
This section describes functions that perform input from an input/output
stream, and functions that output to an input/output stream. 
Passing a null pointer for a <var>stream</var> argument to any of
these functions will make them read from <code>stdin</code> and write to
<code>stdout</code>, respectively.

   <p>When using any of these functions, you must include the <code>&lt;stdio.h&gt;</code>
standard header before <span class="file">mpfr.h</span>, to allow <span class="file">mpfr.h</span> to define
prototypes for these functions.

<div class="defun">
&mdash; Function: size_t <b>mpfr_out_str</b> (<var>FILE *stream, int base, size_t n, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fout_005fstr-194"></a></var><br>
<blockquote><p>Output <var>op</var> on stream <var>stream</var>, as a string of digits in
base <var>base</var>, rounded in the direction <var>rnd</var>. 
The base may vary from 2 to 36.  Print <var>n</var> significant digits exactly,
or if <var>n</var> is 0, enough digits so that <var>op</var> can be read back
exactly (see <code>mpfr_get_str</code>).

        <p>In addition to the significant digits, a decimal point (defined by the
current locale) at the right of the
first digit and a trailing exponent in base 10, in the form <span class="samp">eNNN</span>,
are printed. If <var>base</var> is greater than 10, <span class="samp">@</span> will be used
instead of <span class="samp">e</span> as exponent delimiter.

        <p>Return the number of bytes written, or if an error occurred, return 0. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: size_t <b>mpfr_inp_str</b> (<var>mpfr_t rop, FILE *stream, int base, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005finp_005fstr-195"></a></var><br>
<blockquote><p>Input a string in base <var>base</var> from stream <var>stream</var>,
rounded in the direction <var>rnd</var>, and put the
read float in <var>rop</var>. 
<!-- The argument @var{base} must be in the range 2 to 36. -->

     <!-- The string is of the form @samp{M@@N} or, if the -->
<!-- base is 10 or less, alternatively @samp{MeN} or @samp{MEN}, or, if the base -->
<!-- is 16, alternatively @samp{MpB} or @samp{MPB}. -->
<!-- @samp{M} is the mantissa in the specified base, @samp{N} is the exponent -->
<!-- written in decimal for the specified base, and in base 16, @samp{B} is the -->
<!-- binary exponent written in decimal (i.e.@: it indicates the power of 2 by -->
<!-- which the mantissa is to be scaled). -->
<p>This function reads a word (defined as a sequence of characters between
whitespace) and parses it using <code>mpfr_set_str</code> (it may change). 
See the documentation of <code>mpfr_strtofr</code> for a detailed description
of the valid string formats. 
<!-- Special values can be read as follows (the case does not matter): -->
<!-- @code{@@NaN@@}, @code{@@Inf@@}, @code{+@@Inf@@} and @code{-@@Inf@@}, -->
<!-- possibly followed by other characters; if the base is smaller or equal -->
<!-- to 16, the following strings are accepted too: @code{NaN}, @code{Inf}, -->
<!-- @code{+Inf} and @code{-Inf}. -->

        <p>Return the number of bytes read, or if an error occurred, return 0. 
</p></blockquote></div>

<!-- @deftypefun void mpfr_inp_raw (mpfr_t @var{float}, FILE *@var{stream}) -->
<!-- Input from stdio stream @var{stream} in the format written by -->
<!-- @code{mpfr_out_raw}, and put the result in @var{float}. -->
<!-- @end deftypefun -->
<div class="node">
<p><hr>
<a name="Integer-Related-Functions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Miscellaneous-Functions">Miscellaneous Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Input-and-Output-Functions">Input and Output Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.9 Integer Related Functions</h3>

<p><a name="index-Integer-Related-Functions-196"></a>

<div class="defun">
&mdash; Function: int <b>mpfr_rint</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005frint-197"></a></var><br>
&mdash; Function: int <b>mpfr_ceil</b> (<var>mpfr_t rop, mpfr_t op</var>)<var><a name="index-mpfr_005fceil-198"></a></var><br>
&mdash; Function: int <b>mpfr_floor</b> (<var>mpfr_t rop, mpfr_t op</var>)<var><a name="index-mpfr_005ffloor-199"></a></var><br>
&mdash; Function: int <b>mpfr_round</b> (<var>mpfr_t rop, mpfr_t op</var>)<var><a name="index-mpfr_005fround-200"></a></var><br>
&mdash; Function: int <b>mpfr_trunc</b> (<var>mpfr_t rop, mpfr_t op</var>)<var><a name="index-mpfr_005ftrunc-201"></a></var><br>
<blockquote><p>Set <var>rop</var> to <var>op</var> rounded to an integer. 
<code>mpfr_rint</code> rounds to the nearest representable integer in the
given rounding mode, <code>mpfr_ceil</code> rounds
to the next higher or equal representable integer, <code>mpfr_floor</code> to
the next lower or equal representable integer, <code>mpfr_round</code> to the
nearest representable integer, rounding halfway cases away from zero,
and <code>mpfr_trunc</code> to the next representable integer towards zero.

        <p>The returned value is zero when the result is exact, positive when it is
greater than the original value of <var>op</var>, and negative when it is smaller. 
More precisely, the returned value is 0 when <var>op</var> is an integer
representable in <var>rop</var>, 1 or &minus;1 when <var>op</var> is an integer
that is not representable in <var>rop</var>, 2 or &minus;2 when <var>op</var> is
not an integer.

        <p>Note that <code>mpfr_round</code> is different from <code>mpfr_rint</code> called with
the rounding to the nearest mode (where halfway cases are rounded to an even
integer or mantissa). Note also that no double rounding is performed; for
instance, 4.5 (100.1 in binary) is rounded by <code>mpfr_round</code> to 4 (100
in binary) in 2-bit precision, though <code>round(4.5)</code> is equal to 5 and
5 (101 in binary) is rounded to 6 (110 in binary) in 2-bit precision. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_rint_ceil</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005frint_005fceil-202"></a></var><br>
&mdash; Function: int <b>mpfr_rint_floor</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005frint_005ffloor-203"></a></var><br>
&mdash; Function: int <b>mpfr_rint_round</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005frint_005fround-204"></a></var><br>
&mdash; Function: int <b>mpfr_rint_trunc</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005frint_005ftrunc-205"></a></var><br>
<blockquote><p>Set <var>rop</var> to <var>op</var> rounded to an integer. 
<code>mpfr_rint_ceil</code> rounds to the next higher or equal integer,
<code>mpfr_rint_floor</code> to the next lower or equal integer,
<code>mpfr_rint_round</code> to the nearest integer, rounding halfway cases away
from zero, and <code>mpfr_rint_trunc</code> to the next integer towards zero. 
If the result is not representable, it is rounded in the direction <var>rnd</var>. 
The returned value is the ternary value associated with the considered
round-to-integer function (regarded in the same way as any other
mathematical function). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_frac</b> (<var>mpfr_t rop, mpfr_t op, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005ffrac-206"></a></var><br>
<blockquote><p>Set <var>rop</var> to the fractional part of <var>op</var>, having the same sign as
<var>op</var>, rounded in the direction <var>rnd</var> (unlike in <code>mpfr_rint</code>,
<var>rnd</var> affects only how the exact fractional part is rounded, not how
the fractional part is generated). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_integer_p</b> (<var>mpfr_t op</var>)<var><a name="index-mpfr_005finteger_005fp-207"></a></var><br>
<blockquote><p>Return non-zero iff <var>op</var> is an integer. 
</p></blockquote></div>

<div class="node">
<p><hr>
<a name="Miscellaneous-Functions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Rounding-Modes">Rounding Modes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Integer-Related-Functions">Integer Related Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.10 Miscellaneous Functions</h3>

<p><a name="index-Miscellaneous-float-functions-208"></a>

<div class="defun">
&mdash; Function: void <b>mpfr_nexttoward</b> (<var>mpfr_t x, mpfr_t y</var>)<var><a name="index-mpfr_005fnexttoward-209"></a></var><br>
<blockquote><p>If <var>x</var> or <var>y</var> is NaN, set <var>x</var> to NaN. Otherwise, if <var>x</var>
is different from <var>y</var>, replace <var>x</var> by the next floating-point
number (with the precision of <var>x</var> and the current exponent range)
in the direction of <var>y</var>, if there is one
(the infinite values are seen as the smallest and largest floating-point
numbers). If the result is zero, it keeps the same sign. No underflow or
overflow is generated. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_nextabove</b> (<var>mpfr_t x</var>)<var><a name="index-mpfr_005fnextabove-210"></a></var><br>
<blockquote><p>Equivalent to <code>mpfr_nexttoward</code> where <var>y</var> is plus infinity. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_nextbelow</b> (<var>mpfr_t x</var>)<var><a name="index-mpfr_005fnextbelow-211"></a></var><br>
<blockquote><p>Equivalent to <code>mpfr_nexttoward</code> where <var>y</var> is minus infinity. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_min</b> (<var>mpfr_t rop, mpfr_t op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fmin-212"></a></var><br>
<blockquote><p>Set <var>rop</var> to the minimum of <var>op1</var> and <var>op2</var>. If <var>op1</var>
and <var>op2</var> are both NaN, then <var>rop</var> is set to NaN. If <var>op1</var>
or <var>op2</var> is NaN, then <var>rop</var> is set to the numeric value. If
<var>op1</var> and <var>op2</var> are zeros of different signs, then <var>rop</var>
is set to &minus;0. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_max</b> (<var>mpfr_t rop, mpfr_t op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fmax-213"></a></var><br>
<blockquote><p>Set <var>rop</var> to the maximum of <var>op1</var> and <var>op2</var>. If <var>op1</var>
and <var>op2</var> are both NaN, then <var>rop</var> is set to NaN. If <var>op1</var>
or <var>op2</var> is NaN, then <var>rop</var> is set to the numeric value. If
<var>op1</var> and <var>op2</var> are zeros of different signs, then <var>rop</var>
is set to +0. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_urandomb</b> (<var>mpfr_t rop, gmp_randstate_t state</var>)<var><a name="index-mpfr_005furandomb-214"></a></var><br>
<blockquote><p>Generate a uniformly distributed random float in the interval
0 &lt;= <var>rop</var> &lt; 1. 
Return 0, unless the exponent is not in the current exponent range, in
which case <var>rop</var> is set to NaN and a non-zero value is returned. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_random</b> (<var>mpfr_t rop</var>)<var><a name="index-mpfr_005frandom-215"></a></var><br>
<blockquote><p>Generate a uniformly distributed random float in the interval
0 &lt;= <var>rop</var> &lt; 1. 
This function is deprecated; <code>mpfr_urandomb</code> should be used instead. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_random2</b> (<var>mpfr_t rop, mp_size_t size, mp_exp_t exp</var>)<var><a name="index-mpfr_005frandom2-216"></a></var><br>
<blockquote><p>Generate a random float of at most <var>size</var> limbs, with long strings of
zeros and ones in the binary representation. The exponent of the number is in
the interval &minus;<var>exp</var> to <var>exp</var>. 
This function is useful for
testing functions and algorithms, since this kind of random numbers have
proven to be more likely to trigger corner-case bugs. 
Negative random numbers are generated when <var>size</var> is negative. 
Put +0 in <var>rop</var> when size if zero. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: mp_exp_t <b>mpfr_get_exp</b> (<var>mpfr_t x</var>)<var><a name="index-mpfr_005fget_005fexp-217"></a></var><br>
<blockquote><p>Get the exponent of <var>x</var>, assuming that <var>x</var> is a non-zero ordinary
number. The behavior for NaN, Infinity or Zero is undefined. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_set_exp</b> (<var>mpfr_t x, mp_exp_t e</var>)<var><a name="index-mpfr_005fset_005fexp-218"></a></var><br>
<blockquote><p>Set the exponent of <var>x</var> if <var>e</var> is in the current exponent range,
and return 0 (even if <var>x</var> is not a non-zero ordinary number);
otherwise, return a non-zero value. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: const char * <b>mpfr_get_version</b> (<var>void</var>)<var><a name="index-mpfr_005fget_005fversion-219"></a></var><br>
<blockquote><p>Return the MPFR version, as a null-terminated string. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>MPFR_VERSION</b><var><a name="index-MPFR_005fVERSION-220"></a></var><br>
&mdash; Macro: <b>MPFR_VERSION_MAJOR</b><var><a name="index-MPFR_005fVERSION_005fMAJOR-221"></a></var><br>
&mdash; Macro: <b>MPFR_VERSION_MINOR</b><var><a name="index-MPFR_005fVERSION_005fMINOR-222"></a></var><br>
&mdash; Macro: <b>MPFR_VERSION_PATCHLEVEL</b><var><a name="index-MPFR_005fVERSION_005fPATCHLEVEL-223"></a></var><br>
&mdash; Macro: <b>MPFR_VERSION_STRING</b><var><a name="index-MPFR_005fVERSION_005fSTRING-224"></a></var><br>
<blockquote><p><code>MPFR_VERSION</code> is the version of MPFR as a preprocessing constant. 
<code>MPFR_VERSION_MAJOR</code>, <code>MPFR_VERSION_MINOR</code> and
<code>MPFR_VERSION_PATCHLEVEL</code> are respectively the major, minor and patch
level of MPFR version, as preprocessing constants. 
<code>MPFR_VERSION_STRING</code> is the version as a string constant, which can
be compared to the result of <code>mpfr_get_version</code> to check at run time
the header file and library used match:
     <pre class="example">          if (strcmp (mpfr_get_version (), MPFR_VERSION_STRING))
             fprintf (stderr, "Error, header and library files do not match\n");
     </pre>
        </blockquote></div>

<div class="defun">
&mdash; Macro: long <b>MPFR_VERSION_NUM</b> (<var>major, minor, patchlevel</var>)<var><a name="index-MPFR_005fVERSION_005fNUM-225"></a></var><br>
<blockquote><p>Create an integer in the same format as used by <code>MPFR_VERSION</code> from the
given <var>major</var>, <var>minor</var> and <var>patchlevel</var>. 
Here is an example of how to check the MPFR version at compile time:
     <pre class="example">          #if (!defined(MPFR_VERSION) || (MPFR_VERSION&lt;MPFR_VERSION_NUM(2,1,0)))
          # error "Wrong MPFR version."
          #endif
     </pre>
        </blockquote></div>

<div class="node">
<p><hr>
<a name="Rounding-Modes"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Exceptions">Exceptions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Miscellaneous-Functions">Miscellaneous Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<h3 class="section">5.11 Rounding Modes</h3>

<p><a name="index-Rounding-Modes-226"></a>

<div class="defun">
&mdash; Function: void <b>mpfr_set_default_rounding_mode</b> (<var>mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fdefault_005frounding_005fmode-227"></a></var><br>
<blockquote><p>Set the default rounding mode to <var>rnd</var>. 
The default rounding mode is to nearest initially. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: mp_rnd_t <b>mpfr_get_default_rounding_mode</b> (<var>void</var>)<var><a name="index-mpfr_005fget_005fdefault_005frounding_005fmode-228"></a></var><br>
<blockquote><p>Get the default rounding mode. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_prec_round</b> (<var>mpfr_t x, mp_prec_t prec, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fprec_005fround-229"></a></var><br>
<blockquote><p>Round <var>x</var> according to <var>rnd</var> with precision <var>prec</var>, which
must be an integer between <code>MPFR_PREC_MIN</code> and <code>MPFR_PREC_MAX</code>
(otherwise the behavior is undefined). 
If <var>prec</var> is greater or equal to the precision of <var>x</var>, then new
space is allocated for the mantissa, and it is filled with zeros. 
Otherwise, the mantissa is rounded to precision <var>prec</var> with the given
direction. In both cases, the precision of <var>x</var> is changed to <var>prec</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_round_prec</b> (<var>mpfr_t x, mp_rnd_t rnd, mp_prec_t prec</var>)<var><a name="index-mpfr_005fround_005fprec-230"></a></var><br>
<blockquote><p>[This function is obsolete. Please use <code>mpfr_prec_round</code> instead.] 
</p></blockquote></div>

<div class="defun">
&mdash; Function: const char * <b>mpfr_print_rnd_mode</b> (<var>mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fprint_005frnd_005fmode-231"></a></var><br>
<blockquote><p>Return the input string (GMP_RNDD, GMP_RNDU, GMP_RNDN, GMP_RNDZ)
corresponding to the rounding mode <var>rnd</var> or a null pointer if
<var>rnd</var> is an invalid rounding mode. 
</p></blockquote></div>

<div class="node">
<p><hr>
<a name="Exceptions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Advanced-Functions">Advanced Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Rounding-Modes">Rounding Modes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.12 Exceptions</h3>

<p><a name="index-Exceptions-232"></a>

<div class="defun">
&mdash; Function: mp_exp_t <b>mpfr_get_emin</b> (<var>void</var>)<var><a name="index-mpfr_005fget_005femin-233"></a></var><br>
&mdash; Function: mp_exp_t <b>mpfr_get_emax</b> (<var>void</var>)<var><a name="index-mpfr_005fget_005femax-234"></a></var><br>
<blockquote><p>Return the (current) smallest and largest exponents allowed for a
floating-point variable. The smallest positive value of a floating-point
variable is one half times 2 raised to the
smallest exponent and the largest value has the form (1 - epsilon) times 2 raised to the largest exponent. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_set_emin</b> (<var>mp_exp_t exp</var>)<var><a name="index-mpfr_005fset_005femin-235"></a></var><br>
&mdash; Function: int <b>mpfr_set_emax</b> (<var>mp_exp_t exp</var>)<var><a name="index-mpfr_005fset_005femax-236"></a></var><br>
<blockquote><p>Set the smallest and largest exponents allowed for a floating-point variable. 
Return a non-zero value when <var>exp</var> is not in the range accepted by the
implementation (in that case the smallest or largest exponent is not changed),
and zero otherwise. 
If the user changes the exponent range, it is her/his responsibility to check
that all current floating-point variables are in the new allowed range
(for example using <code>mpfr_check_range</code>), otherwise the subsequent
behavior will be undefined, in the sense of the ISO C standard. 
<!-- It is also her/his responsibility to check that @m {emin <= emax}. -->
</p></blockquote></div>

<div class="defun">
&mdash; Function: mp_exp_t <b>mpfr_get_emin_min</b> (<var>void</var>)<var><a name="index-mpfr_005fget_005femin_005fmin-237"></a></var><br>
&mdash; Function: mp_exp_t <b>mpfr_get_emin_max</b> (<var>void</var>)<var><a name="index-mpfr_005fget_005femin_005fmax-238"></a></var><br>
&mdash; Function: mp_exp_t <b>mpfr_get_emax_min</b> (<var>void</var>)<var><a name="index-mpfr_005fget_005femax_005fmin-239"></a></var><br>
&mdash; Function: mp_exp_t <b>mpfr_get_emax_max</b> (<var>void</var>)<var><a name="index-mpfr_005fget_005femax_005fmax-240"></a></var><br>
<blockquote><p>Return the minimum and maximum of the smallest and largest exponents
allowed for <code>mpfr_set_emin</code> and <code>mpfr_set_emax</code>. These values
are implementation dependent; it is possible to create a non
portable program by writing <code>mpfr_set_emax(mpfr_get_emax_max())</code>
and <code>mpfr_set_emin(mpfr_get_emin_min())</code> since the values
of the smallest and largest exponents become implementation dependent. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_check_range</b> (<var>mpfr_t x, int t, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fcheck_005frange-241"></a></var><br>
<blockquote><p>This function forces <var>x</var> to be in the current range of acceptable
values, <var>t</var> being the current ternary value: negative if <var>x</var>
is smaller than the exact value, positive if <var>x</var> is larger than
the exact value and zero if <var>x</var> is exact (before the call). It
generates an underflow or an overflow if the exponent of <var>x</var> is
outside the current allowed range; the value of <var>t</var> may be used
to avoid a double rounding. This function returns zero if the rounded
result is equal to the exact one, a positive value if the rounded
result is larger than the exact one, a negative value if the rounded
result is smaller than the exact one. Note that unlike most functions,
the result is compared to the exact one, not the input value <var>x</var>,
i.e. the ternary value is propagated. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_subnormalize</b> (<var>mpfr_t x, int t, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fsubnormalize-242"></a></var><br>
<blockquote><p>This function rounds <var>x</var> emulating subnormal number arithmetic:
if <var>x</var> is outside the subnormal exponent range, it just propagates the
ternary value <var>t</var>; otherwise, it rounds <var>x</var> to precision
<code>EXP(x)-emin+1</code> according to rounding mode <var>rnd</var> and previous
ternary value <var>t</var>, avoiding double rounding problems. 
<code>PREC(x)</code> is not modified by this function. 
<var>rnd</var> and <var>t</var> must be the used rounding mode for computing <var>x</var>
and the returned ternary value when computing <var>x</var>. 
The subnormal exponent range is from <code>emin</code> to <code>emin+PREC(x)-1</code>. 
This functions assumes that <code>emax-emin &gt;= PREC(x)</code>. 
Note that unlike most functions, the result is compared to the exact one,
not the input value <var>x</var>, i.e. the ternary value is propagated. 
This is a preliminary interface. 
</p></blockquote></div>

   <p>This is an example of how to emulate double IEEE-754 arithmetic
using MPFR:

<pre class="example">     {
       mpfr_t xa, xb;
       int i;
       volatile double a, b;
     
       mpfr_set_default_prec (53);
       mpfr_set_emin (-1073);
       mpfr_set_emax (1021);
     
       mpfr_init (xa); mpfr_init (xb);
     
       b = 34.3; mpfr_set_d (xb, b, GMP_RNDN);
       a = 0x1.1235P-1021; mpfr_set_d (xa, a, GMP_RNDN);
     
       a /= b;
       i = mpfr_div (xa, xa, xb, GMP_RNDN);
       i = mpfr_subnormalize (xa, i, GMP_RNDN);
     
       mpfr_clear (xa); mpfr_clear (xb);
     }
</pre>
   <p>Warning: this emulates a double IEEE-754 arithmetic with exact rounding
in the subnormal range, which may not be the case for your hardware.

<div class="defun">
&mdash; Function: void <b>mpfr_clear_underflow</b> (<var>void</var>)<var><a name="index-mpfr_005fclear_005funderflow-243"></a></var><br>
&mdash; Function: void <b>mpfr_clear_overflow</b> (<var>void</var>)<var><a name="index-mpfr_005fclear_005foverflow-244"></a></var><br>
&mdash; Function: void <b>mpfr_clear_nanflag</b> (<var>void</var>)<var><a name="index-mpfr_005fclear_005fnanflag-245"></a></var><br>
&mdash; Function: void <b>mpfr_clear_inexflag</b> (<var>void</var>)<var><a name="index-mpfr_005fclear_005finexflag-246"></a></var><br>
&mdash; Function: void <b>mpfr_clear_erangeflag</b> (<var>void</var>)<var><a name="index-mpfr_005fclear_005ferangeflag-247"></a></var><br>
<blockquote><p>Clear the underflow, overflow, invalid, inexact and erange flags. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_set_underflow</b> (<var>void</var>)<var><a name="index-mpfr_005fset_005funderflow-248"></a></var><br>
&mdash; Function: void <b>mpfr_set_overflow</b> (<var>void</var>)<var><a name="index-mpfr_005fset_005foverflow-249"></a></var><br>
&mdash; Function: void <b>mpfr_set_nanflag</b> (<var>void</var>)<var><a name="index-mpfr_005fset_005fnanflag-250"></a></var><br>
&mdash; Function: void <b>mpfr_set_inexflag</b> (<var>void</var>)<var><a name="index-mpfr_005fset_005finexflag-251"></a></var><br>
&mdash; Function: void <b>mpfr_set_erangeflag</b> (<var>void</var>)<var><a name="index-mpfr_005fset_005ferangeflag-252"></a></var><br>
<blockquote><p>Set the underflow, overflow, invalid, inexact and erange flags. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_clear_flags</b> (<var>void</var>)<var><a name="index-mpfr_005fclear_005fflags-253"></a></var><br>
<blockquote><p>Clear all global flags (underflow, overflow, inexact, invalid, erange). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_underflow_p</b> (<var>void</var>)<var><a name="index-mpfr_005funderflow_005fp-254"></a></var><br>
&mdash; Function: int <b>mpfr_overflow_p</b> (<var>void</var>)<var><a name="index-mpfr_005foverflow_005fp-255"></a></var><br>
&mdash; Function: int <b>mpfr_nanflag_p</b> (<var>void</var>)<var><a name="index-mpfr_005fnanflag_005fp-256"></a></var><br>
&mdash; Function: int <b>mpfr_inexflag_p</b> (<var>void</var>)<var><a name="index-mpfr_005finexflag_005fp-257"></a></var><br>
&mdash; Function: int <b>mpfr_erangeflag_p</b> (<var>void</var>)<var><a name="index-mpfr_005ferangeflag_005fp-258"></a></var><br>
<blockquote><p>Return the corresponding (underflow, overflow, invalid, inexact, erange)
flag, which is non-zero iff the flag is set. 
</p></blockquote></div>

<div class="node">
<p><hr>
<a name="Advanced-Functions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Compatibility-with-MPF">Compatibility with MPF</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Exceptions">Exceptions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.13 Advanced Functions</h3>

<p><a name="index-Advanced-Functions-259"></a>
All the given interfaces are preliminary. They might change incompatibly in
future revisions.

<div class="defun">
&mdash; Macro: <b>MPFR_DECL_INIT</b> (<var>name, prec</var>)<var><a name="index-MPFR_005fDECL_005fINIT-260"></a></var><br>
<blockquote><p>This macro declares <var>name</var> as an automatic variable of type <code>mpfr_t</code>,
initializes it and sets its precision to be <strong>exactly</strong> <var>prec</var> bits
and its value to NaN. <var>name</var> must be a valid identifier. 
You must use this macro in the declaration section. This macro is much faster than using <code>mpfr_init2</code> but has some
drawbacks:

          <ul>
<li>You <strong>must not</strong> call <code>mpfr_clear</code> with variables
created with this macro (The storage is allocated at the point of declaration
and deallocated when the brace-level is exited.). 
<li>You <strong>can not</strong> change their precision. 
<li>You <strong>should not</strong> create variables with huge precision with this macro. 
<li>Your compiler must support <span class="samp">Non-Constant Initializers</span> (standard
in C++ and ISO C99) and <span class="samp">Token Pasting</span>
(standard in ISO C89). If <var>prec</var> is not a compiler constant, your compiler
must support <span class="samp">Variable-length automatic arrays</span> (standard in ISO C99). 
<span class="samp">GCC 2.95.3</span> supports all these features. 
</ul>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_inits</b> (<var>mpfr_t x, ...</var>)<var><a name="index-mpfr_005finits-261"></a></var><br>
<blockquote><p>Initialize all the <code>mpfr_t</code> variables of the given <code>va_list</code>,
set their precision to be the default precision and their value to NaN. 
See <code>mpfr_init</code> for more details. 
The <code>va_list</code> is assumed to be composed only of type <code>mpfr_t</code>. 
It begins from <var>x</var>. It ends when it encounters a null pointer. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_inits2</b> (<var>mp_prec_t prec, mpfr_t x, ...</var>)<var><a name="index-mpfr_005finits2-262"></a></var><br>
<blockquote><p>Initialize all the <code>mpfr_t</code> variables of the given <code>va_list</code>,
set their precision to be <strong>exactly</strong>
<var>prec</var> bits and their value to NaN. 
See <code>mpfr_init2</code> for more details. 
The <code>va_list</code> is assumed to be composed only of type <code>mpfr_t</code>. 
It begins from <var>x</var>. It ends when it encounters a null pointer. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_clears</b> (<var>mpfr_t x, ...</var>)<var><a name="index-mpfr_005fclears-263"></a></var><br>
<blockquote><p>Free the space occupied by all the <code>mpfr_t</code> variables of the given
<code>va_list</code>. See <code>mpfr_clear</code> for more details. 
The <code>va_list</code> is assumed to be composed only of type <code>mpfr_t</code>. 
It begins from <var>x</var>. It ends when it encounters a null pointer. 
</p></blockquote></div>

   <p>Here is an example of how to use multiple initialization functions:

<pre class="example">     {
       mpfr_t x, y, z, t;
       mpfr_inits2 (256, x, y, z, t, (void *) 0);
       ...
       mpfr_clears (x, y, z, t, (void *) 0);
     }
</pre>
   <div class="node">
<p><hr>
<a name="Compatibility-with-MPF"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Custom-interface">Custom interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Advanced-Functions">Advanced Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<h3 class="section">5.14 Compatibility with MPF</h3>

<p><a name="index-Compatibility-with-MPF-264"></a>
A header file <span class="file">mpf2mpfr.h</span> is included in the distribution of MPFR for
compatibility with the GNU MP class MPF. 
After inserting the following two lines after the <code>#include &lt;gmp.h&gt;</code>
line,
<pre class="verbatim">
#include &lt;mpfr.h>
#include &lt;mpf2mpfr.h>
</pre>
any program written for
MPF can be compiled directly with MPFR without any changes. 
All operations are then performed with the default MPFR rounding mode,
which can be reset with <code>mpfr_set_default_rounding_mode</code>.

   <p>Warning: the <code>mpf_init</code> and <code>mpf_init2</code> functions initialize
to zero, whereas the corresponding <code>mpfr</code> functions initialize to NaN:
this is useful to detect uninitialized values, but is slightly incompatible
with <code>mpf</code>.

<div class="defun">
&mdash; Function: void <b>mpfr_set_prec_raw</b> (<var>mpfr_t x, mp_prec_t prec</var>)<var><a name="index-mpfr_005fset_005fprec_005fraw-265"></a></var><br>
<blockquote><p>Reset the precision of <var>x</var> to be <strong>exactly</strong> <var>prec</var> bits. 
The only difference with <code>mpfr_set_prec</code> is that <var>prec</var> is assumed to
be small enough so that the mantissa fits into the current allocated memory
space for <var>x</var>. Otherwise the behavior is undefined. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_eq</b> (<var>mpfr_t op1, mpfr_t op2, unsigned long int op3</var>)<var><a name="index-mpfr_005feq-266"></a></var><br>
<blockquote><p>Return non-zero if <var>op1</var> and <var>op2</var> are both non-zero ordinary
numbers with the same exponent and the same first <var>op3</var> bits, both
zero, or both infinities of the same sign. Return zero otherwise. This
function is defined for compatibility with <code>mpf</code>, but does not
make much sense. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_reldiff</b> (<var>mpfr_t rop, mpfr_t op1, mpfr_t op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005freldiff-267"></a></var><br>
<blockquote><p>Compute the relative difference between <var>op1</var> and <var>op2</var>
and store the result in <var>rop</var>. 
This function does not guarantee the exact rounding on the relative difference;
it just computes |<var>op1</var>-<var>op2</var>|/<var>op1</var>, using the
rounding mode <var>rnd</var> for all operations and the precision of <var>rop</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_mul_2exp</b> (<var>mpfr_t rop, mpfr_t op1, unsigned long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fmul_005f2exp-268"></a></var><br>
&mdash; Function: int <b>mpfr_div_2exp</b> (<var>mpfr_t rop, mpfr_t op1, unsigned long int op2, mp_rnd_t rnd</var>)<var><a name="index-mpfr_005fdiv_005f2exp-269"></a></var><br>
<blockquote><p>See <code>mpfr_mul_2ui</code> and <code>mpfr_div_2ui</code>. These functions are only kept
for compatibility with MPF. 
</p></blockquote></div>

<div class="node">
<p><hr>
<a name="Custom-interface"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Internals">Internals</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Compatibility-with-MPF">Compatibility with MPF</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<h3 class="section">5.15 Custom interface</h3>

<p><a name="index-Custom-interface-270"></a>
Some applications use a stack to handle the memory and their objects. 
However, the MPFR memory design is not well suited for such a thing. So that
such applications are able to use MPFR, an auxiliary memory interface has
been created: the Custom Interface.

   <p>The following interface allows them to use MPFR in two ways:
     <ul>
<li>Either they directly store the MPFR FP number as a <code>mpfr_t</code>
on the stack. 
<li>Either they store their own representation of a FP number on the
stack and construct a new temporary <code>mpfr_t</code> each time it is needed. 
</ul>
   Nothing has to be done to destroy the FP numbers except garbaging the used
memory: all the memory stuff (allocating, destroying, garbaging) is kept to
the application.

   <p>Each function is this interface is also implemented as a macro for
efficiency reasons.

   <p>Note 1: MPFR functions may still initialize temporary FP numbers
using standard mpfr_init. See Custom Allocation (GNU MP).

   <p>Note 2: MPFR functions may use the cached functions (mpfr_const_pi for
example), even if they are not explicitly called. You have to call
<code>mpfr_free_cache</code> each time you garbage the memory iff mpfr_init, through
GMP Custom Allocation, allocates its memory on the application stack.

   <p>Note 3: This interface is preliminary.

<div class="defun">
&mdash; Function: size_t <b>mpfr_custom_get_size</b> (<var>mp_prec_t prec</var>)<var><a name="index-mpfr_005fcustom_005fget_005fsize-271"></a></var><br>
<blockquote><p>Return the needed size in bytes to store the mantissa of a FP number
of precision <var>prec</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_custom_init</b> (<var>void *mantissa, mp_prec_t prec</var>)<var><a name="index-mpfr_005fcustom_005finit-272"></a></var><br>
<blockquote><p>Initialize a mantissa of precision <var>prec</var>. 
<var>mantissa</var> must be an area of <code>mpfr_custom_get_size (prec)</code> bytes
at least and be suitably aligned for an array of <code>mp_limb_t</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_custom_init_set</b> (<var>mpfr_t x, int kind, mp_exp_t exp, mp_prec_t prec, void *mantissa</var>)<var><a name="index-mpfr_005fcustom_005finit_005fset-273"></a></var><br>
<blockquote><p>Perform a dummy initialization of a <code>mpfr_t</code> and set it to:
          <ul>
<li>if <code>ABS(kind) == MPFR_NAN_LIND</code>, <var>x</var> is set to NaN;
<li>if <code>ABS(kind) == MPFR_INF_KIND</code>, <var>x</var> is set to the infinity
of sign <code>sign(kind)</code>;
<li>if <code>ABS(kind) == MPFR_ZERO_KIND</code>, <var>x</var> is set to the zero of
sign <code>sign(kind)</code>;
<li>if <code>ABS(kind) == MPFR_REGULAR_KIND</code>, <var>x</var> is set to a regular
number: <code>x = sign(kind)*mantissa*2^exp</code>
</ul>
        In all cases, it uses <var>mantissa</var> directly for further computing
involving <var>x</var>. It will not allocate anything. 
A FP number initialized with this function cannot be resized using
<code>mpfr_set_prec</code>, or cleared using <code>mpfr_clear</code>! 
<var>mantissa</var> must have been initialized with <code>mpfr_custom_init</code>
using the same precision <var>prec</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_custom_get_kind</b> (<var>mpfr_t x</var>)<var><a name="index-mpfr_005fcustom_005fget_005fkind-274"></a></var><br>
<blockquote><p>Return the current kind of a <code>mpfr_t</code> as used by
<code>mpfr_custom_init_set</code>. 
The behavior of this function for any <code>mpfr_t</code> not initialized
with <code>mpfr_custom_init_set</code> is undefined. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>*mpfr_custom_get_mantissa</b> (<var>mpfr_t x</var>)<var><a name="index-_002ampfr_005fcustom_005fget_005fmantissa-275"></a></var><br>
<blockquote><p>Return a pointer to the mantissa used by a <code>mpfr_t</code> initialized with
<code>mpfr_custom_init_set</code>. 
The behavior of this function for any <code>mpfr_t</code> not initialized
with <code>mpfr_custom_init_set</code> is undefined. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: mp_exp_t <b>mpfr_custom_get_exp</b> (<var>mpfr_t x</var>)<var><a name="index-mpfr_005fcustom_005fget_005fexp-276"></a></var><br>
<blockquote><p>Return the exponent of <var>x</var>, assuming that <var>x</var> is a non-zero ordinary
number. The return value for NaN, Infinity or Zero is unspecified but doesn't
produced any trap. 
The behavior of this function for any <code>mpfr_t</code> not initialized
with <code>mpfr_custom_init_set</code> is undefined. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_custom_move</b> (<var>mpfr_t x, void *new_position</var>)<var><a name="index-mpfr_005fcustom_005fmove-277"></a></var><br>
<blockquote><p>Inform MPFR that the mantissa has moved due to a garbage collect
and update its new position to <code>new_position</code>. 
However the application has to move the mantissa and the <code>mpfr_t</code> itself. 
The behavior of this function for any <code>mpfr_t</code> not initialized
with <code>mpfr_custom_init_set</code> is undefined. 
</p></blockquote></div>

   <p>See the test suite for examples.

<div class="node">
<p><hr>
<a name="Internals"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Custom-interface">Custom interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#MPFR-Interface">MPFR Interface</a>
<br>
</div>

<h3 class="section">5.16 Internals</h3>

<p><a name="index-Internals-278"></a>
The following types and
functions were mainly designed for the implementation of <code>mpfr</code>,
but may be useful for users too. 
However no upward compatibility is guaranteed. 
You may need to include <span class="file">mpfr-impl.h</span> to use them.

   <p>The <code>mpfr_t</code> type consists of four fields.

     <ul>
<li>The <code>_mpfr_prec</code> field is used to store the precision of
the variable (in bits); this is not less than <code>MPFR_PREC_MIN</code>.

     <li>The <code>_mpfr_sign</code> field is used to store the sign of the variable.

     <li>The <code>_mpfr_exp</code> field stores the exponent. 
An exponent of 0 means a radix point just above the most significant
limb.  Non-zero values n are a multiplier 2^n relative to that
point. 
A NaN, an Infinity and a Zero are indicated by a special value of the exponent.

     <li>Finally, the <code>_mpfr_d</code> is a pointer to the limbs, least
significant limbs stored first. 
The number of limbs in use is controlled by <code>_mpfr_prec</code>, namely
ceil(<code>_mpfr_prec</code>/<code>mp_bits_per_limb</code>). 
Non-singular values always have the most significant bit of the most
significant limb set to 1.  When the precision does not correspond to a
whole number of limbs, the excess bits at the low end of the data are zero.

   </ul>

<!-- @deftypefun int mpfr_add_one_ulp (mpfr_t @var{x}, mp_rnd_t @var{rnd}) -->
<!-- Add one unit in last place (ulp) to @var{x} if @var{x} is finite -->
<!-- and positive, subtract one ulp if @var{x} is finite and negative; -->
<!-- otherwise, @var{x} is not changed. -->
<!-- The return value is zero unless an overflow occurs, in which case the -->
<!-- @code{mpfr_add_one_ulp} function behaves like a conventional addition. -->
<!-- @end deftypefun -->
<!-- @deftypefun int mpfr_sub_one_ulp (mpfr_t @var{x}, mp_rnd_t @var{rnd}) -->
<!-- Subtract one ulp to @var{x} if @var{x} is finite and positive, add one -->
<!-- ulp if @var{x} is finite and negative; otherwise, @var{x} is not changed. -->
<!-- The return value is zero unless an underflow occurs, in which case the -->
<!-- @code{mpfr_sub_one_ulp} function behaves like a conventional subtraction. -->
<!-- @end deftypefun -->
<div class="defun">
&mdash; Function: int <b>mpfr_can_round</b> (<var>mpfr_t b, mp_exp_t err, mp_rnd_t rnd1, mp_rnd_t rnd2, mp_prec_t prec</var>)<var><a name="index-mpfr_005fcan_005fround-279"></a></var><br>
<blockquote><p>Assuming <var>b</var> is an approximation of an unknown number
<var>x</var> in the direction <var>rnd1</var> with error at most two to the power
E(b)-<var>err</var> where E(b) is the exponent of <var>b</var>, return a non-zero
value if one is able to round exactly <var>x</var> to precision
<var>prec</var> with the direction <var>rnd2</var>,
and 0 otherwise (including for NaN and Inf). 
This function <strong>does not modify</strong> its arguments. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: double <b>mpfr_get_d1</b> (<var>mpfr_t op</var>)<var><a name="index-mpfr_005fget_005fd1-280"></a></var><br>
<blockquote><p>Convert <var>op</var> to a <code>double</code>, using the default MPFR rounding mode
(see function <code>mpfr_set_default_rounding_mode</code>). This function is
obsolete. 
</p></blockquote></div>

<!-- @deftypefun void mpfr_set_str_binary (mpfr_t @var{x}, const char *@var{s}) -->
<!-- Set @var{x} to the value of the binary number in string @var{s}, which has to -->
<!-- be of the -->
<!-- form +/-xxxx.xxxxxxEyy. The exponent is read in decimal, but is interpreted -->
<!-- as the power of two to be multiplied by the mantissa. -->
<!-- The mantissa length of @var{s} has to be less or equal to the precision of -->
<!-- @var{x}, otherwise an error occurs. -->
<!-- If @var{s} starts with @code{N}, it is interpreted as NaN (Not-a-Number); -->
<!-- if it starts with @code{I} after the sign, it is interpreted as infinity, -->
<!-- with the corresponding sign. -->
<!-- @end deftypefun -->
<!-- @deftypefun void mpfr_print_binary (mpfr_t @var{float}) -->
<!-- Output @var{float} on stdout -->
<!-- in raw binary format (the exponent is written in decimal, yet). -->
<!-- @end deftypefun -->
<div class="node">
<p><hr>
<a name="Contributors"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#References">References</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#MPFR-Interface">MPFR Interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="unnumbered">Contributors</h2>

<p>The main developers consist of Guillaume Hanrot, Vincent Lef&egrave;vre,
Patrick P&eacute;lissier and Paul Zimmermann.

   <p>We would like to thank Jean-Michel Muller and Joris van der Hoeven for very
fruitful discussions at the beginning of that project, Torbj&ouml;rn Granlund
and Kevin Ryde for their help about design issues,
and Nathalie Revol for her careful reading of a previous version of
this documentation. 
Kevin Ryde did a tremendous job for the portability of MPFR,
and integrating it into GMP 4.x;
alas the GMP developers decided in January 2004 not to include MPFR any more.

   <p>Sylvie Boldo from ENS-Lyon, France,
contributed the functions <code>mpfr_agm</code> and <code>mpfr_log</code>. 
Emmanuel Jeandel, from ENS-Lyon too,
contributed the generic hypergeometric code in
<code>generic.c</code>, as well as the <code>mpfr_exp3</code>,
a first implementation of the sine and cosine,
and improved versions of
<code>mpfr_const_log2</code> and <code>mpfr_const_pi</code>. 
Mathieu Dutour contributed the functions <code>mpfr_atan</code> and <code>mpfr_asin</code>,
and a previous version of <code>mpfr_gamma</code>;
David Daney contributed the hyperbolic and inverse hyperbolic functions,
the base-2 exponential, and the factorial function. Fabrice Rouillier
contributed the original version of <span class="file">mul_ui.c</span>, the <span class="file">gmp_op.c</span>
file, and helped to the Windows porting. 
Jean-Luc R&eacute;my contributed the <code>mpfr_zeta</code> code. 
Ludovic Meunier helped in the design of the <code>mpfr_erf</code> code.

   <p>The development of the MPFR library would not have been possible without the
continuous support of LORIA, INRIA and INRIA Lorraine. 
The development of MPFR was also supported by a grant
(202F0659 00 MPN 121) from the Conseil R&eacute;gional de Lorraine in 2002.

<div class="node">
<p><hr>
<a name="References"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Contributors">Contributors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="unnumbered">References</h2>

     <ul>
<li>Torbj&ouml;rn Granlund, "GNU MP: The GNU Multiple Precision Arithmetic Library",
  version 4.1.2, 2002.

     <li>IEEE standard for binary floating-point arithmetic, Technical Report
ANSI-IEEE Standard 754-1985, New York, 1985. 
Approved March 21, 1985: IEEE Standards Board; approved July 26,
  1985: American National Standards Institute, 18 pages.

     <li>Donald E. Knuth, "The Art of Computer Programming", vol 2,
"Seminumerical Algorithms", 2nd edition, Addison-Wesley, 1981.

     <li>Jean-Michel Muller, "Elementary Functions, Algorithms and Implementation",
Birkhauser, Boston, 1997.

</ul>

<div class="node">
<p><hr>
<a name="GNU-Free-Documentation-License"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Concept-Index">Concept Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#References">References</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="appendix">Appendix A GNU Free Documentation License</h2>

<p><a name="index-GNU-Free-Documentation-License-281"></a>

<!-- GMP tweak: Have this in gmp.texi to help texinfo-mode -->
<!-- @node GNU Free Documentation License -->
<!-- @appendixsec GNU Free Documentation License -->
<p><a name="index-FDL_002c-GNU-Free-Documentation-License-282"></a><div align="center">Version 1.1, March 2000</div>

<pre class="display">     Copyright &copy; 2000 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
     
     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.
</pre>
     <ol type=1 start=0>
<li>PREAMBLE

     <p>The purpose of this License is to make a manual, textbook, or other
written document <dfn>free</dfn> in the sense of freedom: to assure everyone
the effective freedom to copy and redistribute it, with or without
modifying it, either commercially or noncommercially.  Secondarily,
this License preserves for the author and publisher a way to get
credit for their work, while not being considered responsible for
modifications made by others.

     <p>This License is a kind of &ldquo;copyleft&rdquo;, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

     <p>We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.

     <li>APPLICABILITY AND DEFINITIONS

     <p>This License applies to any manual or other work that contains a
notice placed by the copyright holder saying it can be distributed
under the terms of this License.  The &ldquo;Document&rdquo;, below, refers to any
such manual or work.  Any member of the public is a licensee, and is
addressed as &ldquo;you&rdquo;.

     <p>A &ldquo;Modified Version&rdquo; of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

     <p>A &ldquo;Secondary Section&rdquo; is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject.  (For example, if the Document is in part a
textbook of mathematics, a Secondary Section may not explain any
mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

     <p>The &ldquo;Invariant Sections&rdquo; are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.

     <p>The &ldquo;Cover Texts&rdquo; are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.

     <p>A &ldquo;Transparent&rdquo; copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, whose contents can be viewed and edited directly and
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup has been designed to thwart or discourage
subsequent modification by readers is not Transparent.  A copy that is
not &ldquo;Transparent&rdquo; is called &ldquo;Opaque&rdquo;.

     <p>Examples of suitable formats for Transparent copies include plain
<span class="sc">ascii</span> without markup, Texinfo input format, LaTeX input format,
<acronym>SGML</acronym> or <acronym>XML</acronym> using a publicly available
<acronym>DTD</acronym>, and standard-conforming simple <acronym>HTML</acronym> designed
for human modification.  Opaque formats include PostScript,
<acronym>PDF</acronym>, proprietary formats that can be read and edited only by
proprietary word processors, <acronym>SGML</acronym> or <acronym>XML</acronym> for which
the <acronym>DTD</acronym> and/or processing tools are not generally available,
and the machine-generated <acronym>HTML</acronym> produced by some word
processors for output purposes only.

     <p>The &ldquo;Title Page&rdquo; means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, &ldquo;Title Page&rdquo; means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.

     <li>VERBATIM COPYING

     <p>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

     <p>You may also lend copies, under the same conditions stated above, and
you may publicly display copies.

     <li>COPYING IN QUANTITY

     <p>If you publish printed copies of the Document numbering more than 100,
and the Document's license notice requires Cover Texts, you must enclose
the copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition. 
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

     <p>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

     <p>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a publicly-accessible computer-network location containing a complete
Transparent copy of the Document, free of added material, which the
general network-using public has access to download anonymously at no
charge using public-standard network protocols.  If you use the latter
option, you must take reasonably prudent steps, when you begin
distribution of Opaque copies in quantity, to ensure that this
Transparent copy will remain thus accessible at the stated location
until at least one year after the last time you distribute an Opaque
copy (directly or through your agents or retailers) of that edition to
the public.

     <p>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.

     <li>MODIFICATIONS

     <p>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:

          <ol type=A start=1>
<li>Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

          <li>List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has less than five).

          <li>State on the Title page the name of the publisher of the
Modified Version, as the publisher.

          <li>Preserve all the copyright notices of the Document.

          <li>Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

          <li>Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

          <li>Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document's license notice.

          <li>Include an unaltered copy of this License.

          <li>Preserve the section entitled &ldquo;History&rdquo;, and its title, and add to
it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section entitled &ldquo;History&rdquo; in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

          <li>Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the &ldquo;History&rdquo; section. 
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

          <li>In any section entitled &ldquo;Acknowledgments&rdquo; or &ldquo;Dedications&rdquo;,
preserve the section's title, and preserve in the section all the
substance and tone of each of the contributor acknowledgments
and/or dedications given therein.

          <li>Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

          <li>Delete any section entitled &ldquo;Endorsements&rdquo;.  Such a section
may not be included in the Modified Version.

          <li>Do not retitle any existing section as &ldquo;Endorsements&rdquo;
or to conflict in title with any Invariant Section.
          </ol>

     <p>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice. 
These titles must be distinct from any other section titles.

     <p>You may add a section entitled &ldquo;Endorsements&rdquo;, provided it contains
nothing but endorsements of your Modified Version by various
parties&mdash;for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

     <p>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

     <p>The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.

     <li>COMBINING DOCUMENTS

     <p>You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice.

     <p>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number. 
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

     <p>In the combination, you must combine any sections entitled &ldquo;History&rdquo;
in the various original documents, forming one section entitled
&ldquo;History&rdquo;; likewise combine any sections entitled &ldquo;Acknowledgments&rdquo;,
and any sections entitled &ldquo;Dedications&rdquo;.  You must delete all sections
entitled &ldquo;Endorsements.&rdquo;

     <li>COLLECTIONS OF DOCUMENTS

     <p>You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

     <p>You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.

     <li>AGGREGATION WITH INDEPENDENT WORKS

     <p>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, does not as a whole count as a Modified Version
of the Document, provided no compilation copyright is claimed for the
compilation.  Such a compilation is called an &ldquo;aggregate&rdquo;, and this
License does not apply to the other self-contained works thus compiled
with the Document, on account of their being thus compiled, if they
are not themselves derivative works of the Document.

     <p>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one quarter
of the entire aggregate, the Document's Cover Texts may be placed on
covers that surround only the Document within the aggregate. 
Otherwise they must appear on covers around the whole aggregate.

     <li>TRANSLATION

     <p>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4. 
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License provided that you also include the
original English version of this License.  In case of a disagreement
between the translation and the original English version of this
License, the original English version will prevail.

     <li>TERMINATION

     <p>You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.

     <li>FUTURE REVISIONS OF THIS LICENSE

     <p>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
<a href="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</a>.

     <p>Each version of the License is given a distinguishing version number. 
If the Document specifies that a particular numbered version of this
License &ldquo;or any later version&rdquo; applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.
        </ol>

<!-- GMP tweak: Use @appendixsec -->
<!-- @appendixsubsec ADDENDUM: How to use this License for your documents -->
<h3 class="appendixsec">A.1 ADDENDUM: How to use this License for your documents</h3>

<p>To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:

<pre class="smallexample">       Copyright (C)  <var>year</var>  <var>your name</var>.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.1
       or any later version published by the Free Software Foundation;
       with the Invariant Sections being <var>list their titles</var>, with the
       Front-Cover Texts being <var>list</var>, and with the Back-Cover Texts being <var>list</var>.
       A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.
</pre>
   <p>If you have no Invariant Sections, write &ldquo;with no Invariant Sections&rdquo;
instead of saying which ones are invariant.  If you have no
Front-Cover Texts, write &ldquo;no Front-Cover Texts&rdquo; instead of
&ldquo;Front-Cover Texts being <var>list</var>&rdquo;; likewise for Back-Cover Texts.

   <p>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.

<!-- Local Variables: -->
<!-- ispell-local-pdict: "ispell-dict" -->
<!-- End: -->
<div class="node">
<p><hr>
<a name="Concept-Index"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Function-Index">Function Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="unnumbered">Concept Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-Accuracy-16">Accuracy</a>: <a href="#MPFR-Interface">MPFR Interface</a></li>
<li><a href="#index-Advanced-Functions-259">Advanced Functions</a>: <a href="#Advanced-Functions">Advanced Functions</a></li>
<li><a href="#index-Arithmetic-functions-78">Arithmetic functions</a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-Assignment-functions-25">Assignment functions</a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-Basic-arithmetic-functions-76">Basic arithmetic functions</a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-Combined-initialization-and-assignment-functions-45">Combined initialization and assignment functions</a>: <a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></li>
<li><a href="#index-Comparison-functions-121">Comparison functions</a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-Compatibility-with-MPF-264">Compatibility with MPF</a>: <a href="#Compatibility-with-MPF">Compatibility with MPF</a></li>
<li><a href="#index-Conditions-for-copying-MPFR-2">Conditions for copying MPFR</a>: <a href="#Copying">Copying</a></li>
<li><a href="#index-Conversion-functions-55">Conversion functions</a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-Copying-conditions-1">Copying conditions</a>: <a href="#Copying">Copying</a></li>
<li><a href="#index-Custom-interface-270">Custom interface</a>: <a href="#Custom-interface">Custom interface</a></li>
<li><a href="#index-Exceptions-232">Exceptions</a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-FDL_002c-GNU-Free-Documentation-License-282">FDL, GNU Free Documentation License</a>: <a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a></li>
<li><a href="#index-Float-arithmetic-functions-77">Float arithmetic functions</a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-Float-comparisons-functions-120">Float comparisons functions</a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-Float-functions-14">Float functions</a>: <a href="#MPFR-Interface">MPFR Interface</a></li>
<li><a href="#index-Float-input-and-output-functions-190">Float input and output functions</a>: <a href="#Input-and-Output-Functions">Input and Output Functions</a></li>
<li><a href="#index-Floating_002dpoint-functions-13">Floating-point functions</a>: <a href="#MPFR-Interface">MPFR Interface</a></li>
<li><a href="#index-Floating_002dpoint-number-6">Floating-point number</a>: <a href="#MPFR-Basics">MPFR Basics</a></li>
<li><a href="#index-GNU-Free-Documentation-License-281">GNU Free Documentation License</a>: <a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a></li>
<li><a href="#index-I_002fO-functions-193">I/O functions</a>: <a href="#Input-and-Output-Functions">Input and Output Functions</a></li>
<li><a href="#index-Initialization-functions-17">Initialization functions</a>: <a href="#Initialization-Functions">Initialization Functions</a></li>
<li><a href="#index-Input-functions-191">Input functions</a>: <a href="#Input-and-Output-Functions">Input and Output Functions</a></li>
<li><a href="#index-Installation-3">Installation</a>: <a href="#Installing-MPFR">Installing MPFR</a></li>
<li><a href="#index-Integer-Related-Functions-196">Integer Related Functions</a>: <a href="#Integer-Related-Functions">Integer Related Functions</a></li>
<li><a href="#index-Internals-278">Internals</a>: <a href="#Internals">Internals</a></li>
<li><a href="#index-Limb-12">Limb</a>: <a href="#MPFR-Basics">MPFR Basics</a></li>
<li><a href="#index-Miscellaneous-float-functions-208">Miscellaneous float functions</a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-_0040file_007bmpfr_002eh_007d-5"><span class="file">mpfr.h</span></a>: <a href="#MPFR-Basics">MPFR Basics</a></li>
<li><a href="#index-Output-functions-192">Output functions</a>: <a href="#Input-and-Output-Functions">Input and Output Functions</a></li>
<li><a href="#index-Precision-15">Precision</a>: <a href="#MPFR-Interface">MPFR Interface</a></li>
<li><a href="#index-Precision-8">Precision</a>: <a href="#MPFR-Basics">MPFR Basics</a></li>
<li><a href="#index-Reporting-bugs-4">Reporting bugs</a>: <a href="#Reporting-Bugs">Reporting Bugs</a></li>
<li><a href="#index-Rounding-Modes-226">Rounding Modes</a>: <a href="#Rounding-Modes">Rounding Modes</a></li>
<li><a href="#index-Rounding-Modes-10">Rounding Modes</a>: <a href="#MPFR-Basics">MPFR Basics</a></li>
<li><a href="#index-Special-functions-145">Special functions</a>: <a href="#Special-Functions">Special Functions</a></li>
</ul><div class="node">
<p><hr>
<a name="Function-Index"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Concept-Index">Concept Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="unnumbered">Function and Type Index</h2>



<ul class="index-fn" compact>
<li><a href="#index-_002ampfr_005fcustom_005fget_005fmantissa-275"><code>*mpfr_custom_get_mantissa</code></a>: <a href="#Custom-interface">Custom interface</a></li>
<li><a href="#index-_0040code_007bmp_005fprec_005ft_007d-9"><code>mp_prec_t</code></a>: <a href="#MPFR-Basics">MPFR Basics</a></li>
<li><a href="#index-_0040code_007bmp_005frnd_005ft_007d-11"><code>mp_rnd_t</code></a>: <a href="#MPFR-Basics">MPFR Basics</a></li>
<li><a href="#index-mpfr_005fabs-115"><code>mpfr_abs</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005facos-159"><code>mpfr_acos</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005facosh-169"><code>mpfr_acosh</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fadd-79"><code>mpfr_add</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fadd_005fq-83"><code>mpfr_add_q</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fadd_005fsi-81"><code>mpfr_add_si</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fadd_005fui-80"><code>mpfr_add_ui</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fadd_005fz-82"><code>mpfr_add_z</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fagm-182"><code>mpfr_agm</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fasin-160"><code>mpfr_asin</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fasinh-170"><code>mpfr_asinh</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fatan-161"><code>mpfr_atan</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fatan2-162"><code>mpfr_atan2</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fatanh-171"><code>mpfr_atanh</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fcan_005fround-279"><code>mpfr_can_round</code></a>: <a href="#Internals">Internals</a></li>
<li><a href="#index-mpfr_005fcbrt-106"><code>mpfr_cbrt</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fceil-198"><code>mpfr_ceil</code></a>: <a href="#Integer-Related-Functions">Integer Related Functions</a></li>
<li><a href="#index-mpfr_005fcheck_005frange-241"><code>mpfr_check_range</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fclear-19"><code>mpfr_clear</code></a>: <a href="#Initialization-Functions">Initialization Functions</a></li>
<li><a href="#index-mpfr_005fclear_005ferangeflag-247"><code>mpfr_clear_erangeflag</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fclear_005fflags-253"><code>mpfr_clear_flags</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fclear_005finexflag-246"><code>mpfr_clear_inexflag</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fclear_005fnanflag-245"><code>mpfr_clear_nanflag</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fclear_005foverflow-244"><code>mpfr_clear_overflow</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fclear_005funderflow-243"><code>mpfr_clear_underflow</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fclears-263"><code>mpfr_clears</code></a>: <a href="#Advanced-Functions">Advanced Functions</a></li>
<li><a href="#index-mpfr_005fcmp-122"><code>mpfr_cmp</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fcmp_005fd-125"><code>mpfr_cmp_d</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fcmp_005ff-129"><code>mpfr_cmp_f</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fcmp_005fld-126"><code>mpfr_cmp_ld</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fcmp_005fq-128"><code>mpfr_cmp_q</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fcmp_005fsi-124"><code>mpfr_cmp_si</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fcmp_005fsi_005f2exp-131"><code>mpfr_cmp_si_2exp</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fcmp_005fui-123"><code>mpfr_cmp_ui</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fcmp_005fui_005f2exp-130"><code>mpfr_cmp_ui_2exp</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fcmp_005fz-127"><code>mpfr_cmp_z</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fcmpabs-132"><code>mpfr_cmpabs</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fconst_005fcatalan-187"><code>mpfr_const_catalan</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fconst_005feuler-186"><code>mpfr_const_euler</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fconst_005flog2-184"><code>mpfr_const_log2</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fconst_005fpi-185"><code>mpfr_const_pi</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fcos-152"><code>mpfr_cos</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fcosh-163"><code>mpfr_cosh</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fcot-157"><code>mpfr_cot</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fcoth-168"><code>mpfr_coth</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fcsc-156"><code>mpfr_csc</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fcsch-167"><code>mpfr_csch</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fcustom_005fget_005fexp-276"><code>mpfr_custom_get_exp</code></a>: <a href="#Custom-interface">Custom interface</a></li>
<li><a href="#index-mpfr_005fcustom_005fget_005fkind-274"><code>mpfr_custom_get_kind</code></a>: <a href="#Custom-interface">Custom interface</a></li>
<li><a href="#index-mpfr_005fcustom_005fget_005fsize-271"><code>mpfr_custom_get_size</code></a>: <a href="#Custom-interface">Custom interface</a></li>
<li><a href="#index-mpfr_005fcustom_005finit-272"><code>mpfr_custom_init</code></a>: <a href="#Custom-interface">Custom interface</a></li>
<li><a href="#index-mpfr_005fcustom_005finit_005fset-273"><code>mpfr_custom_init_set</code></a>: <a href="#Custom-interface">Custom interface</a></li>
<li><a href="#index-mpfr_005fcustom_005fmove-277"><code>mpfr_custom_move</code></a>: <a href="#Custom-interface">Custom interface</a></li>
<li><a href="#index-MPFR_005fDECL_005fINIT-260"><code>MPFR_DECL_INIT</code></a>: <a href="#Advanced-Functions">Advanced Functions</a></li>
<li><a href="#index-mpfr_005fdiv-97"><code>mpfr_div</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fdiv_005f2exp-269"><code>mpfr_div_2exp</code></a>: <a href="#Compatibility-with-MPF">Compatibility with MPF</a></li>
<li><a href="#index-mpfr_005fdiv_005f2si-119"><code>mpfr_div_2si</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fdiv_005f2ui-118"><code>mpfr_div_2ui</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fdiv_005fq-103"><code>mpfr_div_q</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fdiv_005fsi-101"><code>mpfr_div_si</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fdiv_005fui-99"><code>mpfr_div_ui</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fdiv_005fz-102"><code>mpfr_div_z</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005feint-175"><code>mpfr_eint</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005feq-266"><code>mpfr_eq</code></a>: <a href="#Compatibility-with-MPF">Compatibility with MPF</a></li>
<li><a href="#index-mpfr_005fequal_005fp-143"><code>mpfr_equal_p</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005ferangeflag_005fp-258"><code>mpfr_erangeflag_p</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005ferf-179"><code>mpfr_erf</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005ferfc-180"><code>mpfr_erfc</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fexp-149"><code>mpfr_exp</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fexp10-151"><code>mpfr_exp10</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fexp2-150"><code>mpfr_exp2</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fexpm1-174"><code>mpfr_expm1</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005ffac_005fui-172"><code>mpfr_fac_ui</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005ffits_005fintmax_005fp-74"><code>mpfr_fits_intmax_p</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005ffits_005fsint_005fp-71"><code>mpfr_fits_sint_p</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005ffits_005fslong_005fp-69"><code>mpfr_fits_slong_p</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005ffits_005fsshort_005fp-73"><code>mpfr_fits_sshort_p</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005ffits_005fuint_005fp-70"><code>mpfr_fits_uint_p</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005ffits_005fuintmax_005fp-75"><code>mpfr_fits_uintmax_p</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005ffits_005fulong_005fp-68"><code>mpfr_fits_ulong_p</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005ffits_005fushort_005fp-72"><code>mpfr_fits_ushort_p</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005ffloor-199"><code>mpfr_floor</code></a>: <a href="#Integer-Related-Functions">Integer Related Functions</a></li>
<li><a href="#index-mpfr_005ffma-181"><code>mpfr_fma</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005ffrac-206"><code>mpfr_frac</code></a>: <a href="#Integer-Related-Functions">Integer Related Functions</a></li>
<li><a href="#index-mpfr_005ffree_005fcache-188"><code>mpfr_free_cache</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005ffree_005fstr-67"><code>mpfr_free_str</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005fgamma-176"><code>mpfr_gamma</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fget_005fd-56"><code>mpfr_get_d</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005fget_005fd1-280"><code>mpfr_get_d1</code></a>: <a href="#Internals">Internals</a></li>
<li><a href="#index-mpfr_005fget_005fd_005f2exp-58"><code>mpfr_get_d_2exp</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005fget_005fdefault_005fprec-22"><code>mpfr_get_default_prec</code></a>: <a href="#Initialization-Functions">Initialization Functions</a></li>
<li><a href="#index-mpfr_005fget_005fdefault_005frounding_005fmode-228"><code>mpfr_get_default_rounding_mode</code></a>: <a href="#Rounding-Modes">Rounding Modes</a></li>
<li><a href="#index-mpfr_005fget_005femax-234"><code>mpfr_get_emax</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fget_005femax_005fmax-240"><code>mpfr_get_emax_max</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fget_005femax_005fmin-239"><code>mpfr_get_emax_min</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fget_005femin-233"><code>mpfr_get_emin</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fget_005femin_005fmax-238"><code>mpfr_get_emin_max</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fget_005femin_005fmin-237"><code>mpfr_get_emin_min</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fget_005fexp-217"><code>mpfr_get_exp</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-mpfr_005fget_005ff-65"><code>mpfr_get_f</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005fget_005fld-57"><code>mpfr_get_ld</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005fget_005fprec-24"><code>mpfr_get_prec</code></a>: <a href="#Initialization-Functions">Initialization Functions</a></li>
<li><a href="#index-mpfr_005fget_005fsi-59"><code>mpfr_get_si</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005fget_005fsj-61"><code>mpfr_get_sj</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005fget_005fstr-66"><code>mpfr_get_str</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005fget_005fui-60"><code>mpfr_get_ui</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005fget_005fuj-62"><code>mpfr_get_uj</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005fget_005fversion-219"><code>mpfr_get_version</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-mpfr_005fget_005fz-64"><code>mpfr_get_z</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005fget_005fz_005fexp-63"><code>mpfr_get_z_exp</code></a>: <a href="#Conversion-Functions">Conversion Functions</a></li>
<li><a href="#index-mpfr_005fgreater_005fp-138"><code>mpfr_greater_p</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fgreaterequal_005fp-139"><code>mpfr_greaterequal_p</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fhypot-183"><code>mpfr_hypot</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005finexflag_005fp-257"><code>mpfr_inexflag_p</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005finf_005fp-134"><code>mpfr_inf_p</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005finit-20"><code>mpfr_init</code></a>: <a href="#Initialization-Functions">Initialization Functions</a></li>
<li><a href="#index-mpfr_005finit2-18"><code>mpfr_init2</code></a>: <a href="#Initialization-Functions">Initialization Functions</a></li>
<li><a href="#index-mpfr_005finit_005fset-46"><code>mpfr_init_set</code></a>: <a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></li>
<li><a href="#index-mpfr_005finit_005fset_005fd-49"><code>mpfr_init_set_d</code></a>: <a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></li>
<li><a href="#index-mpfr_005finit_005fset_005ff-53"><code>mpfr_init_set_f</code></a>: <a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></li>
<li><a href="#index-mpfr_005finit_005fset_005fld-50"><code>mpfr_init_set_ld</code></a>: <a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></li>
<li><a href="#index-mpfr_005finit_005fset_005fq-52"><code>mpfr_init_set_q</code></a>: <a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></li>
<li><a href="#index-mpfr_005finit_005fset_005fsi-48"><code>mpfr_init_set_si</code></a>: <a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></li>
<li><a href="#index-mpfr_005finit_005fset_005fstr-54"><code>mpfr_init_set_str</code></a>: <a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></li>
<li><a href="#index-mpfr_005finit_005fset_005fui-47"><code>mpfr_init_set_ui</code></a>: <a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></li>
<li><a href="#index-mpfr_005finit_005fset_005fz-51"><code>mpfr_init_set_z</code></a>: <a href="#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a></li>
<li><a href="#index-mpfr_005finits-261"><code>mpfr_inits</code></a>: <a href="#Advanced-Functions">Advanced Functions</a></li>
<li><a href="#index-mpfr_005finits2-262"><code>mpfr_inits2</code></a>: <a href="#Advanced-Functions">Advanced Functions</a></li>
<li><a href="#index-mpfr_005finp_005fstr-195"><code>mpfr_inp_str</code></a>: <a href="#Input-and-Output-Functions">Input and Output Functions</a></li>
<li><a href="#index-mpfr_005finteger_005fp-207"><code>mpfr_integer_p</code></a>: <a href="#Integer-Related-Functions">Integer Related Functions</a></li>
<li><a href="#index-mpfr_005fless_005fp-140"><code>mpfr_less_p</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005flessequal_005fp-141"><code>mpfr_lessequal_p</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005flessgreater_005fp-142"><code>mpfr_lessgreater_p</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005flngamma-177"><code>mpfr_lngamma</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005flog-146"><code>mpfr_log</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005flog10-148"><code>mpfr_log10</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005flog1p-173"><code>mpfr_log1p</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005flog2-147"><code>mpfr_log2</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fmax-213"><code>mpfr_max</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-mpfr_005fmin-212"><code>mpfr_min</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-mpfr_005fmul-91"><code>mpfr_mul</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fmul_005f2exp-268"><code>mpfr_mul_2exp</code></a>: <a href="#Compatibility-with-MPF">Compatibility with MPF</a></li>
<li><a href="#index-mpfr_005fmul_005f2si-117"><code>mpfr_mul_2si</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fmul_005f2ui-116"><code>mpfr_mul_2ui</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fmul_005fq-95"><code>mpfr_mul_q</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fmul_005fsi-93"><code>mpfr_mul_si</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fmul_005fui-92"><code>mpfr_mul_ui</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fmul_005fz-94"><code>mpfr_mul_z</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fnan_005fp-133"><code>mpfr_nan_p</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fnanflag_005fp-256"><code>mpfr_nanflag_p</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fneg-114"><code>mpfr_neg</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fnextabove-210"><code>mpfr_nextabove</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-mpfr_005fnextbelow-211"><code>mpfr_nextbelow</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-mpfr_005fnexttoward-209"><code>mpfr_nexttoward</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-mpfr_005fnumber_005fp-135"><code>mpfr_number_p</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fout_005fstr-194"><code>mpfr_out_str</code></a>: <a href="#Input-and-Output-Functions">Input and Output Functions</a></li>
<li><a href="#index-mpfr_005foverflow_005fp-255"><code>mpfr_overflow_p</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fpow-108"><code>mpfr_pow</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fpow_005fsi-110"><code>mpfr_pow_si</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fpow_005fui-109"><code>mpfr_pow_ui</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fpow_005fz-111"><code>mpfr_pow_z</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fprec_005fround-229"><code>mpfr_prec_round</code></a>: <a href="#Rounding-Modes">Rounding Modes</a></li>
<li><a href="#index-mpfr_005fprint_005frnd_005fmode-231"><code>mpfr_print_rnd_mode</code></a>: <a href="#Rounding-Modes">Rounding Modes</a></li>
<li><a href="#index-mpfr_005frandom-215"><code>mpfr_random</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-mpfr_005frandom2-216"><code>mpfr_random2</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-mpfr_005freldiff-267"><code>mpfr_reldiff</code></a>: <a href="#Compatibility-with-MPF">Compatibility with MPF</a></li>
<li><a href="#index-mpfr_005frint-197"><code>mpfr_rint</code></a>: <a href="#Integer-Related-Functions">Integer Related Functions</a></li>
<li><a href="#index-mpfr_005frint_005fceil-202"><code>mpfr_rint_ceil</code></a>: <a href="#Integer-Related-Functions">Integer Related Functions</a></li>
<li><a href="#index-mpfr_005frint_005ffloor-203"><code>mpfr_rint_floor</code></a>: <a href="#Integer-Related-Functions">Integer Related Functions</a></li>
<li><a href="#index-mpfr_005frint_005fround-204"><code>mpfr_rint_round</code></a>: <a href="#Integer-Related-Functions">Integer Related Functions</a></li>
<li><a href="#index-mpfr_005frint_005ftrunc-205"><code>mpfr_rint_trunc</code></a>: <a href="#Integer-Related-Functions">Integer Related Functions</a></li>
<li><a href="#index-mpfr_005froot-107"><code>mpfr_root</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fround-200"><code>mpfr_round</code></a>: <a href="#Integer-Related-Functions">Integer Related Functions</a></li>
<li><a href="#index-mpfr_005fround_005fprec-230"><code>mpfr_round_prec</code></a>: <a href="#Rounding-Modes">Rounding Modes</a></li>
<li><a href="#index-mpfr_005fsec-155"><code>mpfr_sec</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fsech-166"><code>mpfr_sech</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fset-26"><code>mpfr_set</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fd-31"><code>mpfr_set_d</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fdefault_005fprec-21"><code>mpfr_set_default_prec</code></a>: <a href="#Initialization-Functions">Initialization Functions</a></li>
<li><a href="#index-mpfr_005fset_005fdefault_005frounding_005fmode-227"><code>mpfr_set_default_rounding_mode</code></a>: <a href="#Rounding-Modes">Rounding Modes</a></li>
<li><a href="#index-mpfr_005fset_005femax-236"><code>mpfr_set_emax</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fset_005femin-235"><code>mpfr_set_emin</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fset_005ferangeflag-252"><code>mpfr_set_erangeflag</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fset_005fexp-218"><code>mpfr_set_exp</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-mpfr_005fset_005ff-35"><code>mpfr_set_f</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005finexflag-251"><code>mpfr_set_inexflag</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fset_005finf-42"><code>mpfr_set_inf</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fld-32"><code>mpfr_set_ld</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fnan-43"><code>mpfr_set_nan</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fnanflag-250"><code>mpfr_set_nanflag</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fset_005foverflow-249"><code>mpfr_set_overflow</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fset_005fprec-23"><code>mpfr_set_prec</code></a>: <a href="#Initialization-Functions">Initialization Functions</a></li>
<li><a href="#index-mpfr_005fset_005fprec_005fraw-265"><code>mpfr_set_prec_raw</code></a>: <a href="#Compatibility-with-MPF">Compatibility with MPF</a></li>
<li><a href="#index-mpfr_005fset_005fq-34"><code>mpfr_set_q</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fsi-28"><code>mpfr_set_si</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fsi_005f2exp-37"><code>mpfr_set_si_2exp</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fsj-30"><code>mpfr_set_sj</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fsj_005f2exp-39"><code>mpfr_set_sj_2exp</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fstr-40"><code>mpfr_set_str</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fui-27"><code>mpfr_set_ui</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fui_005f2exp-36"><code>mpfr_set_ui_2exp</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fuj-29"><code>mpfr_set_uj</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005fuj_005f2exp-38"><code>mpfr_set_uj_2exp</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fset_005funderflow-248"><code>mpfr_set_underflow</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fset_005fz-33"><code>mpfr_set_z</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fsgn-137"><code>mpfr_sgn</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fsi_005fdiv-100"><code>mpfr_si_div</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fsi_005fsub-87"><code>mpfr_si_sub</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fsin-153"><code>mpfr_sin</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fsin_005fcos-158"><code>mpfr_sin_cos</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fsinh-164"><code>mpfr_sinh</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fsqr-96"><code>mpfr_sqr</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fsqrt-104"><code>mpfr_sqrt</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fsqrt_005fui-105"><code>mpfr_sqrt_ui</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fstrtofr-41"><code>mpfr_strtofr</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-mpfr_005fsub-84"><code>mpfr_sub</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fsub_005fq-90"><code>mpfr_sub_q</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fsub_005fsi-88"><code>mpfr_sub_si</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fsub_005fui-86"><code>mpfr_sub_ui</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fsub_005fz-89"><code>mpfr_sub_z</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fsubnormalize-242"><code>mpfr_subnormalize</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005fsum-189"><code>mpfr_sum</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005fswap-44"><code>mpfr_swap</code></a>: <a href="#Assignment-Functions">Assignment Functions</a></li>
<li><a href="#index-_0040code_007bmpfr_005ft_007d-7"><code>mpfr_t</code></a>: <a href="#MPFR-Basics">MPFR Basics</a></li>
<li><a href="#index-mpfr_005ftan-154"><code>mpfr_tan</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005ftanh-165"><code>mpfr_tanh</code></a>: <a href="#Special-Functions">Special Functions</a></li>
<li><a href="#index-mpfr_005ftrunc-201"><code>mpfr_trunc</code></a>: <a href="#Integer-Related-Functions">Integer Related Functions</a></li>
<li><a href="#index-mpfr_005fui_005fdiv-98"><code>mpfr_ui_div</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fui_005fpow-113"><code>mpfr_ui_pow</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fui_005fpow_005fui-112"><code>mpfr_ui_pow_ui</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005fui_005fsub-85"><code>mpfr_ui_sub</code></a>: <a href="#Basic-Arithmetic-Functions">Basic Arithmetic Functions</a></li>
<li><a href="#index-mpfr_005funderflow_005fp-254"><code>mpfr_underflow_p</code></a>: <a href="#Exceptions">Exceptions</a></li>
<li><a href="#index-mpfr_005funordered_005fp-144"><code>mpfr_unordered_p</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005furandomb-214"><code>mpfr_urandomb</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-MPFR_005fVERSION-220"><code>MPFR_VERSION</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-MPFR_005fVERSION_005fMAJOR-221"><code>MPFR_VERSION_MAJOR</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-MPFR_005fVERSION_005fMINOR-222"><code>MPFR_VERSION_MINOR</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-MPFR_005fVERSION_005fNUM-225"><code>MPFR_VERSION_NUM</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-MPFR_005fVERSION_005fPATCHLEVEL-223"><code>MPFR_VERSION_PATCHLEVEL</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-MPFR_005fVERSION_005fSTRING-224"><code>MPFR_VERSION_STRING</code></a>: <a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#index-mpfr_005fzero_005fp-136"><code>mpfr_zero_p</code></a>: <a href="#Comparison-Functions">Comparison Functions</a></li>
<li><a href="#index-mpfr_005fzeta-178"><code>mpfr_zeta</code></a>: <a href="#Special-Functions">Special Functions</a></li>
   </ul></body></html>

