<title>Frequently Asked Questions about MPFR 0.4</title>
<center><h1>Frequently Asked Questions about MPFR 0.4</h1></center>

<li> <b>When building mpfr, you get the following error:</b> <br>
<ul><tt>
In file included from div_ui.c:26:</br>
/tmp/gmp-3.0/longlong.h:231: warning: string constant runs past end of line</br>
div_ui.c: In function `mpfr_div_ui':</br>
div_ui.c:73: `__gmpn_clz_tab' undeclared (first use in this function)</br>
</tt></ul>
This problem appears with the new version 3.0 of GMP. A workaround is to
swap the include declarations of <tt>gmp-impl.h</tt>
and <tt>longlong.h</tt>. The <tt>libgmp.a</tt> library is now in the
<tt>.libs</tt> subdirectory, whence you have to give <tt>.../gmp-3.0/.libs</tt>
to the Configure script.
<p>

<li> <b>When building mpfr, you get the following error:</b> <br>
<ul><tt>
rnd_mode.c: In function `mpfr_set_machine_rnd_mode':<br>
rnd_mode.c:111: `TONEAREST' undeclared (first use this function)
</tt></ul>
That problems concerns the machine rounding mode control. First check
if your machine supports the ISOC9X standard: check if the file
<tt>/usr/include/fenv.h</tt> exists. If so, then give the <tt>
-D_ISOC9X_SOURCE</tt> option in the Configure script.
If not, check if the machine rounding mode control corresponds to any of
the cases enumerated in the beginning of the <tt>rnd_mode.c</tt> file;
and use the corresponding macro in that case.
If all fails, then you have to add a new case in the <tt>rnd_mode.c</tt> file,
defining the four macros <tt>TOZERO, TOINFP, TONEAREST, TOINFM</tt> which
respectively set the machine rounding mode to zero, plus infinity,
nearest and minus infinity. Please send us the corresponding code so that
we add it in future releases of MPFR.
<p>

<li> <b>When performing the tests, you get the following error:</b> <br>
<ul><tt>
Testing tdiv<br>
mpfr_div failed for n=7.0368760955e+13, d=8.3886090000e+06, prec=24, rnd_mode=1<br>
expected quotient is 8.3886090000e+06, got 8.3886080000e+06<br>
</tt></ul>
This is not a bug from MPFR, but from libm.a. It happens for example on
Alpha under OSF with the -O2 optimization level. A workaround is to add
the option <tt>-ffloat-store</tt>.
<p>
<li> <b>When performing the tests, you get the following error:</b> <br>
<ul><tt>
Testing tdiv<br>
mpfr_div failed for n=1.00000000000000000000e+00, d=2.10263340267725788209e+187, rnd_mode=2<br>
expected quotient is 4.75594080607067333485e-188, got 4.76716286993759699631e-18 (-999517665 ulp)<br>
</tt></ul>
This is not a bug from MPFR, but from libm.a. It happens for example on
old Alpha's under Linux. The bug can be identified by trying the C program
<a href="bug-alpha-linux.c">bug.c</a>
<p>
<li> <b>What are the differences between MPF from GMP and MPFR?</b> <br>
Unlike MPF, the precision of a MPFR variable is the <i>exact</i> number
of bits used for its mantissa. This implies that MPFR results do not depend
on the number of bits (32 or 64 or more) of the underlying architecture.
Also, MPFR provides an additional rounding mode argument to its functions;
furthermore, it is guaranteed that the result of any operation is the nearest
possible floating-point value from the exact result (considering the input
variables as exact values), taking into account the precision of the 
destination variable.
<p>
<li> <b>How to convert my program written using MPF to MPFR?</b> <br>
You need to add 'r' to the function names, and to specify the rounding mode
(GMP_RNDD for rounding towards -infinity, GMP_RNDZ for rounding towards zero,
GMP_RNDU for rounding towards +infinity, and GMP_RNDN for rounding to nearest).
You can also define macros as follows: <br>
<tt>#define mpf_add(a, b, c) mpfr_add(a, b, c, GMP_RNDN)</tt>
<p>
<li> <b>Are there bugs in MPFR?</b> <br>
Yes there are surely several bugs. Please send them to us.
<p>
