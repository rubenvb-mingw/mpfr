diff -Naur mpfr-2.1.0/mpfr.info mpfr-2.1.0-p1/mpfr.info
--- mpfr-2.1.0/mpfr.info	2004-11-03 15:27:10.000000000 +0000
+++ mpfr-2.1.0-p1/mpfr.info	2005-01-23 23:07:31.834786184 +0000
@@ -42,7 +42,7 @@
 
 * Menu:
 
-* Copying::                     GMP Copying Conditions (LGPL).
+* Copying::                     MPFR Copying Conditions (LGPL).
 * Introduction to MPFR::        Brief introduction to MPFR.
 * Installing MPFR::             How to configure and compile the MPFR library.
 * Reporting Bugs::              How to usefully report bugs.
@@ -2429,31 +2429,31 @@
 
 Tag Table:
 Node: Top937
-Node: Copying2235
-Node: Introduction to MPFR3952
-Node: Installing MPFR5630
-Node: Reporting Bugs8303
-Node: MPFR Basics9799
-Node: MPFR Interface15389
-Node: Initialization Functions17421
-Node: Assignment Functions20814
-Node: Combined Initialization and Assignment Functions26697
-Node: Conversion Functions27979
-Node: Basic Arithmetic Functions32952
-Node: Comparison Functions39862
-Node: Special Functions42887
-Node: Input and Output Functions47984
-Node: Integer Related Functions49906
-Node: Miscellaneous Functions52900
-Node: Rounding Modes56769
-Node: Exceptions58118
-Node: Advanced Functions61763
-Node: Compatibility with MPF64368
-Node: Internals66628
-Node: Contributors68652
-Node: References70361
-Node: GNU Free Documentation License71106
-Node: Concept Index91018
-Node: Function Index94807
+Node: Copying2236
+Node: Introduction to MPFR3953
+Node: Installing MPFR5631
+Node: Reporting Bugs8304
+Node: MPFR Basics9800
+Node: MPFR Interface15390
+Node: Initialization Functions17422
+Node: Assignment Functions20815
+Node: Combined Initialization and Assignment Functions26698
+Node: Conversion Functions27980
+Node: Basic Arithmetic Functions32953
+Node: Comparison Functions39863
+Node: Special Functions42888
+Node: Input and Output Functions47985
+Node: Integer Related Functions49907
+Node: Miscellaneous Functions52901
+Node: Rounding Modes56770
+Node: Exceptions58119
+Node: Advanced Functions61764
+Node: Compatibility with MPF64369
+Node: Internals66629
+Node: Contributors68653
+Node: References70362
+Node: GNU Free Documentation License71107
+Node: Concept Index91019
+Node: Function Index94808
 
 End Tag Table
diff -Naur mpfr-2.1.0/mpfr.texi mpfr-2.1.0-p1/mpfr.texi
--- mpfr-2.1.0/mpfr.texi	2004-11-03 15:15:47.000000000 +0000
+++ mpfr-2.1.0-p1/mpfr.texi	2005-01-23 23:06:16.898178280 +0000
@@ -96,7 +96,7 @@
 @end ifnothtml
 
 @menu
-* Copying::                     GMP Copying Conditions (LGPL).
+* Copying::                     MPFR Copying Conditions (LGPL).
 * Introduction to MPFR::        Brief introduction to MPFR.
 * Installing MPFR::             How to configure and compile the MPFR library.
 * Reporting Bugs::              How to usefully report bugs.
@@ -944,7 +944,12 @@
 function (preliminary interface).
 The block is assumed to be @code{strlen(@var{str})+1} bytes.
 For more information about how it is done:
+@ifnothtml
 @pxref{Custom Allocation,,, gmp,GNU MP}.
+@end ifnothtml
+@ifhtml
+see Custom Allocation (GNU MP).
+@end ifhtml
 @end deftypefun
 
 @deftypefun int mpfr_fits_ulong_p (mpfr_t @var{op}, mp_rnd_t @var{rnd})
diff -Naur mpfr-2.1.0-p1/Makefile.in mpfr-2.1.0-p2/Makefile.in
--- mpfr-2.1.0-p1/Makefile.in	2004-11-03 15:26:14.000000000 +0000
+++ mpfr-2.1.0-p2/Makefile.in	2005-01-23 23:11:47.002994720 +0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.9.2 from Makefile.am.
+# Makefile.in generated by automake 1.9.4 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
diff -Naur mpfr-2.1.0-p1/aclocal.m4 mpfr-2.1.0-p2/aclocal.m4
--- mpfr-2.1.0-p1/aclocal.m4	2004-11-03 15:25:55.000000000 +0000
+++ mpfr-2.1.0-p2/aclocal.m4	2005-01-23 23:11:29.176704728 +0000
@@ -1,4 +1,4 @@
-# generated automatically by aclocal 1.9.2 -*- Autoconf -*-
+# generated automatically by aclocal 1.9.4 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
 # Free Software Foundation, Inc.
@@ -40,7 +40,7 @@
 # Call AM_AUTOMAKE_VERSION so it can be traced.
 # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-	 [AM_AUTOMAKE_VERSION([1.9.2])])
+	 [AM_AUTOMAKE_VERSION([1.9.4])])
 
 # AM_AUX_DIR_EXPAND
 
diff -Naur mpfr-2.1.0-p1/configure mpfr-2.1.0-p2/configure
--- mpfr-2.1.0-p1/configure	2004-11-03 15:26:05.000000000 +0000
+++ mpfr-2.1.0-p2/configure	2005-01-23 23:11:50.900402224 +0000
@@ -6952,106 +6952,68 @@
   mv confdefs.tmp confdefs.h
 fi
 
-
-if ` test "$with_gmp_lib" `
-then
-  echo "$as_me:$LINENO: checking gmp library" >&5
-echo $ECHO_N "checking gmp library... $ECHO_C" >&6
-	if  test -r "$with_gmp_lib/libgmp.a"
-	then
-	  LIBS="$LIBS $with_gmp_lib/libgmp.a"
-	else
-	if  test -r "$with_gmp_lib/libgmp.so"
-	then
-	  LIBS="$LIBS $with_gmp_lib/libgmp.so"
-	else
-	if  test -r "$with_gmp_lib/libgmp.lib"
-	then
-	  LIBS="$LIBS $with_gmp_lib/libgmp.lib"
-	else
-	   { { echo "$as_me:$LINENO: error: $with_gmp_lib/libgmp.a/so/lib not found" >&5
-echo "$as_me: error: $with_gmp_lib/libgmp.a/so/lib not found" >&2;}
-   { (exit 1); exit 1; }; }
-	fi
-	fi
-	fi
-  echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6
+echo "$as_me:$LINENO: checking for GMP library" >&5
+echo $ECHO_N "checking for GMP library... $ECHO_C" >&6
+if test -r "$with_gmp_lib/libgmp.a"; then
+  LIBS="$with_gmp_lib/libgmp.a $LIBS"
+elif test -r "$with_gmp_lib/libgmp.so"; then
+  LIBS="$with_gmp_lib/libgmp.so $LIBS"
+elif test -r "$with_gmp_lib/libgmp.lib"; then
+  LIBS="$with_gmp_lib/libgmp.lib $LIBS"
 else
+  if test -d "$with_gmp_lib"; then
+    LDFLAGS="-L$with_gmp_lib $LDFLAGS"
+  fi
+  LIBS="-lgmp $LIBS"
+fi
+if test "$cross_compiling" = yes; then
+
+    echo "$as_me:$LINENO: result: can't test" >&5
+echo "${ECHO_T}can't test" >&6
 
-echo "$as_me:$LINENO: checking for main in -lgmp" >&5
-echo $ECHO_N "checking for main in -lgmp... $ECHO_C" >&6
-if test "${ac_cv_lib_gmp_main+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lgmp  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
+  cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
+#include "gmp.h"
+int main() { return !gmp_version; }
 
-int
-main ()
-{
-main ();
-  ;
-  return 0;
-}
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
+rm -f conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
+  (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_gmp_main=yes
+
+    echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
 else
-  echo "$as_me: failed program was:" >&5
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_gmp_main=no
-fi
-rm -f conftest.err conftest.$ac_objext \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_gmp_main" >&5
-echo "${ECHO_T}$ac_cv_lib_gmp_main" >&6
-if test $ac_cv_lib_gmp_main = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBGMP 1
-_ACEOF
-
-  LIBS="-lgmp $LIBS"
+( exit $ac_status )
 
-else
-  { { echo "$as_me:$LINENO: error: gmp not found" >&5
-echo "$as_me: error: gmp not found" >&2;}
+    echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+    { { echo "$as_me:$LINENO: error: libgmp not found" >&5
+echo "$as_me: error: libgmp not found" >&2;}
    { (exit 1); exit 1; }; }
-fi
 
 fi
-
-
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
 
 echo "$as_me:$LINENO: checking if gmp.h version and libgmp version are the same" >&5
 echo $ECHO_N "checking if gmp.h version and libgmp version are the same... $ECHO_C" >&6
diff -Naur mpfr-2.1.0-p1/configure.in mpfr-2.1.0-p2/configure.in
--- mpfr-2.1.0-p1/configure.in	2004-11-03 15:08:49.000000000 +0000
+++ mpfr-2.1.0-p2/configure.in	2005-01-23 23:10:16.115811672 +0000
@@ -155,7 +155,32 @@
   mv confdefs.tmp confdefs.h
 fi
 
-AC_MY_LIBS($with_gmp_lib, gmp)
+dnl AC_CHECK_LIB doesn't do what we want
+AC_MSG_CHECKING(for GMP library)
+if test -r "$with_gmp_lib/libgmp.a"; then
+  LIBS="$with_gmp_lib/libgmp.a $LIBS"
+elif test -r "$with_gmp_lib/libgmp.so"; then
+  LIBS="$with_gmp_lib/libgmp.so $LIBS"
+elif test -r "$with_gmp_lib/libgmp.lib"; then
+  LIBS="$with_gmp_lib/libgmp.lib $LIBS"
+else
+  if test -d "$with_gmp_lib"; then
+    LDFLAGS="-L$with_gmp_lib $LDFLAGS"
+  fi  
+  LIBS="-lgmp $LIBS"
+fi
+dnl FIXME: If AC_RUN_IFELSE failed try with AC_LINK_IFELSE?
+AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include "gmp.h"
+int main() { return !gmp_version; }
+  ]])], [
+    AC_MSG_RESULT(yes)
+  ], [
+    AC_MSG_RESULT(no)
+    AC_MSG_ERROR(libgmp not found)
+  ], [
+    AC_MSG_RESULT([can't test])
+  ])
 
 dnl Check for corresponding 'gmp.h' and libgmp.a
 AC_MSG_CHECKING(if gmp.h version and libgmp version are the same)
@@ -168,13 +193,13 @@
   char buffer[100];
   if (__GNU_MP_VERSION_PATCHLEVEL != 0)
     sprintf (buffer, "%d.%d.%d", __GNU_MP_VERSION, __GNU_MP_VERSION_MINOR,
-	    __GNU_MP_VERSION_PATCHLEVEL); 
+	    __GNU_MP_VERSION_PATCHLEVEL);
   else
     sprintf (buffer, "%d.%d", __GNU_MP_VERSION, __GNU_MP_VERSION_MINOR);
   printf ("(%s/%s) ", buffer, gmp_version);
   return (strcmp (buffer, gmp_version) != 0) ? 1 : 0;
 }
-], AC_MSG_RESULT(yes), 
+], AC_MSG_RESULT(yes),
    [AC_MSG_RESULT(no)
     AC_MSG_ERROR(['gmp.h' and 'libgmp' have different versions, or (on some platforms) libgmp couldn't be found! You have to properly reinstall GMP.])],
     AC_MSG_RESULT([can't test])
diff -Naur mpfr-2.1.0-p1/tests/Makefile.in mpfr-2.1.0-p2/tests/Makefile.in
--- mpfr-2.1.0-p1/tests/Makefile.in	2004-11-03 15:26:13.000000000 +0000
+++ mpfr-2.1.0-p2/tests/Makefile.in	2005-01-23 23:11:45.314251448 +0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.9.2 from Makefile.am.
+# Makefile.in generated by automake 1.9.4 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
diff -Naur mpfr-2.1.0-p2/get_str.c mpfr-2.1.0-p3/get_str.c
--- mpfr-2.1.0-p2/get_str.c	2004-09-30 16:11:13.000000000 +0000
+++ mpfr-2.1.0-p3/get_str.c	2005-01-23 23:16:07.255430336 +0000
@@ -376,14 +376,22 @@
 static mp_exp_t
 mpfr_get_str_compute_g (int beta, mp_exp_t e)
 {
-  double g0, g1;
+  double g0, g1, de;
   mp_exp_t g;
 
-  g0 = (double) e * log_b2[beta - 2];
-  g1 = (double) e * log_b2_low[beta - 2];
+  de = (double) e;
+  g0 = de * log_b2[beta - 2];
+  g1 = de * log_b2_low[beta - 2];
+  if (de > 9007199254740992.0 || de < -9007199254740992.0)
+    /* can happen on 64-bit machines */
+    {
+      mp_exp_t low_e = e - (mp_exp_t) de;
+      g1 += (double) low_e * log_b2[beta - 2];
+    }
   g = (mp_exp_t) mpfr_ceil_double (g0);
   g0 -= (double) g;
-  return g + (mp_exp_t) mpfr_ceil_double (g0 + g1);
+  g += (mp_exp_t) mpfr_ceil_double (g0 + g1);
+  return g;
 }
 
 /* prints the mantissa of x in the string s, and writes the corresponding
diff -Naur mpfr-2.1.0-p2/mpn_exp.c mpfr-2.1.0-p3/mpn_exp.c
--- mpfr-2.1.0-p2/mpn_exp.c	2004-09-28 09:26:34.000000000 +0000
+++ mpfr-2.1.0-p3/mpn_exp.c	2005-01-23 23:16:07.265428816 +0000
@@ -123,7 +123,7 @@
           (mpn_scan1 (c + 2 * n1, 0) < (n - 2 * n1) * BITS_PER_MP_LIMB))
         error = i;
 
-      if (e & (1 << i))
+      if (e & ((mp_exp_t) 1 << i))
         {
           /* multiply A by B */
           c[2 * n - 1] = mpn_mul_1 (c + n - 1, a, n, B);
diff -Naur mpfr-2.1.0-p3/mpfr-longlong.h mpfr-2.1.0-p4/mpfr-longlong.h
--- mpfr-2.1.0-p3/mpfr-longlong.h	2004-02-23 14:20:32.000000000 +0000
+++ mpfr-2.1.0-p4/mpfr-longlong.h	2005-01-23 23:17:05.706544416 +0000
@@ -1,7 +1,7 @@
 /* longlong.h -- definitions for mixed size 32/64 bit arithmetic.
 
-Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1999, 2000, 2001, 2002 Free
-Software Foundation, Inc.
+Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1999, 2000, 2001, 2002, 2003
+Free Software Foundation, Inc.
 
 This file is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
@@ -94,7 +94,25 @@
    and is lost.
 
    If any of these macros are left undefined for a particular CPU,
-   C macros are used.  */
+   C macros are used.
+
+
+   Notes:
+
+   For add_ssaaaa the two high and two low addends can both commute, but
+   unfortunately gcc only supports one "%" commutative in each asm block.
+   This has always been so but is only documented in recent versions
+   (eg. pre-release 3.3).  Having two or more "%"s can cause an internal
+   compiler error in certain rare circumstances.
+
+   Apparently it was only the last "%" that was ever actually respected, so
+   the code has been updated to leave just that.  Clearly there's a free
+   choice whether high or low should get it, if there's a reason to favour
+   one over the other.  Also obviously when the constraints on the two
+   operands are identical there's no benefit to the reloader in any "%" at
+   all.
+
+   */
 
 /* The CPUs come in alphabetical order below.
 
@@ -183,11 +201,14 @@
 #endif /* _CRAY */
 
 #if defined (__hppa) && W_TYPE_SIZE == 64
-#if defined (__GNUC__)
+/* These macros are for ABI=2.0w.  In ABI=2.0n they can't be used, since GCC
+   (3.2) puts longlong into two adjacent 32-bit registers.  Presumably this
+   is just a case of no direct support for 2.0n but treating it like 1.0. */
+#if defined (__GNUC__) && ! defined (_LONG_LONG_LIMB)
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("add %4,%5,%1\n\tadd,dc %2,%3,%0"				\
 	   : "=r" (sh), "=&r" (sl)					\
-	   : "%rM" (ah), "rM" (bh), "%rM" (al), "rM" (bl))
+	   : "rM" (ah), "rM" (bh), "%rM" (al), "rM" (bl))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("sub %4,%5,%1\n\tsub,db %2,%3,%0"				\
 	   : "=r" (sh), "=&r" (sl)					\
@@ -269,7 +290,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("add %1,%4,%5\n\taddc %0,%2,%3"				\
 	   : "=r" (sh), "=&r" (sl)					\
-	   : "%r" (ah), "rI" (bh), "%r" (al), "rI" (bl))
+	   : "r" (ah), "rI" (bh), "%r" (al), "rI" (bl))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("sub %1,%4,%5\n\tsubc %0,%2,%3"				\
 	   : "=r" (sh), "=&r" (sl)					\
@@ -300,7 +321,7 @@
   __asm__ ("add.f\t%1, %4, %5\n\tadc\t%0, %2, %3"			\
 	   : "=r" ((USItype) (sh)),					\
 	     "=&r" ((USItype) (sl))					\
-	   : "%r" ((USItype) (ah)),					\
+	   : "r"  ((USItype) (ah)),					\
 	     "rIJ" ((USItype) (bh)),					\
 	     "%r" ((USItype) (al)),					\
 	     "rIJ" ((USItype) (bl)))
@@ -318,7 +339,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("adds\t%1, %4, %5\n\tadc\t%0, %2, %3"			\
 	   : "=r" (sh), "=&r" (sl)					\
-	   : "%r" (ah), "rI" (bh), "%r" (al), "rI" (bl) __CLOBBER_CC)
+	   : "r" (ah), "rI" (bh), "%r" (al), "rI" (bl) __CLOBBER_CC)
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   do {									\
     if (__builtin_constant_p (al))					\
@@ -456,7 +477,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("add.w %5,%1\n\taddx %3,%0"					\
 	   : "=g" ((USItype)(sh)), "=&g" ((USItype)(sl))		\
-	   : "%0" ((USItype)(ah)), "g" ((USItype)(bh)),			\
+	   : "0"  ((USItype)(ah)), "g" ((USItype)(bh)),			\
 	     "%1" ((USItype)(al)), "g" ((USItype)(bl)))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("sub.w %5,%1\n\tsubx %3,%0"					\
@@ -480,7 +501,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("add %4,%5,%1\n\taddc %2,%3,%0"				\
 	   : "=r" (sh), "=&r" (sl)					\
-	   : "%rM" (ah), "rM" (bh), "%rM" (al), "rM" (bl))
+	   : "rM" (ah), "rM" (bh), "%rM" (al), "rM" (bl))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("sub %4,%5,%1\n\tsubb %2,%3,%0"				\
 	   : "=r" (sh), "=&r" (sl)					\
@@ -560,7 +581,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("addl %5,%1\n\tadcl %3,%0"					\
 	   : "=r" ((USItype)(sh)), "=&r" ((USItype)(sl))		\
-	   : "%0" ((USItype)(ah)), "g" ((USItype)(bh)),			\
+	   : "0"  ((USItype)(ah)), "g" ((USItype)(bh)),			\
 	     "%1" ((USItype)(al)), "g" ((USItype)(bl)))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("subl %5,%1\n\tsbbl %3,%0"					\
@@ -691,7 +712,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("addq %5,%1\n\tadcq %3,%0"					\
 	   : "=r" ((UDItype)(sh)), "=&r" ((UDItype)(sl))		\
-	   : "%0" ((UDItype)(ah)), "g" ((UDItype)(bh)),			\
+	   : "0"  ((UDItype)(ah)), "g" ((UDItype)(bh)),			\
 	     "%1" ((UDItype)(al)), "g" ((UDItype)(bl)))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("subq %5,%1\n\tsbbq %3,%0"					\
@@ -713,10 +734,12 @@
     __asm__ ("bsrq %1,%0" : "=r" (__cbtmp) : "rm" ((UDItype)(x)));	\
     (count) = __cbtmp ^ 63;						\
   } while (0)
+/* bsfq destination must be a 64-bit register, "%q0" forces this in case
+   count is only an int. */
 #define count_trailing_zeros(count, x)					\
   do {									\
     ASSERT ((x) != 0);							\
-    __asm__ ("bsfq %1,%0" : "=r" (count) : "rm" ((UDItype)(x)));	\
+    __asm__ ("bsfq %1,%q0" : "=r" (count) : "rm" ((UDItype)(x)));	\
   } while (0)
 #endif /* x86_64 */
 
@@ -730,7 +753,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("cmpo 1,0\;addc %5,%4,%1\;addc %3,%2,%0"			\
 	   : "=r" (sh), "=&r" (sl)					\
-	   : "%dI" (ah), "dI" (bh), "%dI" (al), "dI" (bl))
+	   : "dI" (ah), "dI" (bh), "%dI" (al), "dI" (bl))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("cmpo 0,0\;subc %5,%4,%1\;subc %3,%2,%0"			\
 	   : "=r" (sh), "=&r" (sl)					\
@@ -781,7 +804,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("add%.l %5,%1\n\taddx%.l %3,%0"				\
 	   : "=d" ((USItype)(sh)), "=&d" ((USItype)(sl))		\
-	   : "%0" ((USItype)(ah)), "d" ((USItype)(bh)),			\
+	   : "0"  ((USItype)(ah)), "d" ((USItype)(bh)),			\
 	     "%1" ((USItype)(al)), "g" ((USItype)(bl)))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("sub%.l %5,%1\n\tsubx%.l %3,%0"				\
@@ -840,12 +863,15 @@
 #define UMUL_TIME 100
 #define UDIV_TIME 400
 #endif /* not mc68020 */
-/* The '020, '030, '040 and '060 have bitfield insns.  */
-#if defined (__mc68020__) || defined (mc68020) \
+/* The '020, '030, '040 and '060 have bitfield insns.
+   GCC 3.4 defines __mc68020__ when in CPU32 mode, check for __mcpu32__ to
+   exclude bfffo on that chip (bitfield insns not available).  */
+#if (defined (__mc68020__) || defined (mc68020)    \
      || defined (__mc68030__) || defined (mc68030) \
      || defined (__mc68040__) || defined (mc68040) \
      || defined (__mc68060__) || defined (mc68060) \
-     || defined (__NeXT__)
+     || defined (__NeXT__))                        \
+  && ! defined (__mcpu32__)
 #define count_leading_zeros(count, x) \
   __asm__ ("bfffo %1{%b2:%b2},%0"					\
 	   : "=d" ((USItype) (count))					\
@@ -858,7 +884,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("addu.co %1,%r4,%r5\n\taddu.ci %0,%r2,%r3"			\
 	   : "=r" (sh), "=&r" (sl)					\
-	   : "%rJ" (ah), "rJ" (bh), "%rJ" (al), "rJ" (bl))
+	   : "rJ" (ah), "rJ" (bh), "%rJ" (al), "rJ" (bl))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("subu.co %1,%r4,%r5\n\tsubu.ci %0,%r2,%r3"			\
 	   : "=r" (sh), "=&r" (sl)					\
@@ -955,15 +981,15 @@
 #endif /* __ns32000__ */
 
 /* FIXME: We should test _IBMR2 here when we add assembly support for the
-   system vendor compilers.
-   FIXME: What's needed for gcc PowerPC VxWorks?  __vxworks__ is not good
-   enough, since that hits ARM and m68k too.  */
+   system vendor compilers. */
 #if (defined (_ARCH_PPC)	/* AIX */				\
      || defined (_ARCH_PWR)	/* AIX */				\
      || defined (__powerpc__)	/* gcc */				\
      || defined (__POWERPC__)	/* BEOS */				\
      || defined (__ppc__)	/* Darwin */				\
-     || defined (PPC)		/* GNU/Linux, SysV */			\
+     || (defined (PPC) && ! defined (CPU_FAMILY)) /* gcc 2.7.x GNU&SysV */    \
+     || (defined (PPC) && defined (CPU_FAMILY)    /* VxWorks */               \
+         && CPU_FAMILY == PPC)                                                \
      ) && W_TYPE_SIZE == 32
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   do {									\
@@ -976,7 +1002,7 @@
     else								\
       __asm__ ("{a%I5|add%I5c} %1,%4,%5\n\t{ae|adde} %0,%2,%3"		\
 	     : "=r" (sh), "=&r" (sl)					\
-	     : "%r" (ah), "r" (bh), "%r" (al), "rI" (bl));		\
+	     : "r" (ah), "r" (bh), "%r" (al), "rI" (bl));		\
   } while (0)
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   do {									\
@@ -1001,7 +1027,10 @@
   __asm__ ("{cntlz|cntlzw} %0,%1" : "=r" (count) : "r" (x))
 #define COUNT_LEADING_ZEROS_0 32
 #if defined (_ARCH_PPC) || defined (__powerpc__) || defined (__POWERPC__) \
-  || defined (__ppc__) || defined (PPC) || defined (__vxworks__)
+  || defined (__ppc__)                                                    \
+  || (defined (PPC) && ! defined (CPU_FAMILY)) /* gcc 2.7.x GNU&SysV */       \
+  || (defined (PPC) && defined (CPU_FAMILY)    /* VxWorks */                  \
+         && CPU_FAMILY == PPC)
 #define umul_ppmm(ph, pl, m0, m1) \
   do {									\
     USItype __m0 = (m0), __m1 = (m1);					\
@@ -1042,7 +1071,7 @@
     else								\
       __asm__ ("{a%I5|add%I5c} %1,%4,%5\n\t{ae|adde} %0,%2,%3"		\
 	     : "=r" (sh), "=&r" (sl)					\
-	     : "%r" (ah), "r" (bh), "%r" (al), "rI" (bl));		\
+	     : "r" (ah), "r" (bh), "%r" (al), "rI" (bl));		\
   } while (0)
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   do {									\
@@ -1087,7 +1116,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("addw %5,%1\n\taddwc %3,%0"					\
 	   : "=r" ((USItype)(sh)), "=&r" ((USItype)(sl))		\
-	   : "%0" ((USItype)(ah)), "g" ((USItype)(bh)),			\
+	   : "0"  ((USItype)(ah)), "g" ((USItype)(bh)),			\
 	     "%1" ((USItype)(al)), "g" ((USItype)(bl)))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("subw %5,%1\n\tsubwb %3,%0"					\
@@ -1109,7 +1138,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("a %1,%5\n\tae %0,%3"					\
 	   : "=r" ((USItype)(sh)), "=&r" ((USItype)(sl))		\
-	   : "%0" ((USItype)(ah)), "r" ((USItype)(bh)),			\
+	   : "0"  ((USItype)(ah)), "r" ((USItype)(bh)),			\
 	     "%1" ((USItype)(al)), "r" ((USItype)(bl)))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("s %1,%5\n\tse %0,%3"					\
@@ -1168,7 +1197,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("addcc %r4,%5,%1\n\taddx %r2,%3,%0"				\
 	   : "=r" (sh), "=&r" (sl)					\
-	   : "%rJ" (ah), "rI" (bh),"%rJ" (al), "rI" (bl)		\
+	   : "rJ" (ah), "rI" (bh),"%rJ" (al), "rI" (bl)			\
 	   __CLOBBER_CC)
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("subcc %r4,%5,%1\n\tsubx %r2,%3,%0"				\
@@ -1353,7 +1382,7 @@
       "	addccc	%r6,%7,%%g0\n"						\
       "	addc	%r2,%3,%0"						\
 	  : "=r" (sh), "=&r" (sl)					\
-	  : "%rJ" (ah), "rI" (bh), "%rJ" (al), "rI" (bl),		\
+	  : "rJ" (ah), "rI" (bh), "%rJ" (al), "rI" (bl),		\
 	    "%rJ" ((al) >> 32), "rI" ((bl) >> 32)			\
 	   __CLOBBER_CC)
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
@@ -1371,7 +1400,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("addl2 %5,%1\n\tadwc %3,%0"					\
 	   : "=g" ((USItype)(sh)), "=&g" ((USItype)(sl))		\
-	   : "%0" ((USItype)(ah)), "g" ((USItype)(bh)),			\
+	   : "0"  ((USItype)(ah)), "g" ((USItype)(bh)),			\
 	     "%1" ((USItype)(al)), "g" ((USItype)(bl)))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("subl2 %5,%1\n\tsbwc %3,%0"					\
@@ -1413,7 +1442,7 @@
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   __asm__ ("add	%H1,%H5\n\tadc	%H0,%H3"				\
 	   : "=r" ((unsigned int)(sh)), "=&r" ((unsigned int)(sl))	\
-	   : "%0" ((unsigned int)(ah)), "r" ((unsigned int)(bh)),	\
+	   : "0"  ((unsigned int)(ah)), "r" ((unsigned int)(bh)),	\
 	     "%1" ((unsigned int)(al)), "rQR" ((unsigned int)(bl)))
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("sub	%H1,%H5\n\tsbc	%H0,%H3"				\
diff -Naur mpfr-2.1.0-p4/mpfr.h mpfr-2.1.0-p5/mpfr.h
--- mpfr-2.1.0-p4/mpfr.h	2004-10-22 13:16:25.000000000 +0000
+++ mpfr-2.1.0-p5/mpfr.h	2005-01-23 23:17:50.566724632 +0000
@@ -435,7 +435,7 @@
 
 int mpfr_fma _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr,
                            mpfr_rnd_t));
-int mpfr_sum _MPFR_PROTO ((mpfr_ptr, mpfr_ptr __gmp_const tab[], unsigned long,
+int mpfr_sum _MPFR_PROTO ((mpfr_ptr, mpfr_ptr __gmp_const [], unsigned long,
 			   mpfr_rnd_t));
 
 void mpfr_init_cache _MPFR_PROTO ((mpfr_cache_t,int(*)(mpfr_ptr,mpfr_rnd_t)));
diff -Naur mpfr-2.1.0-p5/sub1.c mpfr-2.1.0-p6/sub1.c
--- mpfr-2.1.0-p5/sub1.c	2004-03-26 13:27:16.000000000 +0000
+++ mpfr-2.1.0-p6/sub1.c	2005-01-23 23:18:41.392997864 +0000
@@ -1,6 +1,6 @@
 /* mpfr_sub1 -- internal function to perform a "real" subtraction
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 Contributed by the Spaces project, INRIA Lorraine.
 
 This file is part of the MPFR Library.
@@ -20,7 +20,6 @@
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
 MA 02111-1307, USA. */
 
-
 #include "mpfr-impl.h"
 
 /* compute sign(b) * (|b| - |c|), with |b| > |c|, diff_exp = EXP(b) - EXP(c)
@@ -81,6 +80,60 @@
   else
     MPFR_SET_SAME_SIGN(a,b);
 
+  /* Check if c is too small.
+     A more precise test is to replace 2 by   
+      (rnd == GMP_RNDN) + mpfr_power2_raw (b) 
+      but it is more expensive and not very usefull */
+  if (MPFR_UNLIKELY (MPFR_GET_EXP (c) <= MPFR_GET_EXP (b) 
+		     - (mp_exp_t) MAX (MPFR_PREC (a), MPFR_PREC (b)) - 2))
+    {
+      /* Remember, we can't have an exact result! */
+      /*   A.AAAAAAAAAAAAAAAAA
+	 = B.BBBBBBBBBBBBBBB
+	  -                     C.CCCCCCCCCCCCC */
+      /* A = S*ABS(B) +/- ulp(a) */
+      inexact = mpfr_set4 (a, b, rnd_mode, MPFR_SIGN (a)); 
+      if (inexact == 0)
+	{
+	  /* a = b (Exact)
+	     But we know it isn't (Since we have to remove `c')
+	     So if we round to Zero, we have to remove one ulp.
+	     Otherwise the result is correctly rounded. */
+	  if (MPFR_IS_LIKE_RNDZ (rnd_mode, MPFR_IS_NEG (a))) {
+	    mpfr_nexttoward (a, c);
+	    return -MPFR_INT_SIGN (a);
+	  }
+	  return MPFR_INT_SIGN (a);
+	}
+      else
+	{
+	  /*   A.AAAAAAAAAAAAAA
+             = B.BBBBBBBBBBBBBBB
+  	      -                   C.CCCCCCCCCCCCC */
+	  /* It isn't exact so Prec(b) > Prec(a) and the last
+	     Prec(b)-Prec(a) bits of `b' are not zeros.
+	     Which means that removing c from b can't generate a carry
+	     execpt in case of even rounding.
+	     In all other case the result and the inexact flag should be
+	     correct (We can't have an exact result).
+	     In case of EVEN rounding:
+	       1.BBBBBBBBBBBBBx10
+	     -                     1.CCCCCCCCCCCC 
+	     = 1.BBBBBBBBBBBBBx01  Rounded to Prec(b)
+	     = 1.BBBBBBBBBBBBBx    Nearest / Rounded to Prec(a)
+	     Set gives:
+	       1.BBBBBBBBBBBBB0   if inexact == EVEN_INEX  (x == 0)
+  	       1.BBBBBBBBBBBBB1+1 if inexact == -EVEN_INEX (x == 1) 
+	     which means we get a wrong rounded result if x==1, 
+	     i.e. inexact= MPFR_EVEN_INEX */
+	  if (MPFR_UNLIKELY (inexact == MPFR_EVEN_INEX*MPFR_INT_SIGN (a))) {
+	    mpfr_nexttoward (a, c);
+	    inexact = -MPFR_INT_SIGN (a);
+	  }
+	  return inexact;
+	}
+    }
+
   diff_exp = (mp_exp_unsigned_t) MPFR_GET_EXP (b) - MPFR_GET_EXP (c);
 
   /* reserve a space to store b aligned with the result, i.e. shifted by
@@ -136,19 +189,20 @@
     }
 
 #ifdef DEBUG
-  printf("shift_b=%u shift_c=%u\n", shift_b, shift_c);
+  printf("shift_b=%u shift_c=%u diffexp=%lu\n", shift_b, shift_c, diff_exp);
 #endif
 
   MPFR_ASSERTD (ap != cp);
   MPFR_ASSERTD (bp != cp);
 
   /* here we have shift_c = (diff_exp - cancel) % BITS_PER_MP_LIMB,
+        0 <= shift_c < BITS_PER_MP_LIMB
      thus we want cancel2 = ceil((cancel - diff_exp) / BITS_PER_MP_LIMB) */
 
   cancel2 = (long int) (cancel - (diff_exp - shift_c)) / BITS_PER_MP_LIMB;
   /* the high cancel2 limbs from b should not be taken into account */
 #ifdef DEBUG
-  printf("cancel=%u cancel1=%u cancel2=%d\n", cancel, cancel1, cancel2);
+  printf("cancel=%lu cancel1=%lu cancel2=%ld\n", cancel, cancel1, cancel2);
 #endif
 
   /*               ap[an-1]        ap[0]
@@ -276,6 +330,7 @@
   bn -= an + cancel1;
   cn0 = cn;
   cn -= (long int) an + cancel2;
+
 #ifdef DEBUG
   printf("last %d bits from a are %lu, bn=%ld, cn=%ld\n", sh, carry, bn, cn);
 #endif
diff -Naur mpfr-2.1.0-p6/sum.c mpfr-2.1.0-p7/sum.c
--- mpfr-2.1.0-p6/sum.c	2004-02-24 13:23:35.000000000 +0000
+++ mpfr-2.1.0-p7/sum.c	2005-01-23 23:19:18.010431168 +0000
@@ -1,6 +1,6 @@
 /* Sum -- efficiently sum a list of floating-point numbers
 
-Copyright 2004 Free Software Foundation, Inc.
+Copyright 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -169,17 +169,18 @@
 {
   unsigned long i;
   mpfr_t sum;
-  int error_trap = 0;
+  int error_trap;
+
+  if (MPFR_UNLIKELY (n == 1))
+    return mpfr_set (ret, tab[0], GMP_RNDN);
 
   mpfr_init2 (sum, F);
-  mpfr_set (sum, tab[0], GMP_RNDN);
 
+  error_trap = mpfr_set (sum, tab[0], GMP_RNDN);
   for (i = 1; i < n - 1; i++)
-    {
-      error_trap |= mpfr_add (sum, sum, tab[i], GMP_RNDN);
-    }
-
+    error_trap |= mpfr_add (sum, sum, tab[i], GMP_RNDN);
   error_trap |= mpfr_add (ret, sum, tab[n - 1], GMP_RNDN);
+
   mpfr_clear (sum);
   return error_trap;
 }
@@ -201,6 +202,11 @@
   TMP_DECL(marker);
     
   TMP_MARK(marker);
+  if (MPFR_UNLIKELY (n == 0)) {
+    MPFR_SET_ZERO (ret);
+    MPFR_SET_POS (ret);
+    return 0;
+  }
 
   perm = (mpfr_srcptr *) TMP_ALLOC(n * sizeof(mpfr_srcptr)); 
 
diff -Naur mpfr-2.1.0-p7/tests/tests.c mpfr-2.1.0-p8/tests/tests.c
--- mpfr-2.1.0-p7/tests/tests.c	2004-10-27 13:16:13.000000000 +0000
+++ mpfr-2.1.0-p8/tests/tests.c	2005-01-23 23:20:08.857701208 +0000
@@ -39,6 +39,10 @@
 #  include <time.h>
 #endif
 
+#if HAVE_SYS_FPU_H
+# include <sys/fpu.h>
+#endif
+
 #include "mpfr-test.h"
 
 static void tests_rand_start (void);
diff -Naur mpfr-2.1.0-p7/tests/trint.c mpfr-2.1.0-p8/tests/trint.c
--- mpfr-2.1.0-p7/tests/trint.c	2004-10-27 13:16:14.000000000 +0000
+++ mpfr-2.1.0-p8/tests/trint.c	2005-01-23 23:20:08.867699688 +0000
@@ -25,6 +25,10 @@
 
 #include "mpfr-test.h"
 
+#if __MPFR_STDC (199901L)
+# include <math.h>
+#endif
+
 static void
 special (void)
 {
diff -Naur mpfr-2.1.0-p8/strtofr.c mpfr-2.1.0-p9/strtofr.c
--- mpfr-2.1.0-p8/strtofr.c	2004-10-22 13:16:26.000000000 +0000
+++ mpfr-2.1.0-p9/strtofr.c	2005-01-23 23:20:41.640717432 +0000
@@ -409,7 +409,7 @@
   size_t pstr_size;
   mp_size_t ysize, real_ysize;
   int res, err;
-  TMP_DECL (maker);
+  TMP_DECL (marker);
 
   /* determine the minimal precision for the computation */
   prec = MPFR_PREC (x) + MPFR_INT_CEIL_LOG2 (MPFR_PREC (x));
@@ -671,7 +671,7 @@
   res = mpfr_set_overflow (x, rnd, (pstr->negative) ? -1 : 1);
 
  end:
-  TMP_FREE (maker);
+  TMP_FREE (marker);
   return res;
 }
 
diff -Naur mpfr-2.1.0-p8/sum.c mpfr-2.1.0-p9/sum.c
--- mpfr-2.1.0-p8/sum.c	2005-01-23 23:19:18.010431000 +0000
+++ mpfr-2.1.0-p9/sum.c	2005-01-23 23:20:41.651715760 +0000
@@ -67,7 +67,7 @@
         perm[target_rank] = tab[i];
     }
     
-    TMP_FREE(account);
+    TMP_FREE(marker);
 }
 
 /* Performs a heap sort of the entries */
diff -Naur mpfr-2.1.0-p9/tests/tabs.c mpfr-2.1.0-p10/tests/tabs.c
--- mpfr-2.1.0-p9/tests/tabs.c	2004-02-23 16:47:46.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tabs.c	2005-01-27 17:07:15.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_abs.
 
-Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -30,7 +30,7 @@
 {
   mp_prec_t p, q;
   mpfr_t x, y, absx;
-  mp_rnd_t rnd;
+  int rnd;
   int inexact, cmp;
 
   mpfr_init (x);
@@ -54,7 +54,7 @@
           mpfr_set_prec (y, q);
           for (rnd = 0; rnd < GMP_RND_MAX; rnd++)
             {
-              inexact = mpfr_abs (y, x, rnd);
+              inexact = mpfr_abs (y, x, (mp_rnd_t) rnd);
               cmp = mpfr_cmp (y, absx);
               if (((inexact == 0) && (cmp != 0)) ||
                   ((inexact > 0) && (cmp <= 0)) ||
@@ -138,7 +138,7 @@
       mpfr_random(x);
       MPFR_SET_SIGN(x, sign);
       rnd = RND_RAND();
-      mpfr_abs(y, x, rnd);
+      mpfr_abs(y, x, (mp_rnd_t) rnd);
       MPFR_SET_POS(x);
       if (mpfr_cmp(x,y))
         {
diff -Naur mpfr-2.1.0-p9/tests/tacos.c mpfr-2.1.0-p10/tests/tacos.c
--- mpfr-2.1.0-p9/tests/tacos.c	2004-10-27 13:16:12.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tacos.c	2005-01-27 17:07:33.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_acos.
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 Contributed by Mathieu Dutour.
 
 This file is part of the MPFR Library.
@@ -98,7 +98,7 @@
 main (void)
 {
   mpfr_t x, y;
-  mp_rnd_t r;
+  int r;
 
   tests_start_mpfr ();
 
@@ -145,13 +145,13 @@
   for (r = 0; r < GMP_RND_MAX; r++)
     {
       mpfr_set_ui (x, 0, GMP_RNDN); /* exact */
-      mpfr_acos (y, x, r);
-      mpfr_const_pi (x, r);
+      mpfr_acos (y, x, (mp_rnd_t) r);
+      mpfr_const_pi (x, (mp_rnd_t) r);
       mpfr_div_2exp (x, x, 1, GMP_RNDN); /* exact */
       if (mpfr_cmp (x, y))
         {
           printf ("Error: acos(0) != Pi/2 for rnd=%s\n",
-                  mpfr_print_rnd_mode (r));
+                  mpfr_print_rnd_mode ((mp_rnd_t) r));
           exit (1);
         }
     }
@@ -160,12 +160,12 @@
   for (r = 0; r < GMP_RND_MAX; r++)
     {
       mpfr_set_si (x, -1, GMP_RNDN); /* exact */
-      mpfr_acos (y, x, r);
-      mpfr_const_pi (x, r);
+      mpfr_acos (y, x, (mp_rnd_t) r);
+      mpfr_const_pi (x, (mp_rnd_t) r);
       if (mpfr_cmp (x, y))
         {
           printf ("Error: acos(1) != Pi for rnd=%s\n",
-                  mpfr_print_rnd_mode (r));
+                  mpfr_print_rnd_mode ((mp_rnd_t) r));
           exit (1);
         }
     }
diff -Naur mpfr-2.1.0-p9/tests/tadd.c mpfr-2.1.0-p10/tests/tadd.c
--- mpfr-2.1.0-p9/tests/tadd.c	2004-02-26 09:56:02.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tadd.c	2005-01-27 17:08:39.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_add and mpfr_sub.
 
-Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -509,7 +509,7 @@
 		 abs(EXP(x)-EXP(u)) + max(prec(x), prec(u)) + 1 */
 	      pz = pz + MAX(MPFR_PREC(x), MPFR_PREC(u)) + 1;
 	      mpfr_set_prec (z, pz);
-	      rnd = RND_RAND();
+	      rnd = (mp_rnd_t) RND_RAND();
 	      if (test_add (z, x, u, rnd))
 		{
 		  printf ("z <- x + u should be exact\n");
@@ -519,7 +519,7 @@
 		  exit (1);
 		}
 		{
-                  rnd = RND_RAND();
+                  rnd = (mp_rnd_t) RND_RAND();
 		  inexact = test_add (y, x, u, rnd);
 		  cmp = mpfr_cmp (y, z);
 		  if (((inexact == 0) && (cmp != 0)) ||
@@ -614,7 +614,7 @@
 {
   mpfr_t a, b, c;
   mp_prec_t prec_a;
-  mp_rnd_t r;
+  int r;
 
   mpfr_init2 (a, 256);
   mpfr_init2 (b, 256);
@@ -629,7 +629,7 @@
       {
         mpfr_set_prec (a, prec_a);
         mpfr_clear_overflow ();
-        test_add (a, b, c, r);
+        test_add (a, b, c, (mp_rnd_t) r);
         if (!mpfr_overflow_p ())
           {
             printf ("No overflow in check_overflow\n");
@@ -695,7 +695,7 @@
       mpfr_add (c, c, one, GMP_RNDN);
       diff = (randlimb () % (2*m)) - m;
       mpfr_mul_2si (c, c, diff, GMP_RNDN);
-      rnd_mode = RND_RAND ();
+      rnd_mode = (mp_rnd_t) RND_RAND ();
       inex_a = test_add (a, b, c, rnd_mode);
       mpfr_init2 (s, MPFR_PREC_MIN + 2*m);
       inex_s = mpfr_add (s, b, c, GMP_RNDN); /* exact */
@@ -740,15 +740,15 @@
     0, 1, 2, 3, 4, 29, 30, 31, 32, 33, 34, 35, 61, 62, 63, 64, 65, 66, 67
   };
   mpfr_t a, b, c;
-  int ia, ib, ic;
+  unsigned int ia, ib, ic;
 
   mpfr_init2 (c, MPFR_PREC_MIN);
 
-  for (ia = 0; ia < numberof(prec_a); ia++)
+  for (ia = 0; ia < numberof (prec_a); ia++)
     for (ib = 0; ib < numberof(supp_b); ib++)
       {
         mp_prec_t prec_b;
-        mp_rnd_t rnd_mode;
+        int rnd_mode;
 
         prec_b = prec_a[ia] + supp_b[ib];
 
@@ -767,23 +767,23 @@
 
               mpfr_set_ui (c, 1, GMP_RNDN);
               mpfr_div_ui (c, c, prec_a[ia] + supp_b[ic], GMP_RNDN);
-              inex_a = test_add (a, b, c, rnd_mode);
+              inex_a = test_add (a, b, c, (mp_rnd_t) rnd_mode);
               mpfr_init2 (s, 256);
               inex_s = mpfr_add (s, b, c, GMP_RNDN); /* exact */
               if (inex_s)
                 {
                   printf ("check_1minuseps: result should have been exact "
-                          "(ia = %d, ib = %d, ic = %d)\n", ia, ib, ic);
+                          "(ia = %u, ib = %u, ic = %u)\n", ia, ib, ic);
                   exit (1);
                 }
-              inex_s = mpfr_prec_round (s, prec_a[ia], rnd_mode);
+              inex_s = mpfr_prec_round (s, prec_a[ia], (mp_rnd_t) rnd_mode);
               if ((inex_a < 0 && inex_s >= 0) ||
                   (inex_a == 0 && inex_s != 0) ||
                   (inex_a > 0 && inex_s <= 0) ||
                   !mpfr_equal_p (a, s))
                 {
                   printf ("check_1minuseps: results are different.\n");
-                  printf ("ia = %d, ib = %d, ic = %d\n", ia, ib, ic);
+                  printf ("ia = %u, ib = %u, ic = %u\n", ia, ib, ic);
                   exit (1);
                 }
               mpfr_clear (s);
diff -Naur mpfr-2.1.0-p9/tests/tadd1sp.c mpfr-2.1.0-p10/tests/tadd1sp.c
--- mpfr-2.1.0-p9/tests/tadd1sp.c	2004-10-27 13:16:12.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tadd1sp.c	2005-01-27 17:10:11.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_add1sp.
 
-Copyright 2004 Free Software Foundation.
+Copyright 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -67,7 +67,7 @@
 #define STD_ERROR \
   {\
     printf("ERROR: for %s and p=%lu and i=%d:\nB=",\
-           mpfr_print_rnd_mode(r), p, i);\
+           mpfr_print_rnd_mode ((mp_rnd_t) r), p, i);\
     mpfr_print_binary(b);\
     printf("\nC="); mpfr_print_binary(c);\
     printf("\nadd1  : "); mpfr_print_binary(a1);\
@@ -79,7 +79,7 @@
 #define STD_ERROR2 \
   {\
     printf("ERROR: Wrong inexact flag for %s and p=%lu and i=%d:\nB=",\
-           mpfr_print_rnd_mode(r), p, i);\
+           mpfr_print_rnd_mode ((mp_rnd_t) r), p, i);\
     mpfr_print_binary(b);\
     printf("\nC="); mpfr_print_binary(c);\
     printf("\nA="); mpfr_print_binary(a1);\
@@ -99,7 +99,7 @@
 void check_random(mp_prec_t p)
 {
   mpfr_t a1,b,c,a2;
-  mp_rnd_t r;
+  int r;
   int i, inexact1, inexact2;
 
   mpfr_inits2(p, a1,b,c,a2, NULL);
@@ -115,8 +115,8 @@
           if (MPFR_IS_PURE_FP(b) && MPFR_IS_PURE_FP(c))
             for (r = 0 ; r < GMP_RND_MAX ; r++)
               {
-                inexact1 = mpfr_add1(a1, b, c, r);
-                inexact2 = mpfr_add1sp(a2, b, c, r);
+                inexact1 = mpfr_add1(a1, b, c, (mp_rnd_t) r);
+                inexact2 = mpfr_add1sp(a2, b, c, (mp_rnd_t) r);
                 if (mpfr_cmp(a1, a2))
                   STD_ERROR;
                 if (inexact1 != inexact2)
@@ -131,7 +131,7 @@
 void check_special(void)
 {
   mpfr_t a1,a2,b,c;
-  mp_rnd_t r;
+  int r;
   mpfr_prec_t p;
   int i = -1, inexact1, inexact2;
 
@@ -142,16 +142,16 @@
       SET_PREC(53);
       mpfr_set_str1 (b, "1@100");
       mpfr_set_str1 (c, "1@1");
-      inexact1 = mpfr_add1(a1, b, c, r);
-      inexact2 = mpfr_add1sp(a2, b, c, r);
+      inexact1 = mpfr_add1(a1, b, c, (mp_rnd_t) r);
+      inexact2 = mpfr_add1sp(a2, b, c, (mp_rnd_t) r);
       if (mpfr_cmp(a1, a2))
         STD_ERROR;
       if (inexact1 != inexact2)
         STD_ERROR2;
       mpfr_set_str_binary (b, "1E53");
       mpfr_set_str_binary (c, "1E0");
-      inexact1 = mpfr_add1(a1, b, c, r);
-      inexact2 = mpfr_add1sp(a2, b, c, r);
+      inexact1 = mpfr_add1(a1, b, c, (mp_rnd_t) r);
+      inexact2 = mpfr_add1sp(a2, b, c, (mp_rnd_t) r);
       if (mpfr_cmp(a1, a2))
         STD_ERROR;
       if (inexact1 != inexact2)
diff -Naur mpfr-2.1.0-p9/tests/tadd_ui.c mpfr-2.1.0-p10/tests/tadd_ui.c
--- mpfr-2.1.0-p9/tests/tadd_ui.c	2004-01-28 14:22:04.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tadd_ui.c	2005-01-27 17:11:06.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_add_ui
 
-Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -27,7 +27,7 @@
 
 /* checks that x+y gives the right results with 53 bits of precision */
 static void
-check3 (const char *xs, unsigned long y, unsigned int rnd_mode, const char *zs)
+check3 (const char *xs, unsigned long y, mp_rnd_t rnd_mode, const char *zs)
 {
   mpfr_t xx, zz;
 
diff -Naur mpfr-2.1.0-p9/tests/tasin.c mpfr-2.1.0-p10/tests/tasin.c
--- mpfr-2.1.0-p9/tests/tasin.c	2004-10-27 13:16:12.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tasin.c	2005-01-27 17:11:29.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_asin.
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 Original version by Mathieu Dutour.
 
 This file is part of the MPFR Library.
@@ -32,7 +32,7 @@
 special (void)
 {
   mpfr_t x, y;
-  mp_rnd_t r;
+  int r;
 
   mpfr_init (x);
   mpfr_init (y);
@@ -98,13 +98,13 @@
   for (r = 0; r < GMP_RND_MAX; r++)
     {
       mpfr_set_ui (x, 1, GMP_RNDN); /* exact */
-      mpfr_asin (y, x, r);
-      mpfr_const_pi (x, r);
+      mpfr_asin (y, x, (mp_rnd_t) r);
+      mpfr_const_pi (x, (mp_rnd_t) r);
       mpfr_div_2exp (x, x, 1, GMP_RNDN); /* exact */
       if (mpfr_cmp (x, y))
         {
           printf ("Error: asin(1) != Pi/2 for rnd=%s\n",
-                  mpfr_print_rnd_mode (r));
+                  mpfr_print_rnd_mode ((mp_rnd_t) r));
           exit (1);
         }
     }
@@ -113,14 +113,14 @@
   for (r = 0; r < GMP_RND_MAX; r++)
     {
       mpfr_set_si (x, -1, GMP_RNDN); /* exact */
-      mpfr_asin (y, x, r);
-      mpfr_const_pi (x, MPFR_INVERT_RND(r));
+      mpfr_asin (y, x, (mp_rnd_t) r);
+      mpfr_const_pi (x, MPFR_INVERT_RND((mp_rnd_t) r));
       mpfr_neg (x, x, GMP_RNDN); /* exact */
       mpfr_div_2exp (x, x, 1, GMP_RNDN); /* exact */
       if (mpfr_cmp (x, y))
         {
           printf ("Error: asin(-1) != -Pi/2 for rnd=%s\n",
-                  mpfr_print_rnd_mode (r));
+                  mpfr_print_rnd_mode ((mp_rnd_t) r));
           exit (1);
         }
     }
diff -Naur mpfr-2.1.0-p9/tests/tatan.c mpfr-2.1.0-p10/tests/tatan.c
--- mpfr-2.1.0-p9/tests/tatan.c	2004-10-27 13:16:13.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tatan.c	2005-01-27 17:03:39.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_atan.
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 Written by Paul Zimmermann, INRIA Lorraine.
 
 This file is part of the MPFR Library.
@@ -29,7 +29,7 @@
 special (void)
 {
   mpfr_t x, y, z;
-  mp_rnd_t r;
+  int r;
 
   mpfr_init2 (x, 53);
   mpfr_init2 (y, 53);
@@ -55,12 +55,13 @@
   for (r = 0; r < GMP_RND_MAX ; r++)
     {
       mpfr_set_inf (x, 1);
-      mpfr_atan (y, x, r);
-      mpfr_const_pi (x, r);
-      mpfr_div_2exp (x, x, 1, r);
+      mpfr_atan (y, x, (mp_rnd_t) r);
+      mpfr_const_pi (x, (mp_rnd_t) r);
+      mpfr_div_2exp (x, x, 1, (mp_rnd_t) r);
       if (mpfr_cmp (x, y))
         {
-          printf ("Error: mpfr_atan(+Inf), rnd=%s\n", mpfr_print_rnd_mode (r));
+          printf ("Error: mpfr_atan(+Inf), rnd=%s\n",
+                  mpfr_print_rnd_mode ((mp_rnd_t) r));
           exit (1);
         }
     }
@@ -69,13 +70,14 @@
   for (r = 0; r < GMP_RND_MAX ; r++)
     {
       mpfr_set_inf (x, -1);
-      mpfr_atan (y, x, r);
-      mpfr_const_pi (x, MPFR_INVERT_RND(r));
-      mpfr_neg (x, x, r);
-      mpfr_div_2exp (x, x, 1, r);
+      mpfr_atan (y, x, (mp_rnd_t) r);
+      mpfr_const_pi (x, MPFR_INVERT_RND((mp_rnd_t) r));
+      mpfr_neg (x, x, (mp_rnd_t) r);
+      mpfr_div_2exp (x, x, 1, (mp_rnd_t) r);
       if (mpfr_cmp (x, y))
         {
-          printf ("Error: mpfr_atan(-Inf), rnd=%s\n", mpfr_print_rnd_mode (r));
+          printf ("Error: mpfr_atan(-Inf), rnd=%s\n",
+                  mpfr_print_rnd_mode ((mp_rnd_t) r));
           exit (1);
         }
     }
diff -Naur mpfr-2.1.0-p9/tests/tcan_round.c mpfr-2.1.0-p10/tests/tcan_round.c
--- mpfr-2.1.0-p9/tests/tcan_round.c	2004-02-06 13:27:04.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tcan_round.c	2005-01-27 17:15:57.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_can_round.
 
-Copyright 1999, 2001, 2002, 2003 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -62,10 +62,10 @@
   for (i = 30; i < 99; i++)
     for (j = 30; j < 99; j++)
       {
-        mp_rnd_t r1, r2;
+        int r1, r2;
         for (r1 = 0; r1 < GMP_RND_MAX ; r1++)
           for (r2 = 0; r2 < GMP_RND_MAX ; r2++)
-            mpfr_can_round (x, i, r1, r2, j); /* test for assertions */
+            mpfr_can_round (x, i, (mp_rnd_t) r1, (mp_rnd_t) r2, j); /* test for assertions */
       }
 
   mpfr_clear (x);
diff -Naur mpfr-2.1.0-p9/tests/tcbrt.c mpfr-2.1.0-p10/tests/tcbrt.c
--- mpfr-2.1.0-p9/tests/tcbrt.c	2004-02-23 16:47:46.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tcbrt.c	2005-01-27 17:14:39.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_cbrt.
 
-Copyright 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -136,7 +136,7 @@
 main (void)
 {
   mpfr_t x;
-  mp_rnd_t r;
+  int r;
   mp_prec_t p;
 
   tests_start_mpfr ();
@@ -151,21 +151,21 @@
       for (r = 0; r < GMP_RND_MAX; r++)
         {
           mpfr_set_ui (x, 1, GMP_RNDN);
-          mpfr_cbrt (x, x, r);
+          mpfr_cbrt (x, x, (mp_rnd_t) r);
           if (mpfr_cmp_ui (x, 1))
             {
               printf ("Error in mpfr_cbrt for x=1, rnd=%s\ngot ",
-                      mpfr_print_rnd_mode (r));
+                      mpfr_print_rnd_mode ((mp_rnd_t) r));
               mpfr_out_str (stdout, 2, 0, x, GMP_RNDN);
               printf ("\n");
               exit (1);
             }
           mpfr_set_si (x, -1, GMP_RNDN);
-          mpfr_cbrt (x, x, r);
+          mpfr_cbrt (x, x, (mp_rnd_t) r);
           if (mpfr_cmp_si (x, -1))
             {
               printf ("Error in mpfr_cbrt for x=-1, rnd=%s\ngot ",
-                      mpfr_print_rnd_mode (r));
+                      mpfr_print_rnd_mode ((mp_rnd_t) r));
               mpfr_out_str (stdout, 2, 0, x, GMP_RNDN);
               printf ("\n");
               exit (1);
@@ -183,7 +183,7 @@
                     {
                       printf ("Error in mpfr_cbrt for "
                               "x = 27.0 * 2^(%d), rnd=%s\ngot ",
-                              3*i, mpfr_print_rnd_mode (r));
+                              3*i, mpfr_print_rnd_mode ((mp_rnd_t) r));
                       mpfr_out_str (stdout, 2, 0, x, GMP_RNDN);
                       printf ("\ninstead of 3 * 2^(%d)\n", i);
                       exit (1);
diff -Naur mpfr-2.1.0-p9/tests/tcmp.c mpfr-2.1.0-p10/tests/tcmp.c
--- mpfr-2.1.0-p9/tests/tcmp.c	2004-09-29 13:58:06.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tcmp.c	2005-01-27 17:18:01.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_cmp.
 
-Copyright 1999, 2001, 2002, 2003 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -76,23 +76,24 @@
       exit (1);
     }
 
-  mpfr_set_prec(xx, 53); mpfr_set_prec(yy, 200);
-  mpfr_set_ui(xx, 1, 0);
-  mpfr_set_ui(yy, 1, 0);
-  if (mpfr_cmp(xx, yy) != 0)
+  mpfr_set_prec (xx, 53);
+  mpfr_set_prec (yy, 200);
+  mpfr_set_ui (xx, 1, (mp_rnd_t) 0);
+  mpfr_set_ui (yy, 1, (mp_rnd_t) 0);
+  if (mpfr_cmp (xx, yy) != 0)
     {
       printf ("Error in mpfr_cmp: 1.0 != 1.0\n");
       exit (1);
     }
-  mpfr_set_prec(yy, 31);
-  mpfr_set_str(xx, "1.0000000002", 10, 0);
-  mpfr_set_ui(yy, 1, 0);
-  if (!(mpfr_cmp(xx,yy)>0))
+  mpfr_set_prec (yy, 31);
+  mpfr_set_str (xx, "1.0000000002", 10, (mp_rnd_t) 0);
+  mpfr_set_ui (yy, 1, (mp_rnd_t) 0);
+  if (!(mpfr_cmp (xx,yy)>0))
     {
       printf ("Error in mpfr_cmp: not 1.0000000002 > 1.0\n");
       exit (1);
     }
-  mpfr_set_prec(yy, 53);
+  mpfr_set_prec (yy, 53);
 
   /* bug found by Gerardo Ballabio */
   mpfr_set_ui(xx, 0, GMP_RNDN);
diff -Naur mpfr-2.1.0-p9/tests/tcmpabs.c mpfr-2.1.0-p10/tests/tcmpabs.c
--- mpfr-2.1.0-p9/tests/tcmpabs.c	2004-09-29 13:58:06.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tcmpabs.c	2005-01-27 17:18:28.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_cmpabs.
 
-Copyright 2004 Free Software Foundation, Inc.
+Copyright 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -65,14 +65,14 @@
 
   mpfr_set_prec(xx, 53); 
   mpfr_set_prec(yy, 200);
-  mpfr_set_ui(xx, 1, 0);
-  mpfr_set_ui(yy, 1, 0);
+  mpfr_set_ui (xx, 1, (mp_rnd_t) 0);
+  mpfr_set_ui (yy, 1, (mp_rnd_t) 0);
   if (mpfr_cmpabs(xx, yy) != 0)
     ERROR ("Error in mpfr_cmpabs: 1.0 != 1.0\n");
     
-  mpfr_set_prec(yy, 31);
-  mpfr_set_str(xx, "-1.0000000002", 10, 0);
-  mpfr_set_ui(yy, 1, 0);
+  mpfr_set_prec (yy, 31);
+  mpfr_set_str (xx, "-1.0000000002", 10, (mp_rnd_t) 0);
+  mpfr_set_ui (yy, 1, (mp_rnd_t) 0);
   if (!(mpfr_cmpabs(xx,yy)>0))
     ERROR ("Error in mpfr_cmpabs: not 1.0000000002 > 1.0\n");
   mpfr_set_prec(yy, 53);
diff -Naur mpfr-2.1.0-p9/tests/tconst_euler.c mpfr-2.1.0-p10/tests/tconst_euler.c
--- mpfr-2.1.0-p9/tests/tconst_euler.c	2004-02-23 16:47:46.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tconst_euler.c	2005-01-27 17:20:14.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_const_euler.
 
-Copyright 2001, 2004 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -29,7 +29,7 @@
 {
   mpfr_t gamma, y, z, t;
   unsigned int err, prec, yprec, p0 = 2, p1 = 200;
-  mp_rnd_t rnd;
+  int rnd;
 
   tests_start_mpfr ();
 
@@ -68,16 +68,16 @@
       for (rnd = 0; rnd < GMP_RND_MAX; rnd++)
 	{
 	  mpfr_set_prec (y, yprec);
-	  mpfr_const_euler (y, rnd);
+	  mpfr_const_euler (y, (mp_rnd_t) rnd);
 	  err = (rnd == GMP_RNDN) ? yprec + 1 : yprec;
-	  if (mpfr_can_round (y, err, rnd, rnd, prec))
+	  if (mpfr_can_round (y, err, (mp_rnd_t) rnd, (mp_rnd_t) rnd, prec))
 	    {
-	      mpfr_set (t, y, rnd);
-	      mpfr_const_euler (z, rnd);
+	      mpfr_set (t, y, (mp_rnd_t) rnd);
+	      mpfr_const_euler (z, (mp_rnd_t) rnd);
 	      if (mpfr_cmp (t, z))
 		{
 		  printf ("results differ for prec=%u rnd_mode=%s\n", prec,
-			  mpfr_print_rnd_mode (rnd));
+			  mpfr_print_rnd_mode ((mp_rnd_t) rnd));
 		  printf ("   got      ");
 		  mpfr_out_str (stdout, 2, prec, z, GMP_RNDN);
 		  puts ("");
diff -Naur mpfr-2.1.0-p9/tests/tconst_log2.c mpfr-2.1.0-p10/tests/tconst_log2.c
--- mpfr-2.1.0-p9/tests/tconst_log2.c	2004-04-21 12:36:30.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tconst_log2.c	2005-01-27 17:20:59.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_const_log2.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -43,7 +43,7 @@
       mpfr_set_prec (x, p0);
       mpfr_set_prec (y, p0);
         {
-          rnd = RND_RAND ();
+          rnd = (mp_rnd_t) RND_RAND ();
           mpfr_const_log2 (x, rnd);
           mpfr_set (y, z, rnd);
           if (mpfr_cmp (x, y) && mpfr_can_round (z, mpfr_get_prec(z), GMP_RNDN,
@@ -135,7 +135,7 @@
   tests_start_mpfr ();
 
   p = (argc>1) ? atoi(argv[1]) : 53;
-  rnd = (argc>2) ? atoi(argv[2]) : GMP_RNDZ;
+  rnd = (argc>2) ? (mp_rnd_t) atoi(argv[2]) : GMP_RNDZ;
 
   mpfr_init (x);
 
diff -Naur mpfr-2.1.0-p9/tests/tconst_pi.c mpfr-2.1.0-p10/tests/tconst_pi.c
--- mpfr-2.1.0-p9/tests/tconst_pi.c	2004-04-21 12:36:30.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tconst_pi.c	2005-01-27 17:21:49.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_const_pi.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -55,7 +55,7 @@
 {
   mpfr_t x;
   int p;
-  unsigned char rnd;
+  mp_rnd_t rnd;
 
   tests_start_mpfr ();
 
@@ -67,7 +67,7 @@
         p = a;
     }
 
-  rnd = (argc > 2) ? atoi(argv[2]) : GMP_RNDZ;
+  rnd = (argc > 2) ? (mp_rnd_t) atoi(argv[2]) : GMP_RNDZ;
 
   mpfr_init2 (x, p);
   mpfr_const_pi (x, rnd);
diff -Naur mpfr-2.1.0-p9/tests/tdiv.c mpfr-2.1.0-p10/tests/tdiv.c
--- mpfr-2.1.0-p9/tests/tdiv.c	2004-10-27 13:16:13.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tdiv.c	2005-01-27 17:22:14.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_div.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -211,11 +211,11 @@
       for (j = 0;j < GMP_RND_MAX; j++)
         {
           mpfr_set_ui (y, 1, GMP_RNDN);
-          mpfr_div (y, x, y, j);
+          mpfr_div (y, x, y, (mp_rnd_t) j);
           if (mpfr_cmp_ui (y, 1))
             {
               printf ("mpfr_div failed for x=1.0, y=1.0, prec=%d rnd=%s\n",
-                      i, mpfr_print_rnd_mode(j));
+                      i, mpfr_print_rnd_mode ((mp_rnd_t) j));
               printf ("got "); mpfr_print_binary(y); puts ("");
               exit (1);
             }
@@ -428,7 +428,7 @@
 	      mpfr_set_prec (y, py);
 	      mpfr_set_prec (z, py + pu);
 		{
-                  rnd = RND_RAND ();
+                  rnd = (mp_rnd_t) RND_RAND ();
 		  inexact = mpfr_div (y, x, u, rnd);
 		  if (mpfr_mul (z, y, u, rnd))
 		    {
diff -Naur mpfr-2.1.0-p9/tests/tdiv_ui.c mpfr-2.1.0-p10/tests/tdiv_ui.c
--- mpfr-2.1.0-p9/tests/tdiv_ui.c	2004-02-23 16:47:46.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tdiv_ui.c	2005-01-27 17:22:35.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_div_ui.
 
-Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -140,7 +140,7 @@
   mp_prec_t px, py;
   int inexact, cmp;
   unsigned long int u;
-  mp_rnd_t rnd;
+  int rnd;
 
   mpfr_init (x);
   mpfr_init (y);
@@ -161,8 +161,8 @@
           mpfr_set_prec (z, py + mp_bits_per_limb);
           for (rnd = 0; rnd < GMP_RND_MAX; rnd++)
             {
-              inexact = mpfr_div_ui (y, x, u, rnd);
-              if (mpfr_mul_ui (z, y, u, rnd))
+              inexact = mpfr_div_ui (y, x, u, (mp_rnd_t) rnd);
+              if (mpfr_mul_ui (z, y, u, (mp_rnd_t) rnd))
                 {
                   printf ("z <- y * u should be exact for u=%lu\n", u);
                   printf ("y="); mpfr_print_binary (y); puts ("");
@@ -175,7 +175,7 @@
                   ((inexact < 0) && (cmp >= 0)))
                 {
                   printf ("Wrong inexact flag for u=%lu, rnd=%s\n", u,
-                          mpfr_print_rnd_mode(rnd));
+                          mpfr_print_rnd_mode ((mp_rnd_t) rnd));
                   printf ("x="); mpfr_print_binary (x); puts ("");
                   printf ("y="); mpfr_print_binary (y); puts ("");
                   exit (1);
diff -Naur mpfr-2.1.0-p9/tests/teq.c mpfr-2.1.0-p10/tests/teq.c
--- mpfr-2.1.0-p9/tests/teq.c	2004-02-13 13:57:24.000000000 +0000
+++ mpfr-2.1.0-p10/tests/teq.c	2005-01-27 17:23:23.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_eq.
 
-Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -75,8 +75,8 @@
   mpfr_init2 (y, 53);
   mpfr_init2 (z, 53);
 
-  mpfr_set_str (x, "1", 10, 0);
-  mpfr_set_str (y, "1e-10000", 10, 0);
+  mpfr_set_str (x, "1", 10, (mp_rnd_t) 0);
+  mpfr_set_str (y, "1e-10000", 10, (mp_rnd_t) 0);
   mpfr_add (z, x, y, GMP_RNDU);
 
   for (i = 1; i <= 52; i++)
diff -Naur mpfr-2.1.0-p9/tests/tests.c mpfr-2.1.0-p10/tests/tests.c
--- mpfr-2.1.0-p9/tests/tests.c	2005-01-23 23:20:09.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tests.c	2005-01-27 17:23:51.000000000 +0000
@@ -1,6 +1,6 @@
 /* Miscellaneous support for test programs.
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -302,7 +302,7 @@
 
   if (srcdir == NULL)
     return fopen (filename, mode);
-  buffer = malloc (strlen (filename) + strlen (srcdir) + 1);
+  buffer = (char*) malloc (strlen (filename) + strlen (srcdir) + 1);
   if (buffer == NULL)
     {
       printf ("src_fopen: failed to alloc memory)\n");
diff -Naur mpfr-2.1.0-p9/tests/texceptions.c mpfr-2.1.0-p10/tests/texceptions.c
--- mpfr-2.1.0-p9/tests/texceptions.c	2004-10-27 13:16:13.000000000 +0000
+++ mpfr-2.1.0-p10/tests/texceptions.c	2005-01-27 17:03:06.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for exceptions.
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -30,18 +30,19 @@
 static void
 check_default_rnd (void)
 {
-  mp_rnd_t r, t;
+  int r;
+  mp_rnd_t t;
   for(r = 0 ; r < GMP_RND_MAX ; r++)
     {
-      mpfr_set_default_rounding_mode (r);
+      mpfr_set_default_rounding_mode ((mp_rnd_t) r);
       t = mpfr_get_default_rounding_mode();
-      if (r !=t)
+      if ((mp_rnd_t) r != t)
 	ERROR("ERROR in setting / getting default rounding mode (1)\n");
     }
-  mpfr_set_default_rounding_mode(4);
+  mpfr_set_default_rounding_mode ((mp_rnd_t) 4);
   if (mpfr_get_default_rounding_mode() != GMP_RNDD)
     ERROR("ERROR in setting / getting default rounding mode (2)\n");
-  mpfr_set_default_rounding_mode(-1);
+  mpfr_set_default_rounding_mode ((mp_rnd_t) -1);
   if (mpfr_get_default_rounding_mode() != GMP_RNDD)
     ERROR("ERROR in setting / getting default rounding mode (3)\n");
 }
@@ -137,7 +138,7 @@
   mpfr_t x, zero, min;
   mpfr_ptr r[4];
   int t[4] = { 1, -1, 1, -1 };
-  mp_rnd_t i;
+  int i;
   int s;
 
   mpfr_inits (x, zero, min, (mpfr_ptr) 0);
@@ -154,11 +155,11 @@
           int inex;
 
           j = s < 0 && i > 1 ? 5 - i : i;
-          inex = mpfr_set_underflow (x, i, s);
+          inex = mpfr_set_underflow (x, (mp_rnd_t) i, s);
           if (mpfr_cmp (x, r[j]) || inex * t[j] <= 0)
             {
               printf ("Error in test_set_underflow, sign = %d,"
-                      " rnd_mode = %s\n", s, mpfr_print_rnd_mode (i));
+                      " rnd_mode = %s\n", s, mpfr_print_rnd_mode ((mp_rnd_t) i));
               printf ("Got\n");
               mpfr_out_str (stdout, 2, 0, x, GMP_RNDN);
               printf (", inex = %d\ninstead of\n", inex);
@@ -180,7 +181,7 @@
   mpfr_t x, inf, max;
   mpfr_ptr r[4];
   int t[4] = { 1, -1, 1, -1 };
-  mp_rnd_t i;
+  int i;
   int s;
 
   mpfr_inits2 (32, x, inf, max, (mpfr_ptr) 0);
@@ -197,11 +198,11 @@
           int inex;
 
           j = s < 0 && i > 1 ? 5 - i : i;
-          inex = mpfr_set_overflow (x, i, s);
+          inex = mpfr_set_overflow (x, (mp_rnd_t) i, s);
           if (mpfr_cmp (x, r[j]) || inex * t[j] <= 0)
             {
               printf ("Error in test_set_overflow, sign = %d,"
-                      " rnd_mode = %s\n", s, mpfr_print_rnd_mode (i));
+                      " rnd_mode = %s\n", s, mpfr_print_rnd_mode ((mp_rnd_t) i));
               printf ("Got\n");
               mpfr_out_str (stdout, 2, 0, x, GMP_RNDN);
               printf (", inex = %d\ninstead of\n", inex);
diff -Naur mpfr-2.1.0-p9/tests/texp.c mpfr-2.1.0-p10/tests/texp.c
--- mpfr-2.1.0-p9/tests/texp.c	2004-10-27 13:16:14.000000000 +0000
+++ mpfr-2.1.0-p10/tests/texp.c	2005-01-27 17:24:50.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_exp.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -142,7 +142,7 @@
       mpfr_set_prec (y, prec);
       mpfr_set_prec (z, prec);
       mpfr_random (x);
-      rnd = RND_RAND() ;
+      rnd = (mp_rnd_t) RND_RAND();
       mpfr_exp_2 (y, x, rnd);
       mpfr_exp_3 (z, x, rnd);
       if (mpfr_cmp (y,z))
diff -Naur mpfr-2.1.0-p9/tests/tfactorial.c mpfr-2.1.0-p10/tests/tfactorial.c
--- mpfr-2.1.0-p9/tests/tfactorial.c	2004-02-23 16:47:46.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tfactorial.c	2005-01-27 17:25:11.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_factorial.
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -74,7 +74,7 @@
   mpz_t f;
   mpfr_t x, y;
   mp_prec_t prec_f, p;
-  mp_rnd_t r;
+  int r;
   int inex1, inex2;
 
   mpz_init (f);
@@ -92,19 +92,19 @@
           mpfr_set_prec (y, p);
           for (r = 0; r < GMP_RND_MAX; r++)
             {
-              inex1 = mpfr_fac_ui (x, n, r);
-              inex2 = mpfr_set_z (y, f, r);
+              inex1 = mpfr_fac_ui (x, n, (mp_rnd_t) r);
+              inex2 = mpfr_set_z (y, f, (mp_rnd_t) r);
               if (mpfr_cmp (x, y))
                 {
                   printf ("Error for n=%lu prec=%lu rnd=%s\n",
-                          n, (unsigned long) p, mpfr_print_rnd_mode (r));
+                          n, (unsigned long) p, mpfr_print_rnd_mode ((mp_rnd_t) r));
                   exit (1);
                 }
               if ((inex1 < 0 && inex2 >= 0) || (inex1 == 0 && inex2 != 0)
                   || (inex1 > 0 && inex2 <= 0))
                 {
                   printf ("Wrong inexact flag for n=%lu prec=%lu rnd=%s\n",
-                          n, (unsigned long) p, mpfr_print_rnd_mode (r));
+                          n, (unsigned long) p, mpfr_print_rnd_mode ((mp_rnd_t) r));
                   exit (1);
                 }
             }
@@ -120,7 +120,7 @@
 main (int argc, char *argv[])
 {
   unsigned int prec, err, yprec, n, k, zeros;
-  mp_rnd_t rnd;
+  int rnd;
   mpfr_t x, y, z, t;
   int inexact;
 
@@ -154,12 +154,12 @@
       for (n = 0; n < 50; n++)
 	for (rnd = 0; rnd < GMP_RND_MAX; rnd++)
 	  {
-	    inexact = mpfr_fac_ui (y, n, rnd);
+	    inexact = mpfr_fac_ui (y, n, (mp_rnd_t) rnd);
 	    err = (rnd == GMP_RNDN) ? yprec + 1 : yprec;
-	    if (mpfr_can_round (y, err, rnd, rnd, prec))
+	    if (mpfr_can_round (y, err, (mp_rnd_t) rnd, (mp_rnd_t) rnd, prec))
 	      {
-		mpfr_set (t, y, rnd);
-		inexact = mpfr_fac_ui (z, n, rnd);
+		mpfr_set (t, y, (mp_rnd_t) rnd);
+		inexact = mpfr_fac_ui (z, n, (mp_rnd_t) rnd);
 		/* fact(n) ends with floor(n/2)+floor(n/4)+... zeros */
 		for (k=n/2, zeros=0; k; k >>= 1)
 		  zeros += k;
@@ -187,7 +187,7 @@
 		    printf ("results differ for x=");
 		    mpfr_out_str (stdout, 2, prec, x, GMP_RNDN);
 		    printf (" prec=%u rnd_mode=%s\n", prec,
-			    mpfr_print_rnd_mode (rnd));
+			    mpfr_print_rnd_mode ((mp_rnd_t) rnd));
 		    printf ("   got ");
 		    mpfr_out_str (stdout, 2, prec, z, GMP_RNDN);
 		    puts ("");
diff -Naur mpfr-2.1.0-p9/tests/tfma.c mpfr-2.1.0-p10/tests/tfma.c
--- mpfr-2.1.0-p9/tests/tfma.c	2004-02-12 16:01:26.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tfma.c	2005-01-27 17:25:41.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_fma.
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 Adapted from tarctan.c.
 
 This file is part of the MPFR Library.
@@ -260,7 +260,7 @@
           if (randlimb () % 2)
             mpfr_neg (z, z, GMP_RNDN);
 
-          rnd = RND_RAND ();
+          rnd = (mp_rnd_t) RND_RAND ();
           mpfr_set_prec (slong, 2 * prec);
           if (mpfr_mul (slong, x, y, rnd))
             {
diff -Naur mpfr-2.1.0-p9/tests/tfrac.c mpfr-2.1.0-p10/tests/tfrac.c
--- mpfr-2.1.0-p9/tests/tfrac.c	2004-02-12 16:08:00.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tfrac.c	2005-01-27 17:26:27.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_frac.
 
-Copyright 2002, 2003, 2004 Free Software Foundation.
+Copyright 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -113,16 +113,16 @@
 static void
 check1 (mpfr_ptr ip, mpfr_ptr fp)
 {
-  mp_rnd_t rnd;
+  int rnd;
 
   for (rnd = 0; rnd < GMP_RND_MAX ; rnd++)
     {
-      check0 (ip, fp, PMAX, rnd);
-      check0 (ip, fp, 70, rnd);
+      check0 (ip, fp, PMAX, (mp_rnd_t) rnd);
+      check0 (ip, fp, 70, (mp_rnd_t) rnd);
       mpfr_neg (fp, fp, GMP_RNDN);
       mpfr_neg (ip, ip, GMP_RNDN);
-      check0 (ip, fp, PMAX, rnd);
-      check0 (ip, fp, 70, rnd);
+      check0 (ip, fp, PMAX, (mp_rnd_t) rnd);
+      check0 (ip, fp, 70, (mp_rnd_t) rnd);
       mpfr_neg (fp, fp, GMP_RNDN);
       mpfr_neg (ip, ip, GMP_RNDN);
     }
diff -Naur mpfr-2.1.0-p9/tests/tgeneric.c mpfr-2.1.0-p10/tests/tgeneric.c
--- mpfr-2.1.0-p9/tests/tgeneric.c	2004-02-06 13:27:05.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tgeneric.c	2005-01-27 17:27:49.000000000 +0000
@@ -1,6 +1,6 @@
 /* Generic test file for functions with one mpfr_t argument.
 
-Copyright 2001, 2002, 2003 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -48,7 +48,7 @@
 #else
           mpfr_random (x);
 #endif
-          rnd = RND_RAND ();
+          rnd = (mp_rnd_t) RND_RAND ();
           mpfr_set_prec (y, yprec);
           compare = TEST_FUNCTION (y, x, rnd);
           if (mpfr_can_round (y, yprec, rnd, rnd, prec))
diff -Naur mpfr-2.1.0-p9/tests/tget_d_2exp.c mpfr-2.1.0-p10/tests/tget_d_2exp.c
--- mpfr-2.1.0-p9/tests/tget_d_2exp.c	2004-03-12 17:45:07.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tget_d_2exp.c	2005-01-27 17:29:05.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test mpfr_get_d_2exp.
 
-Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation.
+Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -49,7 +49,7 @@
 
           for (neg = 0; neg <= 1; neg++)
             {
-              got = mpfr_get_d_2exp (&got_exp, f, rnd_mode);
+              got = mpfr_get_d_2exp (&got_exp, f, (mp_rnd_t) rnd_mode);
 
               if (neg == 0
                   ? (got < 0.5 || got >= 1.0)
diff -Naur mpfr-2.1.0-p9/tests/tget_sj.c mpfr-2.1.0-p10/tests/tget_sj.c
--- mpfr-2.1.0-p9/tests/tget_sj.c	2004-09-29 12:27:33.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tget_sj.c	2005-01-27 17:30:01.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_get_sj and mpfr_get_uj.
 
-Copyright 2004 Free Software Foundation, Inc.
+Copyright 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -62,7 +62,7 @@
 
   for (i = -1; i <= 1; i++)
     {
-      mpfr_rnd_t rnd;
+      int rnd;
 
       mpfr_set_si_2exp (y, i, -2, GMP_RNDN);
       mpfr_add (y, y, x, GMP_RNDN);
@@ -79,12 +79,12 @@
           if (rnd == GMP_RNDU && i > 0)
             continue;
           /* rint (y) == x == s */
-          r = mpfr_get_sj (y, rnd);
+          r = mpfr_get_sj (y, (mp_rnd_t) rnd);
           if (r != s)
             {
               printf ("Error in check_sj for y = ");
               mpfr_out_str (stdout, 2, 0, y, GMP_RNDN);
-              printf (" in %s\n", mpfr_print_rnd_mode (rnd));
+              printf (" in %s\n", mpfr_print_rnd_mode ((mp_rnd_t) rnd));
               printf ("Got %jd instead of %jd.\n", r, s);
               exit (1);
             }
@@ -104,7 +104,7 @@
 
   for (i = -1; i <= 1; i++)
     {
-      mpfr_rnd_t rnd;
+      int rnd;
 
       mpfr_set_si_2exp (y, i, -2, GMP_RNDN);
       mpfr_add (y, y, x, GMP_RNDN);
@@ -119,12 +119,12 @@
           if (rnd == GMP_RNDU && i > 0)
             continue;
           /* rint (y) == x == u */
-          r = mpfr_get_uj (y, rnd);
+          r = mpfr_get_uj (y, (mp_rnd_t) rnd);
           if (r != u)
             {
               printf ("Error in check_uj for y = ");
               mpfr_out_str (stdout, 2, 0, y, GMP_RNDN);
-              printf (" in %s\n", mpfr_print_rnd_mode (rnd));
+              printf (" in %s\n", mpfr_print_rnd_mode ((mp_rnd_t) rnd));
               printf ("Got %ju instead of %ju.\n", r, u);
               exit (1);
             }
diff -Naur mpfr-2.1.0-p9/tests/tget_str.c mpfr-2.1.0-p10/tests/tget_str.c
--- mpfr-2.1.0-p9/tests/tget_str.c	2004-10-07 11:53:27.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tget_str.c	2005-01-27 17:30:50.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_get_str.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -963,7 +963,7 @@
   int i, j;
   char s[MAX_DIGITS + 2], s2[MAX_DIGITS + 2], c;
   mp_exp_t e;
-  mp_rnd_t r;
+  int r;
   size_t m;
 
   /* check for invalid base */
@@ -982,7 +982,7 @@
       for (r = 0; r < GMP_RND_MAX; r++)
         for (m= (i<3)? 2 : i-1 ; (int) m <= i+1 ; m++)
           {
-            mpfr_get_str (s, &e, b, m, x, r);
+            mpfr_get_str (s, &e, b, m, x, (mp_rnd_t) r);
             /* s should be 1 followed by (m-1) zeros, and e should be i+1 */
             if ((e != i+1) || strncmp (s, s2, m) != 0)
               {
@@ -996,7 +996,7 @@
       for (r = 0; r < GMP_RND_MAX; r++)
         if (i >= 2)
           {
-            mpfr_get_str (s, &e, b, i, x, r);
+            mpfr_get_str (s, &e, b, i, x, (mp_rnd_t) r);
             /* should be i times (b-1) */
             c = (b <= 10) ? '0' + b - 1 : 'a' + (b - 11);
             for (j=0; (j < i) && (s[j] == c); j++);
@@ -1087,7 +1087,7 @@
       mpfr_set_exp (x, (e == -10) ? mpfr_get_emin () :
                     ((e == 10) ? mpfr_get_emax () : e));
       b = 2 + (randlimb () % 35);
-      r = RND_RAND();
+      r = (mp_rnd_t) RND_RAND();
       mpfr_get_str (s, &f, b, m, x, r);
     }
   mpfr_clear (x);
diff -Naur mpfr-2.1.0-p9/tests/tgmpop.c mpfr-2.1.0-p10/tests/tgmpop.c
--- mpfr-2.1.0-p9/tests/tgmpop.c	2004-04-07 14:42:32.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tgmpop.c	2005-01-27 17:31:30.000000000 +0000
@@ -1,7 +1,7 @@
 /* Test file for mpfr_add_[q,z], mpfr_sub_[q,z], mpfr_div_[q,z], mpfr_mul_[q,z]
    and mpfr_cmp_[q,z]
 
-Copyright 2004 Free Software Foundation.
+Copyright 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -118,7 +118,7 @@
   mpq_t q;
   mpz_t z;
   mpfr_t x;
-  mp_rnd_t r;
+  int r;
   mpfr_sign_t i;
 
   mpfr_init (x);
@@ -135,43 +135,43 @@
 	   i+=MPFR_SIGN_POS-MPFR_SIGN_NEG)
 	{
 	  MPFR_SET_SIGN(x, i);
-	  mpfr_add_z (x, x, z, r);
+	  mpfr_add_z (x, x, z, (mp_rnd_t) r);
 	  if (!MPFR_IS_ZERO(x) || MPFR_SIGN(x)!=i)
 	    {
 	      printf("GMP Zero errors for add_z & rnd=%s & s=%d\n", 
-		     mpfr_print_rnd_mode(r), i);
+		     mpfr_print_rnd_mode ((mp_rnd_t) r), i);
 	      mpfr_dump (x);
 	      exit (1);
 	    }
-	  mpfr_sub_z (x, x, z, r);
+	  mpfr_sub_z (x, x, z, (mp_rnd_t) r);
 	  if (!MPFR_IS_ZERO(x) || MPFR_SIGN(x)!=i)
 	    {
 	      printf("GMP Zero errors for sub_z & rnd=%s & s=%d\n",
-		     mpfr_print_rnd_mode(r), i);
+		     mpfr_print_rnd_mode ((mp_rnd_t) r), i);
 	      mpfr_dump (x);
 	      exit (1);
 	    }
-	  mpfr_mul_z (x, x, z, r);
+	  mpfr_mul_z (x, x, z, (mp_rnd_t) r);
           if (!MPFR_IS_ZERO(x) || MPFR_SIGN(x)!=i)
             {
               printf("GMP Zero errors for mul_z & rnd=%s & s=%d\n",
-                     mpfr_print_rnd_mode(r), i);
+                     mpfr_print_rnd_mode ((mp_rnd_t) r), i);
               mpfr_dump (x);
 	      exit (1);
             }
-          mpfr_add_q (x, x, q, r);
+          mpfr_add_q (x, x, q, (mp_rnd_t) r);
           if (!MPFR_IS_ZERO(x) || MPFR_SIGN(x)!=i)
             {
               printf("GMP Zero errors for add_q & rnd=%s & s=%d\n",
-                     mpfr_print_rnd_mode(r), i);
+                     mpfr_print_rnd_mode ((mp_rnd_t) r), i);
               mpfr_dump (x);
               exit (1);
             }
-          mpfr_sub_q (x, x, q, r);
+          mpfr_sub_q (x, x, q, (mp_rnd_t) r);
           if (!MPFR_IS_ZERO(x) || MPFR_SIGN(x)!=i)
             {
               printf("GMP Zero errors for sub_q & rnd=%s & s=%d\n",
-                     mpfr_print_rnd_mode(r), i);
+                     mpfr_print_rnd_mode ((mp_rnd_t) r), i);
               mpfr_dump (x);
               exit (1);
              }
@@ -389,7 +389,7 @@
         {
           mpfr_urandomb (arg1, RANDS);
 	  mpz_urandomb (arg2, RANDS, 1024);
-          rnd = RND_RAND ();
+          rnd = (mp_rnd_t) RND_RAND ();
           mpfr_set_prec (dst_big, 2*prec);
           compare = func(dst_big, arg1, arg2, rnd);
           if (mpfr_can_round (dst_big, 2*prec, rnd, rnd, prec))
@@ -467,7 +467,7 @@
           mpfr_urandomb (arg1, RANDS);
           mpq_set_ui (arg2, randlimb (), randlimb() );
 	  mpq_canonicalize (arg2);
-          rnd = RND_RAND ();
+          rnd = (mp_rnd_t) RND_RAND ();
           mpfr_set_prec (dst_big, prec+10);
           compare = func(dst_big, arg1, arg2, rnd);
           if (mpfr_can_round (dst_big, prec+10, rnd, rnd, prec))
diff -Naur mpfr-2.1.0-p9/tests/thypot.c mpfr-2.1.0-p10/tests/thypot.c
--- mpfr-2.1.0-p9/tests/thypot.c	2004-02-14 11:11:31.000000000 +0000
+++ mpfr-2.1.0-p10/tests/thypot.c	2005-01-27 17:32:18.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_hypot.
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 Adapted from tarctan.c.
 
 This file is part of the MPFR Library.
@@ -147,7 +147,7 @@
             mpfr_neg (x1, x1, GMP_RNDN);
           if (randlimb () % 2)
             mpfr_neg (x2, x2, GMP_RNDN);
-          rnd = RND_RAND ();
+          rnd = (mp_rnd_t) RND_RAND ();
           mpfr_set_prec (y, yprec);
 
           compare =TEST_FUNCTION (y, x1,x2, rnd);
diff -Naur mpfr-2.1.0-p9/tests/tlog.c mpfr-2.1.0-p10/tests/tlog.c
--- mpfr-2.1.0-p9/tests/tlog.c	2004-10-27 13:16:14.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tlog.c	2005-01-27 17:32:33.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_log.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -204,7 +204,7 @@
 
   if (argc==4)
     {   /* tlog x prec rnd */
-      check3 (atof(argv[1]), atoi(argv[2]), atoi(argv[3]));
+      check3 (atof(argv[1]), atoi(argv[2]), (mp_rnd_t) atoi(argv[3]));
       goto done;
     }
 
diff -Naur mpfr-2.1.0-p9/tests/tmul.c mpfr-2.1.0-p10/tests/tmul.c
--- mpfr-2.1.0-p9/tests/tmul.c	2004-10-27 13:16:14.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tmul.c	2005-01-27 17:32:52.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_mul.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -217,7 +217,7 @@
         {
           mpfr_random (a);
           mpfr_random (b);
-          rnd = RND_RAND ();
+          rnd = (mp_rnd_t) RND_RAND ();
           inexact = mpfr_mul (c, a, b, rnd);
           if (mpfr_mul (d, a, b, rnd)) /* should be always exact */
             {
diff -Naur mpfr-2.1.0-p9/tests/tmul_ui.c mpfr-2.1.0-p10/tests/tmul_ui.c
--- mpfr-2.1.0-p9/tests/tmul_ui.c	2004-10-27 13:16:14.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tmul_ui.c	2005-01-27 17:33:32.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_mul_ui.
 
-Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -31,7 +31,7 @@
   unsigned long u;
   mp_prec_t q;
   int inexact, cmp;
-  mp_rnd_t rnd;
+  int rnd;
 
   mpfr_init2 (x, p);
   mpfr_init (y);
@@ -48,7 +48,7 @@
     for (rnd = 0; rnd < GMP_RND_MAX; rnd++)
       {
         mpfr_set_prec (y, q);
-        inexact = mpfr_mul_ui (y, x, u, rnd);
+        inexact = mpfr_mul_ui (y, x, u, (mp_rnd_t) rnd);
         cmp = mpfr_cmp (y, z);
         if (((inexact == 0) && (cmp != 0)) ||
             ((inexact < 0) && (cmp >= 0)) ||
@@ -56,7 +56,7 @@
           {
             printf ("Wrong inexact flag for p=%u, q=%u, rnd=%s\n",
                     (unsigned int) p, (unsigned int) q,
-                    mpfr_print_rnd_mode (rnd));
+                    mpfr_print_rnd_mode ((mp_rnd_t) rnd));
             exit (1);
           }
       }
diff -Naur mpfr-2.1.0-p9/tests/tout_str.c mpfr-2.1.0-p10/tests/tout_str.c
--- mpfr-2.1.0-p9/tests/tout_str.c	2004-10-22 13:16:27.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tout_str.c	2005-01-27 17:33:58.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_out_str.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -188,7 +188,7 @@
 #endif
       r = RND_RAND ();
       p = 2 + randlimb () % 35;
-      check (d, r, p);
+      check (d, (mp_rnd_t) r, p);
     }
 
   fclose (fout);
diff -Naur mpfr-2.1.0-p9/tests/toutimpl.c mpfr-2.1.0-p10/tests/toutimpl.c
--- mpfr-2.1.0-p9/tests/toutimpl.c	2004-02-13 11:30:05.000000000 +0000
+++ mpfr-2.1.0-p10/tests/toutimpl.c	2005-01-27 17:34:29.000000000 +0000
@@ -1,7 +1,7 @@
 /* Test file for internal debugging-out functions:
    mpfr_dump, mpfr_print_binary, mpfr_print_rnd_mode.
 
-Copyright 2004 Free Software Foundation, Inc.
+Copyright 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -65,7 +65,7 @@
       printf ("Error for printing GMP_RNDZ\n");
       exit (1);
     }
-  if (mpfr_print_rnd_mode (-1) != NULL ||
+  if (mpfr_print_rnd_mode ((mp_rnd_t) -1) != NULL ||
       mpfr_print_rnd_mode (GMP_RND_MAX) != NULL)
     {
       printf ("Error for illegal rounding mode values.\n");
diff -Naur mpfr-2.1.0-p9/tests/tpow.c mpfr-2.1.0-p10/tests/tpow.c
--- mpfr-2.1.0-p9/tests/tpow.c	2004-08-19 15:02:18.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tpow.c	2005-01-27 17:34:39.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_pow, mpfr_pow_ui and mpfr_pow_si.
 
-Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -155,7 +155,7 @@
   unsigned long u;
   mp_prec_t q;
   int inexact, cmp;
-  mp_rnd_t rnd;
+  int rnd;
 
   mpfr_init2 (x, p);
   mpfr_init (y);
@@ -169,15 +169,15 @@
         mpfr_set_prec (y, q);
         mpfr_set_prec (z, q + 10);
         mpfr_set_prec (t, q);
-        inexact = mpfr_pow_ui (y, x, u, rnd);
-        cmp = mpfr_pow_ui (z, x, u, rnd);
-        if (mpfr_can_round (z, q + 10, rnd, rnd, q))
+        inexact = mpfr_pow_ui (y, x, u, (mp_rnd_t) rnd);
+        cmp = mpfr_pow_ui (z, x, u, (mp_rnd_t) rnd);
+        if (mpfr_can_round (z, q + 10, (mp_rnd_t) rnd, (mp_rnd_t) rnd, q))
           {
-            cmp = mpfr_set (t, z, rnd) || cmp;
+            cmp = mpfr_set (t, z, (mp_rnd_t) rnd) || cmp;
             if (mpfr_cmp (y, t))
               {
                 printf ("results differ for u=%lu rnd=%s\n",
-                        u, mpfr_print_rnd_mode(rnd));
+                        u, mpfr_print_rnd_mode ((mp_rnd_t) rnd));
                 printf ("x="); mpfr_print_binary (x); puts ("");
                 printf ("y="); mpfr_print_binary (y); puts ("");
                 printf ("t="); mpfr_print_binary (t); puts ("");
@@ -189,7 +189,7 @@
               {
                 printf ("Wrong inexact flag for p=%u, q=%u, rnd=%s\n",
                         (unsigned int) p, (unsigned int) q,
-                        mpfr_print_rnd_mode (rnd));
+                        mpfr_print_rnd_mode ((mp_rnd_t) rnd));
                 printf ("expected %d, got %d\n", cmp, inexact);
                 printf ("u=%lu x=", u); mpfr_print_binary (x); puts ("");
                 printf ("y="); mpfr_print_binary (y); puts ("");
diff -Naur mpfr-2.1.0-p9/tests/tpow3.c mpfr-2.1.0-p10/tests/tpow3.c
--- mpfr-2.1.0-p9/tests/tpow3.c	2004-02-06 13:27:05.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tpow3.c	2005-01-27 17:35:11.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_pow.
 
-Copyright 2001, 2002, 2003 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2005 Free Software Foundation.
 Adapted from tarctan.c.
 
 This file is part of the MPFR Library.
@@ -65,7 +65,7 @@
           mpfr_random (s);
           if (randlimb () % 2)
             mpfr_neg (s, s, GMP_RNDN);
-          rnd = RND_RAND ();
+          rnd = (mp_rnd_t) RND_RAND ();
           mpfr_set_prec (y, yprec);
           compare = mpfr_pow (y, x, s, rnd);
           err = (rnd == GMP_RNDN) ? yprec + 1 : yprec;
diff -Naur mpfr-2.1.0-p9/tests/trint.c mpfr-2.1.0-p10/tests/trint.c
--- mpfr-2.1.0-p9/tests/trint.c	2005-01-23 23:20:09.000000000 +0000
+++ mpfr-2.1.0-p10/tests/trint.c	2005-01-27 17:38:45.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_rint, mpfr_trunc, mpfr_floor, mpfr_ceil, mpfr_round.
 
-Copyright 2002, 2003, 2004 Free Software Foundation.
+Copyright 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -209,7 +209,7 @@
   mpz_t z;
   mp_prec_t p;
   mpfr_t x, y, t, u, v;
-  mp_rnd_t r;
+  int r;
   int inexact, sign_t;
 
   tests_start_mpfr ();
@@ -250,7 +250,7 @@
             for (trint = 0; trint < 3; trint++)
               {
                 if (trint == 2)
-                  inexact = mpfr_rint (y, x, r);
+                  inexact = mpfr_rint (y, x, (mp_rnd_t) r);
                 else if (r == GMP_RNDN)
                   inexact = mpfr_round (y, x);
                 else if (r == GMP_RNDZ)
@@ -264,13 +264,14 @@
                              mpfr_rint_floor (y, x, GMP_RNDD));
                 if (mpfr_sub (t, y, x, GMP_RNDN))
                   err ("subtraction 1 should be exact",
-                       s, x, y, p, r, trint, inexact);
+                       s, x, y, p, (mp_rnd_t) r, trint, inexact);
                 sign_t = mpfr_cmp_ui (t, 0);
                 if (trint != 0 &&
                     (((inexact == 0) && (sign_t != 0)) ||
                      ((inexact < 0) && (sign_t >= 0)) ||
                      ((inexact > 0) && (sign_t <= 0))))
-                  err ("wrong inexact flag", s, x, y, p, r, trint, inexact);
+                  err ("wrong inexact flag",
+                       s, x, y, p, (mp_rnd_t) r, trint, inexact);
                 if (inexact == 0)
                   continue; /* end of the test for exact results */
 
@@ -279,31 +280,33 @@
                     ((r == GMP_RNDU || (r == GMP_RNDZ && MPFR_SIGN (x) < 0))
                      && inexact < 0))
                   err ("wrong rounding direction",
-                       s, x, y, p, r, trint, inexact);
+                       s, x, y, p, (mp_rnd_t) r, trint, inexact);
                 if (inexact < 0)
                   {
                     mpfr_add_ui (v, y, 1, GMP_RNDU);
                     if (mpfr_cmp (v, x) <= 0)
                       err ("representable integer between x and its "
-                           "rounded value", s, x, y, p, r, trint, inexact);
+                           "rounded value",
+                           s, x, y, p, (mp_rnd_t) r, trint, inexact);
                   }
                 else
                   {
                     mpfr_sub_ui (v, y, 1, GMP_RNDD);
                     if (mpfr_cmp (v, x) >= 0)
                       err ("representable integer between x and its "
-                           "rounded value", s, x, y, p, r, trint, inexact);
+                           "rounded value",
+                           s, x, y, p, (mp_rnd_t) r, trint, inexact);
                   }
                 if (r == GMP_RNDN)
                   {
                     int cmp;
                     if (mpfr_sub (u, v, x, GMP_RNDN))
                       err ("subtraction 2 should be exact",
-                           s, x, y, p, r, trint, inexact);
+                           s, x, y, p, (mp_rnd_t) r, trint, inexact);
                     cmp = mpfr_cmp_abs (t, u);
                     if (cmp > 0)
                       err ("faithful rounding, but not the nearest integer",
-                           s, x, y, p, r, trint, inexact);
+                           s, x, y, p, (mp_rnd_t) r, trint, inexact);
                     if (cmp < 0)
                       continue;
                     /* |t| = |u|: x is the middle of two consecutive
@@ -315,7 +318,8 @@
                         mpfr_div_2ui (y, y, 1, GMP_RNDZ);
                         if (!mpfr_integer_p (y))
                           err ("halfway case for mpfr_rint, result isn't an"
-                               " even integer", s, x, y, p, r, trint, inexact);
+                               " even integer",
+                               s, x, y, p, (mp_rnd_t) r, trint, inexact);
                         /* If floor(x) and ceil(x) aren't both representable
                            integers, the mantissa must be even. */
                         mpfr_sub (v, v, y, GMP_RNDN);
@@ -326,7 +330,8 @@
                                           + 1, GMP_RNDN);
                             if (!mpfr_integer_p (y))
                               err ("halfway case for mpfr_rint, mantissa isn't"
-                                   " even", s, x, y, p, r, trint, inexact);
+                                   " even", s, x, y, p, (mp_rnd_t) r, trint,
+                                   inexact);
                           }
                       }
                     else
@@ -335,7 +340,8 @@
                         if ((MPFR_SIGN (x) > 0 && inexact < 0) ||
                             (MPFR_SIGN (x) < 0 && inexact > 0))
                           err ("halfway case for mpfr_round, bad rounding"
-                               " direction", s, x, y, p, r, trint, inexact);
+                               " direction",
+                               s, x, y, p, (mp_rnd_t) r, trint, inexact);
                       }
                   }
               }
diff -Naur mpfr-2.1.0-p9/tests/tset.c mpfr-2.1.0-p10/tests/tset.c
--- mpfr-2.1.0-p9/tests/tset.c	2004-10-27 13:16:14.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tset.c	2005-01-27 17:39:19.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_set.
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -46,7 +46,7 @@
 {
   mp_prec_t p, q;
   mpfr_t x, y, z, u;
-  mp_rnd_t rnd;
+  int rnd;
   int inexact, cmp;
   mp_exp_t emax;
 
@@ -110,7 +110,7 @@
           mpfr_set_prec (y, q);
           for (rnd = 0; rnd < GMP_RND_MAX; rnd++)
             {
-              inexact = mpfr_set (y, x, rnd);
+              inexact = mpfr_set (y, x, (mp_rnd_t) rnd);
               cmp = mpfr_cmp (y, x);
               if (((inexact == 0) && (cmp != 0)) ||
                   ((inexact > 0) && (cmp <= 0)) ||
diff -Naur mpfr-2.1.0-p9/tests/tset_d.c mpfr-2.1.0-p10/tests/tset_d.c
--- mpfr-2.1.0-p9/tests/tset_d.c	2004-09-20 14:45:32.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tset_d.c	2005-01-27 17:39:32.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_set_d and mpfr_get_d.
 
-Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -108,16 +108,17 @@
        exit (1);
      }
 
-  mpfr_init2(z, 32);
-  mpfr_set_d(z, 1.0, 0);
+  mpfr_init2 (z, 32);
+  mpfr_set_d (z, 1.0, (mp_rnd_t) 0);
   if (mpfr_cmp_ui (z, 1))
     {
       mpfr_print_binary (z); puts ("");
       printf ("Error: 1.0 != 1.0\n");
       exit (1);
     }
-  mpfr_set_prec(x, 53); mpfr_init2(y, 53);
-  mpfr_set_d(x, d=-1.08007920352320089721e+150, 0);
+  mpfr_set_prec (x, 53);
+  mpfr_init2 (y, 53);
+  mpfr_set_d (x, d=-1.08007920352320089721e+150, (mp_rnd_t) 0);
   if (mpfr_get_d1 (x) != d)
     {
       mpfr_print_binary (x); puts ("");
@@ -126,9 +127,9 @@
       exit (1);
     }
 
-  mpfr_set_d(x, 8.06294740693074521573e-310, 0);
+  mpfr_set_d (x, 8.06294740693074521573e-310, (mp_rnd_t) 0);
   d = -6.72658901114033715233e-165;
-  mpfr_set_d(x, d, 0);
+  mpfr_set_d (x, d, (mp_rnd_t) 0);
   if (d != mpfr_get_d1 (x))
     {
       mpfr_print_binary (x);
@@ -149,7 +150,7 @@
 #else
       while (ABS(d) < DBL_MIN);
 #endif
-      mpfr_set_d (x, d, 0);
+      mpfr_set_d (x, d, (mp_rnd_t) 0);
       dd = mpfr_get_d1 (x);
       if (d != dd && !(Isnan(d) && Isnan(dd)))
         {
diff -Naur mpfr-2.1.0-p9/tests/tset_f.c mpfr-2.1.0-p10/tests/tset_f.c
--- mpfr-2.1.0-p9/tests/tset_f.c	2004-04-08 09:07:10.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tset_f.c	2005-01-27 17:40:15.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_set_f.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -47,7 +47,7 @@
   mpfr_set_f (x, y, GMP_RNDN);
 
   mpf_random2 (y, 10, 0);
-  mpfr_set_f (x, y, RND_RAND() );
+  mpfr_set_f (x, y, (mp_rnd_t) RND_RAND());
 
   /* bug found by Jean-Pierre Merlet */
   mpfr_set_prec (x, 256);
@@ -93,25 +93,25 @@
       mpf_set_prec (z, pr);
       mpf_random2 (z, z->_mp_prec, 0);
       mpfr_set_prec (x, pr);
-      mpfr_set_f (x, z, 0);
+      mpfr_set_f (x, z, (mp_rnd_t) 0);
     }
 
   /* Check for +0 */
   mpfr_set_prec (x, 53);
   mpf_set_prec (y, 53);
   mpf_set_ui (y, 0);
-  for(r = 0 ; r < GMP_RND_MAX ; r++)
+  for (r = 0 ; r < GMP_RND_MAX ; r++)
     {
       int i;
       for (i = -1; i <= 1; i++)
         {
           if (i)
             mpfr_set_si (x, i, GMP_RNDN);
-          inexact = mpfr_set_f (x, y, r);
+          inexact = mpfr_set_f (x, y, (mp_rnd_t) r);
           if (!MPFR_IS_ZERO(x) || !MPFR_IS_POS(x) || inexact)
             {
               printf ("mpfr_set_f(x,0) failed for %s, i = %d\n",
-                      mpfr_print_rnd_mode (r), i);
+                      mpfr_print_rnd_mode ((mp_rnd_t) r), i);
               exit (1);
             }
         }
diff -Naur mpfr-2.1.0-p9/tests/tset_ld.c mpfr-2.1.0-p10/tests/tset_ld.c
--- mpfr-2.1.0-p9/tests/tset_ld.c	2004-10-27 13:16:14.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tset_ld.c	2005-01-27 17:40:41.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_set_ld and mpfr_get_ld.
 
-Copyright 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -57,13 +57,13 @@
 static void
 check_set_get (long double d, mpfr_t x)
 {
-  mp_rnd_t r;
+  int r;
   long double e;
   int inex;
 
   for (r = 0; r < GMP_RND_MAX; r++)
     {
-      inex = mpfr_set_ld (x, d, r);
+      inex = mpfr_set_ld (x, d, (mp_rnd_t) r);
       if (inex != 0)
         {
           printf ("Error: mpfr_set_ld should be exact\n");
@@ -72,7 +72,7 @@
           mpfr_dump (x);
           exit (1);
         }
-      e = mpfr_get_ld (x, r);
+      e = mpfr_get_ld (x, (mp_rnd_t) r);
       if (e != d && !(Isnan_ld(e) && Isnan_ld(d)))
         {
           printf ("Error: mpfr_get_ld o mpfr_set_ld <> Id\n");
diff -Naur mpfr-2.1.0-p9/tests/tset_q.c mpfr-2.1.0-p10/tests/tset_q.c
--- mpfr-2.1.0-p9/tests/tset_q.c	2004-09-20 14:45:32.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tset_q.c	2005-01-27 17:40:57.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_set_q.
 
-Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -75,24 +75,24 @@
   mpq_t y;
   mpfr_t x;
   int inexact;
-  mp_rnd_t r;
+  int r;
 
   /* Check for +0 */
-  mpfr_init(x);
-  mpq_init(y);
-  mpq_set_si(y, 0, 1);
-  for(r = 0 ; r < GMP_RND_MAX ; r++)
+  mpfr_init (x);
+  mpq_init (y);
+  mpq_set_si (y, 0, 1);
+  for (r = 0; r < GMP_RND_MAX; r++)
     {
-      inexact = mpfr_set_q(x, y, r);
+      inexact = mpfr_set_q(x, y, (mp_rnd_t) r);
       if (!MPFR_IS_ZERO(x) || !MPFR_IS_POS(x) || inexact)
         {
           printf("mpfr_set_q(x,0) failed for %s\n",
-                 mpfr_print_rnd_mode(r));
+                 mpfr_print_rnd_mode ((mp_rnd_t) r));
           exit(1);
         }
     }
-  mpfr_clear(x);
-  mpq_clear(y);
+  mpfr_clear (x);
+  mpq_clear (y);
 }
 
 int
diff -Naur mpfr-2.1.0-p9/tests/tset_si.c mpfr-2.1.0-p10/tests/tset_si.c
--- mpfr-2.1.0-p9/tests/tset_si.c	2004-10-27 13:16:14.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tset_si.c	2005-01-27 17:41:29.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_set_si and mpfr_set_ui.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -72,7 +72,7 @@
   long k, z, d, N;
   unsigned long zl, dl;
   int inex;
-  mp_rnd_t r;
+  int r;
   mp_exp_t emax;
 
   tests_start_mpfr ();
@@ -167,23 +167,23 @@
       exit (1);
     }
 
-  for(r = 0 ; r < GMP_RND_MAX ; r++)
+  for (r = 0 ; r < GMP_RND_MAX ; r++)
     {
-      mpfr_set_si (x, -1, r);
-      mpfr_set_ui (x, 0, r);
+      mpfr_set_si (x, -1, (mp_rnd_t) r);
+      mpfr_set_ui (x, 0, (mp_rnd_t) r);
       if (MPFR_IS_NEG (x) )
 	{
 	  printf ("mpfr_set_ui (x, 0) gives -0 for %s\n", 
-		  mpfr_print_rnd_mode(r));
+		  mpfr_print_rnd_mode ((mp_rnd_t) r));
 	  exit (1);
 	}
 
-      mpfr_set_si (x, -1, r);
-      mpfr_set_si (x, 0, r);
-      if (MPFR_IS_NEG (x) )
+      mpfr_set_si (x, -1, (mp_rnd_t) r);
+      mpfr_set_si (x, 0, (mp_rnd_t) r);
+      if (MPFR_IS_NEG (x))
 	{
 	  printf ("mpfr_set_si (x, 0) gives -0 for %s\n",
-		  mpfr_print_rnd_mode(r) );
+		  mpfr_print_rnd_mode ((mp_rnd_t) r));
 	  exit (1);
 	}
     }
diff -Naur mpfr-2.1.0-p9/tests/tset_str.c mpfr-2.1.0-p10/tests/tset_str.c
--- mpfr-2.1.0-p9/tests/tset_str.c	2004-10-27 13:16:14.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tset_str.c	2005-01-27 17:42:18.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_set_str.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -111,7 +111,7 @@
 
   bd = randlimb () & 8;
 
-  str2 = str = (*__gmp_allocate_func) (nc * sizeof(char));
+  str2 = str = (char*) (*__gmp_allocate_func) (nc * sizeof(char));
 
   if (bd)
     {
@@ -211,13 +211,13 @@
 	baseprec = prec;
       else
 	baseprec = 1 + (prec - 2 + logbase) / logbase;
-      str = mpfr_get_str (NULL, &e, base, baseprec, x, k);
-      mpfr_set_str (y, str, base, k);
+      str = mpfr_get_str (NULL, &e, base, baseprec, x, (mp_rnd_t) k);
+      mpfr_set_str (y, str, base, (mp_rnd_t) k);
       MPFR_EXP(y) += logbase * (e - strlen (str));
       if (mpfr_cmp (x, y))
         {
           printf ("mpfr_set_str o mpfr_get_str <> id for rnd_mode=%s\n",
-                  mpfr_print_rnd_mode (k));
+                  mpfr_print_rnd_mode ((mp_rnd_t) k));
           printf ("x=");
           mpfr_print_binary (x);
           puts ("");
@@ -743,7 +743,7 @@
     mpfr_set_prec (x, mp_bits_per_limb); /* x and y have only one limb */
     mpfr_set_prec (y, mp_bits_per_limb);
 
-    str = (*__gmp_allocate_func) (N + 20);
+    str = (char*) (*__gmp_allocate_func) (N + 20);
 
     mpfr_set_ui (x, 1, GMP_RNDN); /* ensures that x is not NaN or Inf */
     for (; nb_digit < N; nb_digit *= 10)
diff -Naur mpfr-2.1.0-p9/tests/tset_z.c mpfr-2.1.0-p10/tests/tset_z.c
--- mpfr-2.1.0-p9/tests/tset_z.c	2004-10-27 13:16:14.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tset_z.c	2005-01-27 17:43:31.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_set_z.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -31,17 +31,18 @@
   mpz_t y;
   mpfr_t x;
   int inexact, r;
+
   /* Check for +0 */
-  mpfr_init(x);
-  mpz_init(y);
-  mpz_set_si(y, 0);
-  for(r = 0 ; r < GMP_RND_MAX ; r++)
+  mpfr_init (x);
+  mpz_init (y);
+  mpz_set_si (y, 0);
+  for(r = 0; r < GMP_RND_MAX; r++)
     {
-      inexact = mpfr_set_z(x, y, r);
+      inexact = mpfr_set_z (x, y, (mp_rnd_t) r);
       if (!MPFR_IS_ZERO(x) || !MPFR_IS_POS(x) || inexact)
         {
           printf("mpfr_set_z(x,0) failed for %s\n",
-                 mpfr_print_rnd_mode(r));
+                 mpfr_print_rnd_mode ((mp_rnd_t) r));
           exit(1);
         }
     }
@@ -129,11 +130,12 @@
   tests_start_mpfr ();
 
   check_large ();
-  check (0, 0);
+  check (0, (mp_rnd_t) 0);
   for (j = 0; j < 200000; j++)
-    check (randlimb () & LONG_MAX, RND_RAND () );
-  check0();
+    check (randlimb () & LONG_MAX, (mp_rnd_t) RND_RAND ());
+  check0 ();
 
   tests_end_mpfr ();
+
   return 0;
 }
diff -Naur mpfr-2.1.0-p9/tests/tsqr.c mpfr-2.1.0-p10/tests/tsqr.c
--- mpfr-2.1.0-p9/tests/tsqr.c	2004-07-20 09:09:34.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tsqr.c	2005-01-27 17:05:52.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_sqr.
 
-Copyright 2004 Free Software Foundation.
+Copyright 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -66,7 +66,7 @@
 void check_random(mpfr_prec_t p)
 {
   mpfr_t x,y,z;
-  mp_rnd_t r;
+  int r;
   int i, inexact1, inexact2;
 
   mpfr_inits2(p, x, y, z, NULL);
@@ -74,14 +74,14 @@
     {
       mpfr_random (x);
       if (MPFR_IS_PURE_FP(x))
-        for(r = 0 ; r < GMP_RND_MAX ; r++)
+        for (r = 0 ; r < GMP_RND_MAX ; r++)
           {
-            inexact1 = mpfr_mul (y, x, x, r);
-            inexact2 = mpfr_sqr (z, x, r);
-            if (mpfr_cmp(y, z))
-              error1 (r,p,x,y,z);
+            inexact1 = mpfr_mul (y, x, x, (mp_rnd_t) r);
+            inexact2 = mpfr_sqr (z, x, (mp_rnd_t) r);
+            if (mpfr_cmp (y, z))
+              error1 ((mp_rnd_t) r,p,x,y,z);
             if (inexact1 != inexact2)
-              error2 (r,p,x,y,inexact1,inexact2);
+              error2 ((mp_rnd_t) r,p,x,y,inexact1,inexact2);
           }
     }
   mpfr_clears(x,y,z,NULL);
diff -Naur mpfr-2.1.0-p9/tests/tsqrt.c mpfr-2.1.0-p10/tests/tsqrt.c
--- mpfr-2.1.0-p9/tests/tsqrt.c	2004-02-16 18:23:49.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tsqrt.c	2005-01-27 17:44:44.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_sqrt.
 
-Copyright 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -304,7 +304,7 @@
   mpfr_init2 (y, p);
   mpfr_init2 (z, 2*p);
   mpfr_random (x);
-  rnd = RND_RAND();
+  rnd = (mp_rnd_t) RND_RAND();
   inexact = mpfr_sqrt (y, x, rnd);
   if (mpfr_mul (z, y, y, rnd)) /* exact since prec(z) = 2*prec(y) */
     {
diff -Naur mpfr-2.1.0-p9/tests/tsub.c mpfr-2.1.0-p10/tests/tsub.c
--- mpfr-2.1.0-p9/tests/tsub.c	2004-02-12 12:38:17.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tsub.c	2005-01-27 17:44:55.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_sub.
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -411,14 +411,14 @@
                 : MPFR_EXP(u) - MPFR_EXP(x);
               pz = pz + MAX(MPFR_PREC(x), MPFR_PREC(u));
               mpfr_set_prec (z, pz);
-              rnd = RND_RAND();
+              rnd = (mp_rnd_t) RND_RAND();
               if (mpfr_sub (z, x, u, rnd))
                 {
                   printf ("z <- x - u should be exact\n");
                   exit (1);
                 }
                 {
-                  rnd = RND_RAND ();
+                  rnd = (mp_rnd_t) RND_RAND ();
                   inexact = mpfr_sub (y, x, u, rnd);
                   cmp = mpfr_cmp (y, z);
                   if (((inexact == 0) && (cmp != 0)) ||
diff -Naur mpfr-2.1.0-p9/tests/tsub1sp.c mpfr-2.1.0-p10/tests/tsub1sp.c
--- mpfr-2.1.0-p9/tests/tsub1sp.c	2004-10-27 13:16:15.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tsub1sp.c	2005-01-27 17:45:10.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_sub1sp.
 
-Copyright 2003, 2004 Free Software Foundation.
+Copyright 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -44,7 +44,7 @@
 #define STD_ERROR \
             {\
               printf("ERROR: for %s and p=%lu and i=%d:\nY=",\
-                     mpfr_print_rnd_mode(r), p, i);\
+                     mpfr_print_rnd_mode ((mp_rnd_t) r), p, i);\
                mpfr_print_binary(y);\
                printf("\nZ="); mpfr_print_binary(z);\
                printf("\nReal: "); mpfr_print_binary(x2);\
@@ -56,7 +56,7 @@
 #define STD_ERROR2 \
             {\
               printf("ERROR: for %s and p=%lu and i=%d:\nY=",\
-                      mpfr_print_rnd_mode(r), p, i);\
+                      mpfr_print_rnd_mode ((mp_rnd_t) r), p, i);\
                mpfr_print_binary(y);\
                printf("\nZ="); mpfr_print_binary(z);\
                printf("\nR="); mpfr_print_binary(x);\
@@ -68,7 +68,7 @@
 void check_random(mpfr_prec_t p)
 {
   mpfr_t x,y,z,x2;
-  mp_rnd_t r;
+  int r;
   int i, inexact1, inexact2;
 
   mpfr_inits2(p, x,y,z,x2,NULL);
@@ -80,8 +80,8 @@
       if (MPFR_IS_PURE_FP(y) && MPFR_IS_PURE_FP(z))
         for(r = 0 ; r < GMP_RND_MAX ; r++)
           {
-            inexact1 = mpfr_sub1(x2, y, z, r);
-            inexact2 = mpfr_sub1sp(x, y, z, r);
+            inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+            inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
             if (mpfr_cmp(x, x2))
               STD_ERROR;
             if (inexact1 != inexact2)
@@ -95,7 +95,7 @@
 void check_special(void)
 {
   mpfr_t x,y,z,x2;
-  mp_rnd_t r;
+  int r;
   mpfr_prec_t p;
   int i = -1, inexact1, inexact2;
   mp_exp_t es;
@@ -113,7 +113,7 @@
       mpfr_set_str_binary (y,
        "0.10110111101101110010010010011011000001101101011011001E31");
 
-      mpfr_sub1sp(x, y, y, r);
+      mpfr_sub1sp (x, y, y, (mp_rnd_t) r);
       if (mpfr_cmp_ui(x, 0))
         {
           printf("Error for x-x with p=%lu. Expected 0. Got:", p);
@@ -121,8 +121,8 @@
           exit(1);
         }
 
-      mpfr_set(z, y, r);
-      mpfr_sub1sp(x, y, z, r);
+      mpfr_set(z, y, (mp_rnd_t) r);
+      mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp_ui(x, 0))
         {
           printf("Error for x-y with y=x and p=%lu. Expected 0. Got:", p);
@@ -132,8 +132,8 @@
       /* diff = 0 */
       mpfr_set_str_binary (y,
        "0.10110111101101110010010010011011001001101101011011001E31");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -142,8 +142,8 @@
       /* Diff = 1 */
       mpfr_set_str_binary (y,
        "0.10110111101101110010010010011011000001101101011011001E30");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -152,8 +152,8 @@
       /* Diff = 2 */
       mpfr_set_str_binary (y,
        "0.10110111101101110010010010011011000101101101011011001E32");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -162,8 +162,8 @@
       /* Diff = 32 */
       mpfr_set_str_binary (y,
        "0.10110111101101110010010010011011000001101101011011001E63");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -172,8 +172,8 @@
       /* Diff = 52 */
       mpfr_set_str_binary (y,
        "0.10110111101101110010010010011011010001101101011011001E83");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -182,8 +182,8 @@
       /* Diff = 53 */
       mpfr_set_str_binary (y,
        "0.10110111101101110010010010011111000001101101011011001E31");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -192,8 +192,8 @@
       /* Diff > 200 */
       mpfr_set_str_binary (y,
        "0.10110111101101110010010010011011000001101101011011001E331");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -203,8 +203,8 @@
        "0.10000000000000000000000000000000000000000000000000000E31");
       mpfr_set_str_binary (z,
        "0.11111111111111111111111111111111111111111111111111111E30");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -214,8 +214,8 @@
        "0.10000000000000000000000000000000000000000000000000000E31");
       mpfr_set_str_binary (z,
        "0.11111111111111111111111111111111111111111111111111111E29");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -225,8 +225,8 @@
        "0.10000000000000000000000000000000000000000000000000000E52");
       mpfr_set_str_binary (z,
        "0.10000000000010000000000000000000000000000000000000000E00");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -236,9 +236,9 @@
         "0.11100000000000000000000000000000000000000000000000000E53");
       mpfr_set_str_binary (z,
         "0.10000000000000000000000000000000000000000000000000000E00");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(z, y, z, r);
-      mpfr_set(x, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(z, y, z, (mp_rnd_t) r);
+      mpfr_set(x, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -248,8 +248,8 @@
        "0.10000000000000000000000000000000000000000000000000000E53");
       mpfr_set_str_binary (z,
        "0.10100000000000000000000000000000000000000000000000000E00");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -259,8 +259,8 @@
         "0.10000000000000000000000000000000000000000000000000000E54");
       mpfr_set_str_binary (z,
         "0.10100000000000000000000000000000000000000000000000000E00");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -275,8 +275,8 @@
       "0.100000000000000000000000000000000000000000000000000000000000000E62");
       mpfr_set_str_binary (z,
       "0.110000000000000000000000000000000000000000000000000000000000000E00");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -292,8 +292,8 @@
       "0.1100000000000000000000000000000000000000000000000000000000000000E31");
       mpfr_set_str_binary (z,
       "0.1111111111111111111111111110000000000000000000000000011111111111E29");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -303,8 +303,8 @@
       "0.1000000000000000000000000000000000000000000000000000000000000000E63");
       mpfr_set_str_binary (z,
       "0.1011000000000000000000000000000000000000000000000000000000000000E00");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -314,8 +314,8 @@
       "0.1000000000000000000000000000000000000000000000000000000000000000E63");
       mpfr_set_str_binary (z,
       "0.1110000000000000000000000000000000000000000000000000000000000000E00");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -325,8 +325,8 @@
         "0.10000000000000000000000000000000000000000000000000000000000000E63");
       mpfr_set_str_binary (z,
         "0.10000000000000000000000000000000000000000000000000000000000000E00");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -336,8 +336,8 @@
       "0.1000000000000000000000000000000000000000000000000000000000000000E64");
       mpfr_set_str_binary (z,
       "0.1010000000000000000000000000000000000000000000000000000000000000E00");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -351,8 +351,8 @@
       mpfr_set_str_binary (z,
       "0.1100000000000000000000000000000000000000000000000000000000000000"
                           "E-1073741823");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -366,8 +366,8 @@
 
       mpfr_set_str_binary (y, "0.100000000E1");
       mpfr_set_str_binary (z, "0.100000000E-8");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -381,8 +381,8 @@
 
       mpfr_set_str_binary (y, "-0.1011110000111100010111011100110100E-18");
       mpfr_set_str_binary (z, "0.1000101010110011010101011110000000E-14");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -398,8 +398,8 @@
 "0.1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000E1");
       mpfr_set_str_binary (z,
 "0.1011111000100111000011001000011101010101101100101010101001000001110100001101110110001110111010000011101001100010111110001100E-31");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -415,8 +415,8 @@
      "0.111000110011000001000111101010111011110011101001101111111110000011100101000001001010110010101010011001010100000001110011110001010101101010001011101110100100001011110100110000101101100011010001001011011010101010000010001101001000110010010111111011110001111101001000101101001100101100101000E80");
       mpfr_set_str_binary (z,
      "-0.100001111111101001011010001100110010100111001110000110011101001011010100001000000100111011010110110010000000000010101101011000010000110001110010100001100101011100100100001011000100011110000001010101000100011101001000010111100000111000111011001000100100011000100000010010111000000100100111E-258");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -432,8 +432,8 @@
 "0.1111101110100110110110100010101011101001100010100011110110110010010011101100101111100E-4");
       mpfr_set_str_binary (z,
 "0.1111101110100110110110100010101001001000011000111000011101100101110100001110101010110E-4");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -449,8 +449,8 @@
       mpfr_set_str_binary (z,
                           "0.10000000000000000000000000000000"
                           "00000000000000000000000000000001E0");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -462,8 +462,8 @@
       mpfr_set_str_binary (z,
                           "0.10000000000000000000000000000000"
                           "00000000000000000000000000000001E0");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -478,8 +478,8 @@
       mpfr_set_str_binary (z,
                           "0.10000000000000000000000000000000"
                           "00000000000000000000000000000001E-1023");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
@@ -491,8 +491,8 @@
       mpfr_set_str_binary (z,
                            "0.1000000000000000000000000000000"
                            "000000000000000000000000000000E-1023");
-      inexact1 = mpfr_sub1(x2, y, z, r);
-      inexact2 = mpfr_sub1sp(x, y, z, r);
+      inexact1 = mpfr_sub1(x2, y, z, (mp_rnd_t) r);
+      inexact2 = mpfr_sub1sp(x, y, z, (mp_rnd_t) r);
       if (mpfr_cmp(x, x2))
         STD_ERROR;
       if (inexact1 != inexact2)
diff -Naur mpfr-2.1.0-p9/tests/tsum.c mpfr-2.1.0-p10/tests/tsum.c
--- mpfr-2.1.0-p9/tests/tsum.c	2004-02-20 13:15:44.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tsum.c	2005-01-27 17:47:10.000000000 +0000
@@ -1,6 +1,6 @@
 /* tsum -- test file for the list summation function
 
-Copyright 2004 Free Software Foundation.
+Copyright 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -100,7 +100,7 @@
   mpfr_ptr *tabtmp;
   unsigned long i, n;
   mp_prec_t f;
-  mp_rnd_t rnd_mode;
+  int rnd_mode;
   mpfr_srcptr *perm;
   mpfr_t sum, real_sum, real_non_rounded;
 
@@ -118,8 +118,8 @@
   algo_exact (real_non_rounded, tab, n, f);
   for (rnd_mode = 0; rnd_mode < GMP_RND_MAX; rnd_mode++)
   {
-      mpfr_list_sum (sum, tab, n, rnd_mode);
-      mpfr_set (real_sum, real_non_rounded, rnd_mode);
+      mpfr_list_sum (sum, tab, n, (mp_rnd_t) rnd_mode);
+      mpfr_set (real_sum, real_non_rounded, (mp_rnd_t) rnd_mode);
       if (mpfr_cmp (real_sum, sum) != 0)
       {
           printf ("mpfr_list_sum incorrect.\n");
@@ -142,8 +142,8 @@
   
   for (rnd_mode = 0; rnd_mode < GMP_RND_MAX; rnd_mode++)
   {
-      mpfr_list_sum (sum, tab, n, rnd_mode);
-      mpfr_set (real_sum, real_non_rounded, rnd_mode);
+      mpfr_list_sum (sum, tab, n, (mp_rnd_t) rnd_mode);
+      mpfr_set (real_sum, real_non_rounded, (mp_rnd_t) rnd_mode);
       if (mpfr_cmp (real_sum, sum) != 0)
       {
           printf ("mpfr_list_sum incorrect.\n");
diff -Naur mpfr-2.1.0-p9/tests/tui_div.c mpfr-2.1.0-p10/tests/tui_div.c
--- mpfr-2.1.0-p9/tests/tui_div.c	2004-02-23 16:47:46.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tui_div.c	2005-01-27 17:47:39.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_ui_div.
 
-Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -51,7 +51,7 @@
   mp_prec_t px, py;
   int inexact, cmp;
   unsigned long int u;
-  mp_rnd_t rnd;
+  int rnd;
 
   mpfr_init (x);
   mpfr_init (y);
@@ -72,8 +72,8 @@
           mpfr_set_prec (z, py + px);
           for (rnd = 0; rnd < GMP_RND_MAX; rnd++)
             {
-              inexact = mpfr_ui_div (y, u, x, rnd);
-              if (mpfr_mul (z, y, x, rnd))
+              inexact = mpfr_ui_div (y, u, x, (mp_rnd_t) rnd);
+              if (mpfr_mul (z, y, x, (mp_rnd_t) rnd))
                 {
                   printf ("z <- y * x should be exact\n");
                   exit (1);
@@ -84,7 +84,7 @@
                   ((inexact < 0) && (cmp >= 0)))
                 {
                   printf ("Wrong inexact flag for u=%lu, rnd=%s\n",
-                          u, mpfr_print_rnd_mode (rnd));
+                          u, mpfr_print_rnd_mode ((mp_rnd_t) rnd));
                   printf ("expected %d, got %d\n", cmp, inexact);
                   printf ("x="); mpfr_print_binary (x); puts ("");
                   printf ("y="); mpfr_print_binary (y); puts ("");
diff -Naur mpfr-2.1.0-p9/tests/tui_pow.c mpfr-2.1.0-p10/tests/tui_pow.c
--- mpfr-2.1.0-p9/tests/tui_pow.c	2004-02-14 23:05:51.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tui_pow.c	2005-01-27 17:48:02.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_ui_pow and mpfr_ui_pow_ui.
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 Adapted from tarctan.c.
 
 This file is part of the MPFR Library.
@@ -221,7 +221,7 @@
           int nt;
           nt = randlimb () & INT_MAX;
 	  mpfr_random (x);
-	  rnd = RND_RAND ();
+	  rnd = (mp_rnd_t) RND_RAND ();
           check1 (x, prec, nt, rnd);
 	}
     }
diff -Naur mpfr-2.1.0-p9/tests/tzeta.c mpfr-2.1.0-p10/tests/tzeta.c
--- mpfr-2.1.0-p9/tests/tzeta.c	2004-02-24 09:12:03.000000000 +0000
+++ mpfr-2.1.0-p10/tests/tzeta.c	2005-01-27 17:48:11.000000000 +0000
@@ -1,6 +1,6 @@
 /* tzeta -- test file for the Riemann Zeta function
 
-Copyright 2003, 2004 Free Software Foundation.
+Copyright 2003, 2004, 2005 Free Software Foundation.
 Contributed by Jean-Luc Re'my and the Spaces project, INRIA Lorraine.
 
 This file is part of the MPFR Library.
@@ -215,7 +215,7 @@
       mpfr_init2 (s, prec);
       mpfr_init2 (z, prec);
       mpfr_set_str (s, argv[1], 10, GMP_RNDN);
-      rnd_mode = atoi(argv[3]);
+      rnd_mode = (mp_rnd_t) atoi(argv[3]);
 
       mpfr_zeta (z, s, rnd_mode);
       mpfr_out_str (stdout, 10, 0, z, GMP_RNDN);
diff -Naur mpfr-2.1.0-p10/rint.c mpfr-2.1.0-p11/rint.c
--- mpfr-2.1.0-p10/rint.c	2004-09-30 16:06:25.000000000 +0000
+++ mpfr-2.1.0-p11/rint.c	2005-01-28 13:52:33.000000000 +0000
@@ -1,6 +1,6 @@
 /* mpfr_rint -- Round to an integer.
 
-Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -205,8 +205,6 @@
           uj = un - ui;  /* lowest limb of the integer part in u */
           rj = rn - ui;  /* lowest limb of the integer part in r */
 
-          MPN_ZERO(rp, rj);
-
           if (rp != up)
             MPN_COPY(rp + rj, up + uj, ui);
 
@@ -270,6 +268,8 @@
                    (sh == 0 && (MPFR_ASSERTN (uj >= 1),
                                 up[uj - 1] & MPFR_LIMB_HIGHBIT) != 0));
             }
+
+          MPN_ZERO (rp-rj, rj);
         }
 
       if (sh != 0)
diff -Naur mpfr-2.1.0-p10/tests/trint.c mpfr-2.1.0-p11/tests/trint.c
--- mpfr-2.1.0-p10/tests/trint.c	2005-01-27 17:38:45.000000000 +0000
+++ mpfr-2.1.0-p11/tests/trint.c	2005-01-28 13:50:56.000000000 +0000
@@ -134,6 +134,19 @@
       exit (1);
     }
 
+  /* Bug found by  Mark J Watkins */
+  mpfr_set_prec (x, 84);
+  mpfr_set_str_binary (x, 
+   "0.110011010010001000000111101101001111111100101110010000000000000" \
+		       "000000000000000000000E32");
+  mpfr_round (x, x);
+  if (mpfr_cmp_str (x, "0.1100110100100010000001111011010100000000000000" \
+		    "00000000000000000000000000000000000000E32", 2, GMP_RNDN))
+    {
+      printf ("Rounding error when dest=src\n");
+      exit (1);
+    }
+
   mpfr_clear (x);
   mpfr_clear (y);
 }
diff -Naur mpfr-2.1.0-p11/exp.c mpfr-2.1.0-p12/exp.c
--- mpfr-2.1.0-p11/exp.c	2004-05-06 09:56:48.000000000 +0000
+++ mpfr-2.1.0-p12/exp.c	2005-01-29 11:39:51.000000000 +0000
@@ -1,6 +1,6 @@
 /* mpfr_exp -- exponential of a floating-point number
 
-Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 Contributed by the Spaces project.
 
 This file is part of the MPFR Library.
@@ -82,9 +82,9 @@
     {
       int signx = MPFR_SIGN(x);
 
+      MPFR_SET_POS(y);
       if (MPFR_IS_NEG_SIGN(signx) && (rnd_mode == GMP_RNDD))
         {
-          MPFR_SET_POS(y);
           mpfr_setmax (y, 0);  /* y = 1 - epsilon */
           return -1;
         }
diff -Naur mpfr-2.1.0-p11/tests/texp.c mpfr-2.1.0-p12/tests/texp.c
--- mpfr-2.1.0-p11/tests/texp.c	2005-01-27 17:24:50.000000000 +0000
+++ mpfr-2.1.0-p12/tests/texp.c	2005-01-29 11:36:41.000000000 +0000
@@ -31,6 +31,8 @@
   mpfr_t x, y;
 
   mpfr_inits2 (53, x, y, NULL);
+  /* y negative. If we forget to set the sign in mpfr_exp, we'll see it. */
+  mpfr_set_si (y, -1, GMP_RNDN);
   mpfr_set_str1 (x, op);
   mpfr_exp (y, x, rnd);
   if (mpfr_cmp_str1 (y, res) )
@@ -385,6 +387,8 @@
   compare_exp2_exp3(500);
   check_worst_cases();
   check3("0.0", GMP_RNDU, "1.0");
+  check3("-1e-170", GMP_RNDU, "1.0");
+  check3("-1e-170", GMP_RNDN, "1.0");
   check3("-8.88024741073346941839e-17", GMP_RNDU, "1.0");
   check3("8.70772839244701057915e-01", GMP_RNDN, "2.38875626491680437269");
   check3("1.0", GMP_RNDN, "2.71828182845904509080");
diff -Naur mpfr-2.1.0-p12/sub1.c mpfr-2.1.0-p13/sub1.c
--- mpfr-2.1.0-p12/sub1.c	2005-01-23 23:18:41.000000000 +0000
+++ mpfr-2.1.0-p13/sub1.c	2005-02-02 14:13:48.000000000 +0000
@@ -100,7 +100,7 @@
 	     So if we round to Zero, we have to remove one ulp.
 	     Otherwise the result is correctly rounded. */
 	  if (MPFR_IS_LIKE_RNDZ (rnd_mode, MPFR_IS_NEG (a))) {
-	    mpfr_nexttoward (a, c);
+	    (MPFR_IS_POS (a) ? mpfr_nextbelow : mpfr_nextabove) (a);
 	    return -MPFR_INT_SIGN (a);
 	  }
 	  return MPFR_INT_SIGN (a);
diff -Naur mpfr-2.1.0-p12/tests/tui_sub.c mpfr-2.1.0-p13/tests/tui_sub.c
--- mpfr-2.1.0-p12/tests/tui_sub.c	2004-04-05 08:53:04.000000000 +0000
+++ mpfr-2.1.0-p13/tests/tui_sub.c	2005-02-02 14:19:05.000000000 +0000
@@ -1,6 +1,6 @@
 /* Test file for mpfr_ui_sub.
 
-Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation.
+Copyright 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
 
 This file is part of the MPFR Library.
 
@@ -129,6 +129,12 @@
   else
     MPFR_ASSERTN(mpfr_cmpabs (x, y) == 0 && mpfr_sgn (x) != mpfr_sgn (y));
 
+  mpfr_set_prec (x, 73);
+  mpfr_set_str_binary (x, "0.1101111010101011011011100011010000000101110001011111001011011000101111101E-99");
+  mpfr_ui_sub (x, 1, x, GMP_RNDZ);
+  mpfr_nextabove (x);
+  MPFR_ASSERTN(mpfr_cmp_ui (x, 1) == 0);
+
   mpfr_clear (x);
   mpfr_clear (y);
   mpfr_clear (res);
diff -Naur mpfr-2.1.0-p13/sum.c mpfr-2.1.0-p14/sum.c
--- mpfr-2.1.0-p13/sum.c	2005-01-23 23:20:42.000000000 +0000
+++ mpfr-2.1.0-p14/sum.c	2005-02-14 13:49:29.000000000 +0000
@@ -212,7 +212,7 @@
 
   mpfr_count_sort (tab, n, perm);
 
-  initial_f = MPFR_PREC(tab[0]);
+  initial_f = MAX (MPFR_PREC(tab[0]), MPFR_PREC(ret));
   k = __gmpfr_ceil_log2 ((double) n) + 1;
   mpfr_init2 (cur_sum, initial_f);
   initial_guard_digits = k + 2;
@@ -227,7 +227,7 @@
   }
   while ((error_trap != 0) &&
           !(mpfr_can_round (cur_sum, MPFR_GET_EXP(cur_sum) - current_f + 2,
-                            GMP_RNDN, rnd, initial_f)));
+                            GMP_RNDN, rnd, MPFR_PREC(ret))));
   error_trap |= mpfr_set (ret, cur_sum, rnd);
   mpfr_clear (cur_sum);
   TMP_FREE(marker);
diff -Naur mpfr-2.1.0-p14/tan.c mpfr-2.1.0-p15/tan.c
--- mpfr-2.1.0-p14/tan.c	2004-05-12 14:57:10.000000000 +0000
+++ mpfr-2.1.0-p15/tan.c	2005-02-15 14:49:38.972926000 +0000
@@ -1,6 +1,6 @@
 /* mpfr_tan -- tangent of a floating-point number
 
-Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -44,6 +44,9 @@
 	}
     }
 
+  mpfr_save_emin_emax ();
+
+  /* Compute initial precision */
   precy = MPFR_PREC(y);
   m = precy + __gmpfr_ceil_log2 ((double) precy)
     + ABS (MPFR_GET_EXP (x)) + 13;
@@ -53,10 +56,13 @@
 
   for (;;)
     {
+      /* The only way to get an overflow is to get ~ Pi/2
+         But the result will be ~ 2^Prec(y). */
       mpfr_sin_cos (s, c, x, GMP_RNDN); /* err <= 1/2 ulp on s and c */
       mpfr_div (c, s, c, GMP_RNDN);     /* err <= 2 ulps */
-      if (MPFR_IS_INF(x) || mpfr_can_round (c, m - 1, GMP_RNDN, GMP_RNDZ,
-					    precy + (rnd_mode == GMP_RNDN)))
+      MPFR_ASSERTD (!MPFR_IS_SINGULAR (c));
+      if (MPFR_LIKELY (mpfr_can_round (c, m - 1, GMP_RNDN, GMP_RNDZ,
+                                       precy + (rnd_mode == GMP_RNDN))))
 	break;
       m += BITS_PER_MP_LIMB;
       mpfr_set_prec (s, m);
@@ -68,5 +74,6 @@
   mpfr_clear (s);
   mpfr_clear (c);
 
-  return inexact;
+  mpfr_restore_emin_emax ();
+  return mpfr_check_range (y, inexact, rnd_mode);
 }
diff -Naur mpfr-2.1.0-p15/sub1.c mpfr-2.1.0-p16/sub1.c
--- mpfr-2.1.0-p15/sub1.c	2005-02-02 14:13:48.000000000 +0000
+++ mpfr-2.1.0-p16/sub1.c	2005-02-16 10:40:00.808198000 +0000
@@ -127,7 +127,7 @@
 	     which means we get a wrong rounded result if x==1, 
 	     i.e. inexact= MPFR_EVEN_INEX */
 	  if (MPFR_UNLIKELY (inexact == MPFR_EVEN_INEX*MPFR_INT_SIGN (a))) {
-	    mpfr_nexttoward (a, c);
+	    (MPFR_IS_POS (a) ? mpfr_nextbelow : mpfr_nextabove) (a);
 	    inexact = -MPFR_INT_SIGN (a);
 	  }
 	  return inexact;
diff -Naur mpfr-2.1.0-p16/ui_sub.c mpfr-2.1.0-p17/ui_sub.c
--- mpfr-2.1.0-p16/ui_sub.c	2004-04-07 14:42:32.000000000 +0000
+++ mpfr-2.1.0-p17/ui_sub.c	2005-02-21 13:17:42.639432000 +0000
@@ -1,6 +1,6 @@
 /* mpfr_ui_sub -- subtract a floating-point number from an integer
 
-Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+Copyright 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
 This file is part of the MPFR Library.
 
@@ -28,7 +28,10 @@
   mpfr_t uu;
   mp_limb_t up[1];
   unsigned long cnt;
-  
+
+  if (MPFR_UNLIKELY (u == 0))
+    return mpfr_neg (y, x, rnd_mode);
+
   if (MPFR_UNLIKELY(MPFR_IS_SINGULAR(x)))
     {
       if (MPFR_IS_NAN(x))
@@ -47,7 +50,7 @@
 	/* u - 0 = u */
 	return mpfr_set_ui(y, u, rnd_mode);
     }
-  else if (MPFR_LIKELY(u))
+  else
     {
       MPFR_TMP_INIT1 (up, uu, BITS_PER_MP_LIMB);
       MPFR_ASSERTN(u == (mp_limb_t) u);
@@ -56,7 +59,4 @@
       MPFR_SET_EXP (uu, BITS_PER_MP_LIMB - cnt);
       return mpfr_sub (y, uu, x, rnd_mode);
     }
-  else
-    /* u == 0 BUT x != 0 */
-    return mpfr_neg (y, x, rnd_mode); /* if u=0, then set y to -x */
 }
